## 7. ベクトルロードストア命令

ベクトルロードとストア命令はベクトルレジスタとメモリ間で値を移動する。ベクトルロードとストア命令は要素のマスクが可能であり、インアクティブな要素に関しては例外を発生しない。マスクされたベクトルロードは書き込みベクトルレジスタグループ内のインアクティブな要素に対して値を更新しない。マスクされたストアはアクティブな要素のみをメモリに書き込む。

### 7.1. ベクトルロードストア命令エンコーディング

ベクトルロードとストア命令はスカラの浮動小数点ロードストア命令と同じメジャーオペコードを使用する(LOAD-FP/STORE-FP)。ベクトルロードとストアのエンコーディングは標準的なスカラの浮動小数点ロードストア命令の12ビットの即値フィールドを別の用途で使用し、さらなるベクトル命令エンコーディングに使用する。25ビット目は標準的なベクトルマスクビットが格納されている([Mask Encoding](https://riscv.github.io/documents/riscv-v-spec/#sec-vector-mask-encoding) を参照のこと)

```
LOAD-FPメジャーオペコードを使用したベクトルロード命令のフォーマット

31 29 28 26  25  24      20 19       15 14   12 11      7 6     0
 nf  | mop | vm |  lumop   |    rs1    | width |    vd   |0000111| VL*  unit-stride
 nf  | mop | vm |   rs2    |    rs1    | width |    vd   |0000111| VLS* strided
 nf  | mop | vm |   vs2    |    rs1    | width |    vd   |0000111| VLX* indexed
  3     3     1      5           5         3         5       7

STORE-FPメジャーオペコードを使用したベクトルストア命令のフォーマット

31 29 28 26  25  24      20 19       15 14   12 11      7 6     0
 nf  | mop | vm |  sumop   |    rs1    | width |   vs3   |0100111| VS*  unit-stride
 nf  | mop | vm |   rs2    |    rs1    | width |   vs3   |0100111| VSS* strided
 nf  | mop | vm |   vs2    |    rs1    | width |   vs3   |0100111| VSX* indexed
  3     3     1      5           5         3         5        7
```

| フィールド            | 説明                                                         |
| :-------------------- | :----------------------------------------------------------- |
| rs1[4:0]              | ベースアドレスを格納した整数レジスタを指定する。             |
| rs2[4:0]              | ストライドを格納した整数レジスタを指定する。                 |
| vs2[4:0]              | アドレスオフセットを格納したVレジスタを指定する。            |
| vs3[4:0]              | ストアデータを格納したVレジスタを指定する。                  |
| vd[4:0]               | ロード命令の書き込み先のVレジスタを指定する。                |
| vm                    | ベクトルマスク                                               |
| width[2:0]            | メモリ要素のサイズを指定する。FPスカラの場合と値のエンコーディングは同一である。 |
| mop[2:0]              | メモリのアドレッシングモードを指定する。                     |
| nf[2:0]               | セグメントロード・ストア命令のための、各セグメントのフィールド数を指定する。 |
| lumop[4:0]/sumop[4:0] | ユニットストライド命令のための追加のフィールドエンコーディングを指定する。 |

### 7.2. ベクトルロードストアアドレッシングモード

ベースとなるベクトル拡張ではユニットストライド・ストライド・インデックス(scatter/gather)アドレッシングモードをサポートしている。ベクトルロード・ストアのベースレジスタとストライドフィールドは整数レジスタ`x`で指定される。

すべてのベクトル命令のベース有効アドレスは整数レジスタの`rs1`で指定される。

ベクトルのユニットストライド操作はメモリ内に連続している要素に対して、ベースの有効アドレスから順番に操作を行う。

ベクトルストライド操作は、ベース有効アドレスから始まる最初のメモリ要素に対して捜査を行い、後続の要素に対しては`rs2`で指定される整数ベクトルレジスタの値に基づいてバイトオフセットを増加させながらアクセスを行う。

ベクトルインデックス操作命令は、各要素の有効アドレスに対して`vs2`で指定されるベクトルレジスタで指定されるベクトルオフセットを各要素に加算する。もしベクトルオフセット要素がXLENよりも小さい場合はベース有効アドレスとの加算前にXLENビットにゼロ拡張される。もしベクトルオフセット要素がXLENよりも小さい場合は、アドレス計算のために最も小さいXLENビットが使用される。

> 現在のベクトルインデックス命令のPoRでは、ベクトルのバイトオフセット(vs2)とベクトル読み書きのためのデータ(vs3/vd)が同一の長さである必要がある。1つの疑問として、べく鳥インデックス命令の中で2つのサイズのベクトルオペランドをどこでどうやって許容するかということである。例えば、64ビットアドレス空間を持つ実装でのscatter/gatherのバイト値は64ビット空間であり、しかしベクトルレジスタが64ビットの空間を持つ必要があるわけではない。

ベクトルアドレッシングモードは3ビットの`mop[2:0]`フィールドを用いてエンコーディングされる。

| mop [2:0] |      |      | 説明                       | オペコード  |
| :-------- | :--- | :--- | -------------------------- | ----------- |
| 0         | 0    | 0    | ゼロ拡張ユニットストライド | VLxU,VLE    |
| 0         | 0    | 1    | 予約                       |             |
| 0         | 1    | 0    | ゼロ拡張ストライド         | VLSxU, VLSE |
| 0         | 1    | 1    | ゼロ拡張インデックス       | VLXxU, VLXE |
| 1         | 0    | 0    | 符号拡張ユニットストライド | VLx (x!=E)  |
| 1         | 0    | 1    | 予約                       |             |
| 1         | 1    | 0    | 符号拡張ストライド         | VLSx (x!=E) |
| 1         | 1    | 1    | 符号拡張インデックス       | VLXx (x!=E) |

| mop [2:0] |      |      | 説明                       | オペコード |
| :-------- | :--- | :--- | -------------------------- | ---------- |
| 0         | 0    | 0    | ユニットストライド         | VSx        |
| 0         | 0    | 1    | 予約                       |            |
| 0         | 1    | 0    | ストライド                 | VSSx       |
| 0         | 1    | 1    | オーダー付きインデックス   | VSXx       |
| 1         | 0    | 0    | 予約                       |            |
| 1         | 0    | 1    | 予約                       |            |
| 1         | 1    | 0    | 予約                       |            |
| 1         | 1    | 1    | オーダーしないインデックス | VSUXx      |

ベクトルインデックスメモリ操作命令は2種類の形式がある。オーダー付きとアンオーダーである。インデックス・アンオーダーはメモリに書き込む順番について順序を守らない。

> インデックス・アンオーダー形式は実装最適化の可能性の1つとして追加した。実装では最適化を無視し、インデックス・オーダーと同じようにインデックス・アンオーダーを自由に実装できる。

ユニットストライドベクトル命令のアドレッシングモードにさらに追加されるフィールドでは、`lumop`と`sumop`フィールドを使ってユニットストライドロード・ストア命令のエンコーディングを拡張する。

| lumop[4] | [3]  | [2]  | [1]  | [0]  | Description                                |
| :------- | :--- | ---- | ---- | ---- | ------------------------------------------ |
| 0        | 0    | 0    | 0    | 0    | ユニットストライド                         |
| 0        | 0    | x    | x    | x    | 予約, x!=0                                 |
| 0        | 1    | 0    | 0    | 0    | すべてのレジスタに対してユニットストライド |
| 0        | 1    | x    | x    | x    | 予約, x!=0                                 |
| 1        | 0    | 0    | 0    | 0    | ユニットストライド。 fault-only-first      |
| 1        | x    | x    | x    | x    | 予約, x!=0                                 |

| sumop[4] | [3]  | [2]  | [1]  | [0]  | Description                                |
| :------- | :--- | ---- | ---- | ---- | ------------------------------------------ |
| 0        | 0    | 0    | 0    | 0    | ユニットストライド                         |
| 0        | 0    | x    | x    | x    | 予約, x!=0                                 |
| 0        | 1    | 0    | 0    | 0    | すべてのレジスタに対してユニットストライド |
| 0        | 1    | x    | x    | x    | 予約, x!=0                                 |
| 1        | x    | x    | x    | x    | 予約                                       |

`nf[2:0]`フィールドは各セグメント内のフィールドの数を示している。通常のベクトルロードとストア命令では`nf=0`であり、ベクトルレジスタグループとメモリ内で各要素が1つの値を動かすことを示している。`nf`が1以上になると、[Vector Load/Store Segment Instructions (`Zvlsseg`)](https://riscv.github.io/documents/riscv-v-spec/#sec-aos)に示すように複数の連続したフィールドに対してアクセスするために使用される。

> `nf`フィールドはセグメントロードストアのためのフィールドで、同じアドレスビットを使用する条件を置き換えるものである。オフセットは1つの整数の計算に置き換えることができ、またセグメントロードストアはメモリから要素を移動するのに強力なプリミティブを与えるものである。

`nf[2:0]`フィールドは、ロード・ストア命令の全体ベクトルレジスタに対して転送するベクトルレジスタの数をエンコードしている。

### 7.3. ベクトルロードストア : Widthのエンコーディング

ベクトルロードストアはwidth値を使用してエンコードされる。この値は浮動小数点ロードストアには存在せず、8ビット、16ビット、32ビットのメモリ要素を移動するためのベクトルロード・ストア命令のwidthが用意されている。また、SEWビット長のメモリ要素を扱うための4つ目のエンコーディングも用意されている。

|                      | Width [2:0] |      |      | メモリビット | レジスタビット | オペコード |
| :------------------- | :---------- | :--- | :--- | :----------- | -------------- | ---------- |
| 標準スカラFP         | 0           | 0    | 1    | 16           | FLEN           | FLH/FSH    |
| 標準スカラFP         | 0           | 1    | 0    | 32           | FLEN           | FLW/FSW    |
| 標準スカラFP         | 0           | 1    | 1    | 64           | FLEN           | FLD/FSD    |
| 標準スカラFP         | 1           | 0    | 0    | 128          | FLEN           | FLQ/FSQ    |
| ベクトルバイト       | 0           | 0    | 0    | vl*8         | vl*SEW         | VxB        |
| ベクトルハーフワード | 1           | 0    | 1    | vl*16        | vl*SEW         | VxH        |
| ベクトルワード       | 1           | 1    | 0    | vl*32        | vl*SEW         | VxW        |
| ベクトルエレメント   | 1           | 1    | 1    | vl*SEW       | vl*SEW         | VxE        |

メモリビットはメモリ中でアクセスされる要素のサイズである。

レジスタビットはレジスタ中でアクセスされる要素のサイズである。

固定サイズのベクトルロードは、書き込みレジスタのサイズがメモリ要素よりも大きい場合として、符号拡張するかゼロ拡張するかをオプションとして選択することができる。固定サイズのベクトルロードは、書き込みレジスタ要素のサイズがメモリ要素よりも小さい場合には不定命令例外を発生する。可変サイズのロードは、ゼロ拡張ロードのようにエンコードされ、現在予約されている可変サイズのロードの符号拡張エンコードが使用される。

### 7.4. ベクトルユニットストライド命令

```
    # ベクトルユニットストライドロード・ストア命令

    # vdは書き込みレジスタアドレス, rs1はベースアドレス, vm マスクのエンコーディング (v0.t or <無し>)
    vlb.v  vd, (rs1), vm # 8b signed
    vlh.v  vd, (rs1), vm # 16b signed
    vlw.v  vd, (rs1), vm # 32b signed

    vlbu.v vd, (rs1), vm # 8b unsigned
    vlhu.v vd, (rs1), vm # 16b unsigned
    vlwu.v vd, (rs1), vm # 32b unsigned

    vle.v  vd, (rs1), vm # SEW

    # vs3はストアデータ, rs1はベースアドレス, vmはマスクエンコーディング (v0.t or <無し>)
    vsb.v  vs3, (rs1), vm  # 8b store
    vsh.v  vs3, (rs1), vm  # 16b store
    vsw.v  vs3, (rs1), vm  # 32b store
    vse.v  vs3, (rs1), vm  # SEW store
```

### 7.5. ベクトルストライド命令

```
    # ベクトルストライドロード・ストア命令

    # vdは書き込みレジスタアドレス, rs1はベースアドレス, rs2はバイトストライド
    vlsb.v  vd, (rs1), rs2, vm # 8b
    vlsh.v  vd, (rs1), rs2, vm # 16b
    vlsw.v  vd, (rs1), rs2, vm # 32b

    vlsbu.v vd, (rs1), rs2, vm # unsigned 8b
    vlshu.v vd, (rs1), rs2, vm # unsigned 16b
    vlswu.v vd, (rs1), rs2, vm # unsigned 32b

    vlse.v  vd, (rs1), rs2, vm  # SEW

    # vs3はストアデータ, rs1はベースアドレス, rs2はバイトストライド
    vssb.v vs3, (rs1), rs2, vm  # 8b
    vssh.v vs3, (rs1), rs2, vm  # 16b
    vssw.v vs3, (rs1), rs2, vm  # 32b
    vsse.v vs3, (rs1), rs2, vm  # SEW
```

> 負の数、ゼロのストライド数もサポートされている。

### 7.6. ベクトルインデックスロードストア命令

```
    # ベクトルインデックスロードストア命令

    # vdは書き込み先レジスタアドレス, rs1はベースアドレス, vs2はインデックスの集合
    vlxb.v  vd, (rs1), vs2, vm  # 8b
    vlxh.v  vd, (rs1), vs2, vm  # 16b
    vlxw.v  vd, (rs1), vs2, vm  # 32b

    vlxbu.v vd, (rs1), vs2, vm  # 8b unsigned
    vlxhu.v vd, (rs1), vs2, vm  # 16b unsigned
    vlxwu.v vd, (rs1), vs2, vm  # 32b unsigned

    vlxe.v  vd, (rs1), vs2, vm  # SEW

    # ベクトル順序付きインデックストア命令
    # vs3はストアデータ, rs1はベースアドレス, vs2はインデックスの集合
    vsxb.v vs3, (rs1), vs2, vm  # 8b
    vsxh.v vs3, (rs1), vs2, vm  # 16b
    vsxw.v vs3, (rs1), vs2, vm  # 32b
    vsxe.v vs3, (rs1), vs2, vm  # SEW

    # ベクトルの順序無しインデックスストア命令
    vsuxb.v vs3, (rs1), vs2, vm  # 8b
    vsuxh.v vs3, (rs1), vs2, vm  # 16b
    vsuxw.v vs3, (rs1), vs2, vm  # 32b
    vsuxe.v vs3, (rs1), vs2, vm  # SEW
```

### 7.7. ユニットストライドFault-Only-Firstロード命令

ユニットストライドFault-Only-Firstロード命令は、終了条件がデータに依存するループ(whileループなど)において使用される。これらの命令は通常のロード命令と同一であるが、最初の要素についてのみ例外の判定を行う。もし要素のインデックス > 0で例外が発生すると、その要素と後続の要素は変更されず、ベクトル長`vl`はトラップが発生しないサイズまで縮退される。

```
    vlbff.v  vd, (rs1), vm # 8b
    vlhff.v  vd, (rs1), vm # 16b
    vlwff.v  vd, (rs1), vm # 32b

    vlbuff.v vd, (rs1), vm # unsigned 8b
    vlhuff.v vd, (rs1), vm # unsigned 16b
    vlwuff.v vd, (rs1), vm # unsigned 32b

    vleff.v  vd, (rs1), vm # SEW

ユニットストライドFault-only-first命令を用いたstrlenの例

# size_t strlen(const char *str)
# a0 holds *str

strlen:
    mv a3, a0             # レジスタの退避
    li t0, -1             # AVLの初期化
loop:
    vsetvli a1, t0, e8    # 最大長のベクトル長に設定する。
    vlbff.v v1, (a3)      # バイトロード
    csrr a1, vl           # 読み込んだバイト数を取得
    vmseq.vi v0, v1, 0    # v1[i] == 0の結果をv0[i]に格納する。
    vfirst.m a2, v0       # 最初に設定されたビットの位置を探す。
    add a3, a3, a1        # ポインタを進める。
    bltz a2, loop         # これ以上ある？

    add a0, a0, a1        # start + bump
    add a3, a3, a2        # インデックスの加算
    sub a0, a3, a0        # startからaddress+bumpの値を減算

    ret
```

> ベクトルストライド命令と、scatter/gather fault-only-first命令は大きなセキュリティホールとなるため定義されない。この命令では、ソフトウェアがトラップを発生させずに複数のランダムなページのアクセス性をチェックすることができるようになる。ユニットストライド版は即値で表現される連続した領域でしかチェック数rことができず、明らかなセキュリティ問題への影響とはならない。非連続なアクセスを用いるfault-only-first命令の対策は、将来のベクトル拡張で追加される予定である。

### 7.8. セグメントベクトルロード・ストア命令(`Zvlsseg`)

> この命令セット群はベースとなる"V"拡張に取り込まれる予定である。

セグメントベクトルロードストア命令はメモリ中の複数の連続したフィールド連続した複数のベクトルレジスタとの間で移動する命令である。

> これらの操作では、構造体のフィールドをアンパックすることで"Array-of-structures"のデータ型複数のベクトルレジスタに格納する操作をサポートする。

通常のロードストア命令では、メモリのサイズとしてwidthのエンコーディングが与えられ、サイズはすべての要素で同一である。そしてSEWはレジスタ要素のサイズが与えられる。

ベクトル命令エンコーディング中の3ビットの`nf`フィールドは符号なし整数で、セグメント当たりのフィールドの数**NFIELDS**を示している。

| nf[2] | [1]  | [0]  | NFIELDS |
| :---- | :--- | ---- | ------- |
| 0     | 0    | 0    | 1       |
| 0     | 0    | 1    | 2       |
| 0     | 1    | 0    | 3       |
| 0     | 1    | 1    | 4       |
| 1     | 0    | 0    | 5       |
| 1     | 0    | 1    | 6       |
| 1     | 1    | 0    | 7       |
| 1     | 1    | 1    | 8       |

LMULの設定は LMUL * NFIELDS ⇐ 8のように制約される必要があり、これを違反する場合は不正命令例外が発生する。

> LMUL * NFIELDSはセグメントロード・ストア命令によりアクセスされるベクトルレジスタの数を示している。この制約は、全体のアーキテクチャレジスタファイルの1/4を超える事は無いというものである。これはLMUL=8の場合と同じものである。この制約は将来の仕様の改定で緩和される可能性がある。

各フィールドはベクトルレジジスタグループの連続した番号を格納する。LMUL>1であれば、各フィールドは不空の連続したベクトルレジスタの数を保持することになり、各フィールドのレジスタグループは通常のベクトルレジスタのアライメントの制約を守る必要がある(例えば、LMUL=2かつNFIELD=4の場合は各フィールドのベクトルレジスタグループはベクトルレジスタの偶数番号から始まる必要があるが、ベクトルレジスタの8の倍数から始まる必要はない)。

> 初期の仕様ではベクトルレジスタ数に関数る制約が存在した柄、NFIELDSが2の累乗でない場合に、すべてのレジスタが使用できるように制約が緩和された。

もしセグメントれロードストア命令によりアクセスされるベクトルレジスタの数が31を超える場合、不正命令例外が発生する。

この制約は、将来より長い命令エンコーディングにより、より多くのベクトルレジスタを使用できるようになった場合の将来への互換性を取るための制約である。

`vl`レジスタは移動する構造体の数を示し、各ベクトルレジスタグループにてそうされる要素の数と同一である。すべての構造体において、マスク操作が可能である。

例外が発生すると、`vstart`は構造体の単位で格納されていることになる。

#### 7.8.1. ベクトルユニットストライドセグメントロードストア命令

ベクトルユニットストライドセグメントロードストア命令はパッキングしてある連続したセグメント("Array-of-structures")を、複数のベクトルレジスタグループとの間で転送するための命令である。

>  フィールドのサイズ後異なるセグメントでは、ソフトウェアは追加の命令を使用してフィールドをアンパックし、セグメントロード命令によりが値を別々のベクトルレジスタに格納する。

The assembler prefixes `vlseg`/`vsseg` are used for unit-stride segment loads and stores respectively.

アセンブラ命令では、`vlseg`/`vsseg`というプレフィックスを使い、ユニットストライドセグメントロード・ストア命令を表現する。

```
# フォーマット
vlseg<nf>{b,h,w}.v vd, (rs1),  vm    # ユニットストライド符号付きセグメントロード命令のテンプレート
vlseg<nf>e.v vd, (rs1), vm           # ユニットストライドセグメントロード命令のテンプレート
vlseg<nf>{b,h,w}u.v vd, (rs1), vm    # ユニットストライド符号なしセグメントロード命令のテンプレート
vsseg<nf>{b,h,w,e}.v vs3, (rs1), vm  # ユニットストライドセグメントストア命令のテンプレート

# 例
vlseg2b.v vd, (rs1), vm   # 符号付2*1バイトのセグメントをvd,vd+1に格納する。
vlseg3bu.v vd, (rs1), vm  # 符号なし3:1バイトのセグメントをvd,vd+1,vd+2に格納する。
vlseg7w.v vd, (rs1), vm   # 7*4バイトのセグメントをvd, vd+1, ... vd+6に格納する。
vlseg8e.v vd, (rs1), vm   # 8*SEWバイトのセグメントをvd, vd+1, ... vd+7に格納する。

vsseg3b.v vs3, (rs1), vm  # vs3,vs3+1,vs3+2のパックされた3*1バイトのセグメントをメモリに格納する。
```

ロード命令では、`vd`レジスタはセグメントからロードされた最初のフィールドを格納する。ストア命令では、`vs3`レジスタは各セグメントで最初にストアされたフィールドを提供するために読み込まれる。

```
    # 例1
    # メモリ中にパックされたRGBピクセルデータが格納されている(8bppで24ビット幅)
    vlseg3bu.v v8, (a0), vm
    # v8 は赤のピクセルが書きこまれる。
    # v9 は緑のピクセルが書き込まれる。
    # v10 は青のピクセルが書き込まれる。

    # 例2
    # メモリ中に複素数が格納されている。32ビットの実数部と32ビットの虚数部。
    vlseg2w.v v8, (a0), vm
    # v8 は実数部が書き込まれる。
    # v9 は虚数部が書き込まれる。
```

ユニットストライド命令のfault-only-first命令も定義されている。

```
# ベクトルfault-only-firstユニットストライドセグメントロードストア命令のテンプレート
vlseg<nf>{b,h,w}ff.v vd, (rs1),  vm    # ユニットストライド符号付fault-only-firstセグメントロード
vlseg<nf>eff.v vd, (rs1),  vm          # ユニットストライドfault-only-firstセグメントロード
vlseg<nf>{b,h,w}uff.v vd, (rs1),   vm  # ユニットストライド符号なしfault-only-firstセグメントロード
```

#### 7.8.2. ベクトルストライドセグメントロードストア命令

ベクトルストライドセグメントロードストア命令は、`rs2` GPRに格納されたバイトストライドオフセットに基づいて離れ離れの連続したセグメントに格納されたデータを移動するための命令である。

> 負数とゼロのストライド数もサポートする。

```
    # フォーマット
    vlsseg<nf>{b,h,w}.v vd, (rs1), rs2, vm    # ストライド符号付セグメントロード
    vlsseg<nf>e.v vd, (rs1), rs2, vm          # ストライドセグメントロード
    vlsseg<nf>{b,h,w}u.v vd, (rs1), rs2, vm   # ストライド符号なしセグメントロード
    vssseg<nf>{b,h,w,e}.v vs3, (rs1), rs2, vm # ストライドセグメントストア

    # 例
    vlsseg3b.v v4, (x5), x6   # アドレスx5+i*x6のデータをv4[i]に格納し、
                              #  アドレスx5+i*x6+1のデータをv5[i]に格納し、
                              #  アドレスx5+i*x6+2のデータをv6[i]に格納する。

    # Examples
    vssseg2w.v v2, (x5), x6   # v2[i]をアドレスx5+i*x6に格納し、
                              #   v3[i]をアドレスx5+i*x6+4に格納する。
```

バイトストライドでのストライドセグメントストア命令では、セグメントがメモリ内でオーバラップすることがあるが、セグメントは要素の順番で書き込まれなければならない。

#### 7.8.3. ベクトルインデックスセグメントロードストア命令

ベクトルインデックスセグメントロードストア命令はスカラのベースアドレス`rs1`を`vs2`に格納されているバイトオフセットの値と加算してそれをセグメントのアドレスとし、データを転送するための命令である。

```
    # フォーマット
    vlxseg<nf>{b,h,w}.v vd, (rs1), vs2, vm    # 符号付インデックスセグメントロード
    vlxseg<nf>e.v vd, (rs1), vs2, vm          # インデックスセグメントロード
    vlxseg<nf>{b,h,w}u.v vd, (rs1), vs2, vm   # 符号なしインデックスセグメントロード
    vsxseg<nf>{b,h,w,e}.v vs3, (rs1), vs2, vm # インデックスセグメントストア

    # 例
    vlxseg3bu.v v4, (x5), v3   # アドレスx5+v3[i]のデータをv4[i]に格納し、
                               #  x5+v3[i]+1のアドレスをv5[i]に格納し、
                               #  x5+v3[i]+2のアドレスをv6[i]に格納する。

    # 例
    vsxseg2w.v v2, (x5), v5   # v2[i]のワードデータをアドレスx5+v5[i]にストアし、
                              #   v3[i]のワードデータをx5+v5[i]+4にストアする。
```

ベクトルインデックスセグメントロードでは、書き込みレジスタグループは`vs2`で指定されるソースベクトルレジスタグループとオーバ六腑することはできず、マスクを使用する場合はマスクレジスタとオーバラップしてはならない。そのような場合には不正命令例外が発生する。

> この制約により、インデックス付きセグメントロード命令が構造体をロードしている最中に例外が発生した場合にリスタートできるようになる。

順序付きセグメントストア命令のみ定義されている。セグメントは要素の順番に沿って書き込まれる必要がある。

### 7.9. 全体ベクトルレジスタ・ベクトルロードストア命令

これらの命令はまだ初期検討段階で、仕様に含まれるかどうかは未定である。

こられの命令はすべてのベクトルレジスタ(例えば、VLENビット)に対してロード・ストアを実行するための命令で、`vl`および`vtype`レジスタの設定を無視することができる。

こられの命令は現在のコンテキストにおけるベクトルレジスタの`type`および長さが不定である場合にベクトルレジスタの退避・復帰を行うために使用されるか、`vl`および`vtype`を変更することがコスト高である場合に使用される。

使用例としてはコンパイラのレジスタスピルアウトや、ベクトルレジスタ経由で関数呼び出しの引数を渡す場合、例外ハンドラ、コンテキストスイッチなどである。

```
ベクトルレジスタ全体を取り扱うベクトルロード命令はLOAD-FP メジャーオペコードに配置される。
31 29 28 26  25  24      20 19       15 14   12 11      7 6     0
 nf  | 000 | 1 |   01000   |    rs1    |  111  |    vd   |0000111| VL<nf>R

ベクトルレジスタ全体を取り扱うベクトルストア命令はSTORE-FPメジャーオペコード内に配置される。
31 29 28 26  25  24      20 19       15 14   12 11      7 6     0
 nf  | 000 | 1 |   01000   |    rs1    |  111  |   vs3   |0100111| VS<nf>R
```

これらの命令はマスクを使用しないユニットストライドのロードストア命令に似ており、ベースアドレスはスカラの整数レジスタを`rs1`を使用して指定する。ロード命令は`vd`によって指定される1つのベクトルレジスタに転送し、ストア命令は`vs3`によって指定される1つのベクトルレジスタをストアする。これらのレジスタはSEW=8およびLMUL=1であるかのように動作する。

全体ベクトルロード命令はマスクされていないゼロ拡張のユニットストライドロード命令のように動作する。`nf`フィールドのエンコーディングによっていくつのベクトルレジスタをロード・ストアに使用するかを指定する。全体ベクトルストア命令はマスクされていないユニットストライドのストア命令のエンコーディングと似ている。現在のベース仕様では`nf=0`しかサポートされておらず、他の`nf`の値は予約である。将来の拡張では、複数のレジスタが転送される場合にベクトルレジスタの値をLMUL=1であるかのように、最下位のベクトルレジスタの値から最下位のメモリアドレスに連続して複数のメモリ領域に格納できるようになる。`nf`フィールドのエンコードによってベースのレジスタから順番にいくつのベクトルレジスタを転送するかが決められる。ベースレジスタ+`nf`の値は31を超えてはならず、超えた場合は不定命令例外が発生する。

```
   # Format
   vl1r.v v3, (a0)      # Load v3 with VLEN/8 bytes held at address in a0

   vs1r.v v3, (a1)      # Store v3 to address in a1
```
