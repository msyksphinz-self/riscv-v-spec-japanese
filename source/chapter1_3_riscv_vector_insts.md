Version 0.9

Contributors include: Alon Amid, Krste Asanovic, Allen Baum, Alex Bradbury, Tony Brewer, Chris Celio, Aliaksei Chapyzhenka, Silviu Chiricescu, Ken Dockser, Bob Dreyer, Roger Espasa, Sean Halle, John Hauser, David Horner, Bruce Hoult, Bill Huffman, Nicholas Knight, Constantine Korikov, Ben Korpan, Hanna Kruppe, Yunsup Lee, Guy Lemieux, Grigorios Magklis, Filip Moc, Rich Newell, Albert Ou, David Patterson, Colin Schmidt, Alex Solomatnikov, Steve Wallach, Andrew Waterman, Jim Wilson.

現在のバージョンで分かっている問題点:

- エンコーディングフォーマットをより改善する必要がある。
- ベクトルメモリに関するコンシステンシモデルを明らかにする必要がある。
- 特権アーキテクチャとの相互関係について説明する必要がある。

## v0.9からの変更点

### SLEN=VLENレイアウトが必須

グループはSLEN=VLENのレイアウトが必須となるように仕様を変更した。レジスタ内のバイトレイアウトは、メモリのレイアウトと一致する。SLEN<VLENレイアウトで、幅広いデータパスのマシンでマイクロアーキテクチャのテクニックによる多くの最適化が可能になり、SLEN=VLENによりソフトウェアとのインタフェースがより単純になる。

### LMUL > 1におけるELEN > VLENのサポート

仕様では、単一のベクトルレジスタよりも幅の広い要素についての仕様が含まれていなかったが、ベクトルレジスタグループを使用することによりサポートされる。しかしELENの最小値はLMUL=1の時を満たす必要がある。

### Vector FP例外の動作についての定義

### `misa.v`および`mstatus.vs`の相互作用について

### 逆数及び逆数の平方根を推論する命令の追加

### wholeレジスタ移動およびロードストア命令におけるEEWエンコーディングのサポート。マイクロアーキテクチャにおける内部データ再構成をサポートするため。

### `vrgatherei16`命令のサポート

### `vtype`ビットレイアウトを変更し`vlmul`を連続したビットフィールドに設定

### EDIVを付録に移動し、v1.0に含まれないことを明確にするためにdot命令をエンコーディングから削除

### Quad-widerning mulacc命令を付録に移動し、v1.0に含まれないことを明確にするために命令エンコーディングから削除

### `vneg`と`vfneg`の疑似命令を追加



## 1. イントロダクション

このドキュメントはRISC-Vのベースベクトル拡張 version 1.0 について説明するものである。

>本ドキュメントは、実装及び評価に用いられるベクトル仕様の安定版プロポーザルのドラフト仕様である。ドラフトのラベルが外れると、Version 1.0 はRISC-V Internationalの承認プロセスの一部であるPublic Reviewに送られる意図がある。Version 1.0はツールチェインの開発、機能シミュレータ、初期の実装に関して十分に安定していると見なされ、承認中に重大な問題が発見された場合を除き、機能に大きな変更が入ることはない。一度承認されると、仕様はVersion 2.0が与えられる。

ドラフト版の仕様は特定のベクトル機能がベクトル命令としてどのように実装することができるのかについて把握する意味を持っているが、与えられたプラットフォームプロファイルに対して、どのようなベクトル命令の集合が十分であるかについて決定されている訳ではない。

「ベースベクトル拡張」という言葉は、"V"拡張に必要な標準的なベクトルISAコンポーネントを説明するためのインフォーマルな用語として使用され、標準的なサーバやアプリケーションプロセッサのプラットフォームプロファイルとして使用されることを意図している。必須の命令とサポートされる要素の幅のセットは、以下で説明するようにベースISA(RV32I, RV64I)によって異なる。

組み込みプロファイルを含む他のプロファイルは、これらの拡張機能のサブセットのみを選択することがある。特定のプロファイルに準拠するための実装でサポートされている必須の命令の正確なセットは、各プロファイル仕様が承認された場合にのみ決定される。サブセットプロファイルの定義に便利なように、ベクトル命令サブセットには、"Zv"プレフィックスで始まるISA文字列が付加される。

>ベース”V"拡張に含まれないが将来含まれることになる命令を含めてすべてのベクトル命令のサブセットおよび拡張の名前は未決定である。

このベースベクトル命令は、暗号処理や機械学習などの様々なドメイン向けに拡張された追加ベクトル命令として動作するように設計されている。

## 2. 実装により決定される定数パラメータ

各hartはベクトル拡張をサポートすることにより以下の2つのパラメータを持つことになる。

1. 1ベクトル要素の最大ビットサイズ*ELEN*≥8。2の累乗の必要がある。

2. ベクトルレジスタのビットサイズ*VLEN ≥ ELEN*, 2の累乗の必要がある。

>  プラットフォームのプロファイルにはこれらのパラメータに関して更なる制約が入る可能性がある。例えば、ELEN ≥ max(XLEN,FLEN)や、最小VLEN値、SLEN=VLENなど。

ISAは上記の制約情報をバイナリコードで記述することができ、hartは個のバイナリコードを参照することで異なるパラメータで異なる動作できるようになる。

>コードにより実装パラメータの違いを表現できるようになる。

>ベクトル状態がアクティブなスレッドコンテキストは、VLEN, ELENパラメータのいずれかが異なるハードウェアスレッド間では、実行中に合流することはできない。

## 3. ベクトル拡張のプログラミングモデル

ベクトル拡張ではベースとなるスカラRISC-V ISAに対して32個のベクトルレジスタと、7つの非特権CSRレジスタ(`vstart`, `vxsat`, `vxrm`, `vcsr`,`vtype`, `vl`, `vlenb`)が定義されている。

<div align="center">表1. 新ベクトルCSR</div>

| Address | Privilege | Name   | Description                                   |
| :------ | :-------- | :----- | :-------------------------------------------- |
| 0x008   | URW       | vstart | ベクトルスタート位置を示すレジスタ            |
| 0x009   | URW       | vxsat  | 浮動小数点飽和フラグレジスタ                  |
| 0x00A   | URW       | vxrm   | 浮動小数点丸めモードレジスタ                  |
| 0x00F   | URW       | vcsr   | ベクトル制御およびステータスレジスタ          |
| 0xC20   | URO       | vl     | ベクトル長レジスタ                            |
| 0xC21   | URO       | vtype  | ベクトルデータ型レジスタ                      |
| 0xC22   | URO       | vlenb  | VLEN/8 (ベクトルレジスタのバイト単位での長さ) |

### 3.1 ベクトルレジスタ

ベクトル拡張ではベースのスカラRISC-V ISAに対して32個のアーキテクチャベクトルレジスタ`v0`-`v31`が加わっている。

それぞれのベクトルレジスタはVLENビットだけのビットを保持する。

> Zfinx("F in X")は新しいISAのオプションとして考えられているもので、浮動小数点命令が整数レジスタファイルをレジスタ引数として取ることができるようになるものである。0.8ベクトル拡張ではこのオプションとの互換性を持っている。

### 3.2 `mstatus`内でのベクトルコンテキストの状態

`mstatus[24:23]`に`VS`フィールドとしてベクトルのコンテキスト状態を表すためのビットが追加された。これは`sstatus[24:23]`に対してもシャドウされる。このビットは、浮動小数点のコンテキストを表現するための`FS`フィールドと同様の目的で定義されている。

`VS`ビットフィールドがOffの状態で任意のベクトル命令を実行しようとするか`vl`, `vtype`, `vlenb`, `vstart` CSRにアクセスしようとすると不定命令例外が発生する。

`VS`フィールドがInitialもしくはCleanの状態でベクトルの状態を変更する任意の命令を実行するか、`vl`, `vtype`, `vstart`レジスタへのアクセスを行うと`VS`フィールドはDirtyに変更される。

> 実装では、ベクトルの状態に変更が発生しなくても`VS`フィールドの状態は常にDirtyに設定しておくこともできる。`VS`フィールドを細かく実装するかどうかはオプションである。

実装では`misa.v`フィールドを書き込み可能にすることができる。これは浮動小数点命令における仕様と同一である。`mstatus.vs`フィールドは、`misa.v`が設定されていないとしても存在している。

> `misa.v`がクリアされていたとしても`mstatus.vs`を存在させることによって、ベクトルのエミュレーションが可能になり`misa.v`が書き込み可能なシステムにおける`mstatus.vs`の取り扱いが簡単になる。

### 3.3 ベクトル型レジスタ, `vtype`

`vtype`レジスタはXLENビット長のRead-onlyなCSRであり、ベクトルレジスタファイルに含まれるデフォルトのデータ型を示している。`vtype`は`vsetvl{i}`命令の実行でしかアップデートすることができない。ベクトル型は各ベクトルレジスタ内の要素の構成についても決定し、どのように複数のベクトルレジスタをグループ化するかについても決定する。

> 初期のドラフト版では、`vtype`レジスタは通常のCSR書き込み命令でも書き込みを行うことが可能であった。`vsetvl{i}`命令でのみアップデートが可能である仕様に変更したのは、`vtype`レジスタの管理をより簡単化するためである。

ベースベクトル拡張では、`vtype`レジスタは5つのフィールドを持っている。`vill`, `vma`, `vta`,`vsew[2:0]`, `vlmul[2:0]`である。

<div align="center">表2. `vtype`レジスタレイアウト</div>

| Bits     | Name       | Description                                      |
| -------- | :--------- | :----------------------------------------------- |
| XLEN-1   | vill       | 不正な値が設定されると1が設定される              |
| XLEN-2:7 |            | 予約(write 0)                                    |
| 7        | vma        | Vector mask agnostic                             |
| 6        | vta        | Vector tail agnostic                             |
| 5:3      | vsew[2:0]  | SEW(Selected-Element-Width)の設定に使用される    |
| 2:0      | vlmul[1:0] | ベクトルレジスタグループ(LMUL)の設定に使用される |

> ELEN=32をサポートする最小のベース実装では、`vtype`では7ビットが必要である：`ma`, `ta`の2ビット、`vsew[1:0]`の2ビットと`vlmul[2:0]`の3ビットである。`vill`の不正な値の設定は、`vsew[1:0]`を使用した64ビットのコンビネーションによりエンコードでき、これにより`vill`のためのストレージを省略できる。

> ベクトルベース拡張に対するさらなる標準・カスタム拡張に関しては、上記のフィールドを拡張してより多くのデータタイプをサポートできるようにする。

>拡張64ビット命令エンコーディングにより、これらのフィールドを命令エンコーディングで静的に指定できるようになると予想される。

#### 3.2.1. ベクトル選択エレメント幅`vsew`

`vsew`の値は動的**選択エレメント幅: selected element width(SEW)**を設定する。デフォルトでは、ベクトルレジスタはVLEN / SEW標準幅エレメントに分割されているように見ることができる。

> ベースベクトル拡張では、SEWはmax(XLEN,FLEN)までのサイズをサポートすることが必要である。他のプロフィールではELENを異なる値に設定することが可能である。

<div align="center">表3. `vsew[2:0]`(standard element width)エンコーディング</div>

| vsew[2] | vsew[1] | vsew[0] | SEW  |
| :------ | :------ | ------- | ---- |
| 0       | 0       | 0       | 8    |
| 0       | 0       | 1       | 16   |
| 0       | 1       | 0       | 32   |
| 0       | 1       | 1       | 64   |
| 1       | 0       | 0       | 128  |
| 1       | 0       | 1       | 256  |
| 1       | 1       | 0       | 512  |
| 1       | 1       | 1       | 1024 |

<div align="center">表4. VLEN=128ビットの場合の例</div>

| SEW  | ベクトルサイズあたりの要素数 |
| ---- | ---------------------------- |
| 64   | 2                            |
| 32   | 4                            |
| 16   | 8                            |
| 8    | 16                           |

サポートされるエレメント幅はLMULによって異なるが、プロファイルはLMUL=1のときにサポートされる最小のSEWをサポートしなければならない。

> いくつかの実装では、複数のベクトルレジスタを組み合わせたときにのみサポート可能な、より大きなSEWのみをサポートすることがある。ベースベクトル拡張ではLMUL=1のときのSEW=max(XLEN,FLEN)が要求されている。

> より大きなEEWに依存するソフトウェアは、コードが実行される実装の数を増やすために、最大のLMUL値を使用しようとすべきであり、従ってベクトルレジスタのグループは最小になる。`vtype`レジスタ中の`vill`ビットをチェックしてコンフィグレーションがサポートされているかどうかを確認するべきであり、そのコンフィグレーションが存在しない場合は別のコードパスを提供するべきである。あるいは、プロファイルは各LMUL設定で最小SEWを必須とすることができる。

#### 3.2.2 ベクトルレジスタグルーピング(`vlmul[2:0]`)

複数のベクトルレジスタを1つにグループ化することができ、単一のベクトル命令で複数のベクトルレジスタを取り扱うことができる。**ベクトルレジスタグループ**という名前はベクトル命令によって取り扱われる1つ以上のベクトルレジスタのことを指す。ベクトルレジスタグループは、標準幅の要素から構成される、2倍以上のより長いベクトル長を操作することができるようになる。ベクトルレジスタグループは、よりベクトル長の長いアプリケーションにおいて効率的に命令を実行できるようになる。

グループ内のベクトルレジスタの数は**LMUL**により管理される。この値が1よりも大きいバイは、その数だけのベクトルレジスタが結合され1つのベクトルレジスタグループを構成する。LMULは整数値として1, 2, 4, 8が設定できる。

またLMULは分数も指定することができ、ベクトルレジスタ内の使用するビット数を削減することができる。LMULは分数として1/2, 1/4, 1/8が設定できる。分数のLMULは、より大きなベクトルが複数のベクトルレジスタを占有する必要のない、混合幅の値を操作するときにアーキテクチャのレジスタ数を増加させるために使用される。代わりに、より広い値が単一のベクトルレジスタを占有し、より狭い値がベクトルレジスタの一部を占める可能性がある。

実装は、分数LMULの設定として、LMUL=1のときのELENに対して`LMUL>=SEW/ELEN`をサポートしなくてはならない。サポートされないSEWおよびLMULコンフィグレーションを設定した場合には、`vtype`レジスタの`vill`が設定される。

> LMUL ≥ SEW/ELEN を必要とすることで、混在幅要素で動作するソフトウェアでは、単一のベクトルレジスタを使用して最も広い (ELEN) 要素のみを保持し、分数のLMUL を使用して狭い要素を保持することができる。LMUL < SEW/ELEN の場合、VLEN=ELEN が有効な実装の選択であるため、分数ベクタレジスタに少なくとも 1 つの要素を格納するのに十分なビットがあるという保証はない。

`LMUL < SEW/ELEN`の実装および`vill`ビットが設定されない場合の動作については予約されている。

> このようなすべての実装で`vill`ビットを設定すると、将来的には個のエンコーディングを拡張機能として使用できなくなるため、`LMUL<SEW/ELEN`の動作を定義するようにするため、ここでは`vill`が予約されない場合の考慮をしている。

> アセンブラは`vsetvli`命令がLMUL < SEW/ELENの設定を行おうとする場合に警告(エラーではない)を出力することが推奨されている。

LMULは`vtype`フィールドの符号付き`vlmul`である(LMUL= $$2^{\text{vlmul[2:0]}}$$)

VLMAX=LMUL*VLEN/SEWは、下記の表に示す通り、現在のSEWおよびLMULの設定が与えられた場合に、単一のベクトル命令で操作可能な要素の最大数を示している。

| vlmul[2] | vlmul[1] | vlmul[0] | LMUL | #groups | VLMAX      | Grouped registers                 |
| -------- | :------- | :------- | :--- | :------ | :--------- | --------------------------------- |
| 1        | 0        | 0        | -    | -       | -          | 予約                              |
| 1        | 0        | 1        | 1/8  | 32      | VLEN/SEW/8 | `v` n (グループ内にレジスタは1つ) |
| 1        | 1        | 0        | 1/4  | 32      | VLEN/SEW/4 | `v` n (グループ内にレジスタは1つ) |
| 1        | 1        | 1        | 1/2  | 32      | VLEN/SEW/2 | `v` n (グループ内にレジスタは1つ) |
| 0        | 0        | 0        | 1    | 32      | VLEN/SEW   | `v` n (グループ内にレジスタは1つ) |
| 0        | 0        | 1        | 2    | 16      | 2*VLEN/SEW | `v` n, `v` n+1                    |
| 0        | 1        | 0        | 4    | 8       | 4*VLEN/SEW | `v` n, …, `v` n+3                 |
| 0        | 1        | 1        | 8    | 4       | 8*VLEN/SEW | `v` n, …, `v` n+7                 |

LMUL=2の場合、ベクトルレジスタ`v`nはベクトルレジスタ`v`n+1も含み、2倍のビット長を操作することになる。ベクトルオペランドにより指定されるオペランドで、奇数番号のベクトルレジスタを指定した場合は不定命令例外が発生する。

LMUL=4である場合、ベクトル命令は4つのベクトルレジスタを同時に操作する。また、ベクトル命令により指定されるベクトルオペランドが4の倍数でなかった場合は不定命令例外が発生する。

LMUL=8である場合は、8つのベクトルレジスタを同時に操作し、ベクトルオペランドとして使用されるベクトルレジスタが8の倍数でない場合は不定命令例外が発生する。

レジスタマスク命令は、LMULの設定に関係なく常に単一ベクトルレジスタに対して機能する。

#### 3.2.3. ベクトルタイプ不正 `vill`

`vill`では直前に実行された`vsetvl{i}`命令によりサポートされない値が`vtype`に書き込まれたことをエンコードするために使用される。

> `vill`ビットはCSRのXLEN-1ビットにより設定される。これにより、不正な値が設定されたかどうかを符号判定の分岐命令により判定できる。

もし、`vill`ビットが設定されている場合、どのようなベクトル命令(ベクトルコンフィグレーション命令以外)を実行しても不定命令例外が発生する。

`vill`が設定されていると、`vtype`の他の`XLEN-1`ビットは0に設定される。

### 3.3. ベクトル長レジスタ`vl`

XLENビット長の読み込み専用CSRである`vl`は`vsetvli`および`vsetvl`命令でのみアップデートすることができるレジスタで、**fault-only-first**ベクトルロード命令バリアントである。

`vl`レジスタは、ベクトル命令によりアップデートされる要素の数を符号なし整数として保持している。任意の書き込み先ベクトルレジスタグループにおいて、インデックスが`vl`以上の場合は、ベクトル命令が実行されても何も変化しない。`vstart`≥`vl`の場合、書き込み先ベクトルレジスタグループにおいてどのような要素もアップデートされない。

> 結論として、`vl`=0の場合は`vstart`の値にかかわらず書き込み先ベクトルレジスタグループには何も書きこまれない。

> スカラ整数レジスタもしくはスカラ浮動小数点レジスタの場合は`vstart`≦`vl`でも実行される。

> `vl`に実装されるビットの長さは、その実装が最小のデータタイプにおいて実行することができる最大の要素数に依存する。最小のベクトル実装であるRV32IVでは、少なくとも`vl`では0-32までの値を保持する(VLEN=32, LMUL=8, SEW=8でVLMAXが32となる)を保持するために6ビットが必要となる。

### 3.4 ベクトルバイト長レジスタ`vlenb`

`XLEN`ビット長の読み込み専用CSRレジスタ`vlenb`はVLEN/8の値、つまりバイト単位でのベクトル長を保持する。

> `vlenb`の値は任意の実装において、設計時に決められる定数である。

> このCSRを使わない場合、いくつかの命令を実行してVLENのバイト単位での値を計算する必要がある。退避の必要な現在の`vl`および`vtype`の値を取得して計算を行う必要がある。

### 3.5. ベクトルスタートインデックスCSR`vstart`

`vsatrt`は読み込み専用のCSRで、ベクトル命令により実行される最初の要素のインデックスを示している。

通常、`vstart`はベクトル命令の例外時にハードウェアにより書き込まれる。`vsatrt`の値はどの要素により例外がが発生したか(同期例外及び非同期例外で同様である)を示しており、復帰可能な例外である場合は、どの場所から復帰するかを示している。

すべてのベクトル命令は`vstart`CSRで示されるエレメントの場所から実行され、例外が発生した要素よりも前の要素の結果が邪魔されることがないように設計されている。命令の実行が完了すると、`vstart`CSRは0にリセットされる。

> `vsetvl{i}`命令を含むすべてのベクトル命令は`vstart`CSRをゼロに設定する。

不定命令例外を発生させたベクトル命令では、`vstart`の値は変更されない。

`vstart`レジスタの値が`vl`以上場合は、どの要素にも実行されず、書き込みベクトルレジスタの`vl`がゼロに設定されることはない。

`vstart`CSRは最大の要素インデックス(VLMAXよりも1つ小さな値)もしくはlg2(VLEN)まで書き込むことができるようなビットサイズが定義される。`vstart`CSRの上位のビットはハード的にゼロが設定される(ゼロ読み出し、書き込みは無視される)。

> ベクトル長の最大値はLMULの最大設定値(8)およびSEWの最小値(8)により計算され、VLMAX_max=8*VLEN/8=VLENとなる。例えば、VLEN=256であれば、`vstart`は8ビットであり、0から255までを表現することができる。

`vstart`CSRは非特権コードにより書き込みを行うことができるが、いくつかの実装では`vstart`にゼロ以外の値を書き込むと大幅に速度が低下する可能性がある。したがって、`vstart`はアプリケーションプログラマが使用すべきではない。いくつかのベクトル命令では`vstart`が非ゼロの場合には実行することができず、以下に定義された不定命令例外が発生する。

> 特権用以外のコードでも`vstart`が見えることによって、ユーザレベルのスレッドライブラリをサポートすることができる。

実装では、`vstart`の値に何らかの値が設定されている状態では例外を発生することを許しており、そのような実装では同じ`vtype`設定においてベクトル命令は結果を生成しない。

> たとえば、いくつかの実装ではベクトル算術演算を実行中には決して例外を発生せず、命令の実行が完了するまで例外の発生を待つことができる。このような実装ではベクトル算術演算命令において`vstart`が非ゼロである場合は例外が発生することを許している。

### 3.6. ベクトル固定小数点丸めモードレジスタ`vxrm`

ベクトル固定小数点丸めモードレジスタは2ビットのRead-Write丸めモードビットフィールドを持っている。ベクトル固定小数点丸めは`fcsr`レジスタの上位ビットのビットフィールドを反映しているが、異なるCSRビットアドレスが割り当てられている。浮動小数点を持たないシステムの場合は、ベクトル拡張を追加する場合には`fcsr`レジスタを追加する必要がある。

固定小数点の丸めアルゴリズムは以下のように指定される。丸め前の値が`v`であり、`d`ビット長であるとする。この場合丸め後の値は`(v >> d) + r`であり、`r`は以下に示す丸めモードの表によって決定される。

| Bits [1] | Bits[0] | 略称 | 丸めモード                                 | 丸めインクリメント`r`   |
| :------- | :------ | :--- | ------------------------------------------ | ----------------------- |
| 0        | 0       | rnu  | round-to-nearest-up (add +0.5 LSB)         | `v[d-1]`                |
| 0        | 1       | rne  | round-to-nearest-even                      | `v[d-1] & (v[d-2:0]!=0` |
| 1        | 0       | rdn  | round-down (truncate)                      | `0`                     |
| 1        | 1       | rod  | round-to-odd (OR bits into LSB, aka "jam") | `!v[d] & v[d-1:0] != 0` |

以下の丸め関数は、命令の説明時に丸めの操作を説明表現するために使用する。

```
roundoff_unsigned(v, d) = (unsigned(v) >> d) + r
roundoff_signed(v, d) = (signed(v) >> d) + r
```

Bits[XLEN-1:2]はゼロである。

> 丸めモードは`csrwi`命令により1命令で設定できる。

### 3.7. ベクトル固定小数点飽和フラグ`vxsat`

`vxsat`CSRは1ビットの読み書き可能なビットを保持しており、固定小数点命令の計算結果が書き込み先レジスタのフォーマットに合わせるために飽和した場合に設定される。

`vxsat`ビットは`fcsr`レジスタの上位ビットにミラーリングされる。

### 3.7. `fcsr`のベクトル固定小数点フィールド

`vxrm`および`vxsat`は分離されたCSRであり浮動小数点CSR`fcsr`からアクセスすることができる。`fcsr`レジスタは浮動小数点をサポートしていない実装でも、ベクトル拡張をサポートしている場合には追加する必要がある。

| Bits | Name   | Description              |
| ---- | :----- | :----------------------- |
| 10:9 | vxrm   | 固定小数点丸めモード     |
| 8    | vxsat  | 固定小数点精度飽和フラグ |
| 7:5  | frm    | 浮動小数点丸めモード     |
| 4:0  | fflags | 浮動小数点例外フラグ     |

> これらのフィールドは`fcsr`にパッキングされるのは、コンテキストの保存と回復を高速化させるためである。

### 3.8. ベクトル拡張のリセット状態について

ベクトル拡張はリセット時に矛盾の発生していない状態でなければならない。特に、`vtype`および`vl`は`vsetvl`命令により読み込みおよびリストアできなければならない。

> リセット時には`vtype.vill`は1が設定されており、残りの`vtype`レジスタはゼロが設定されており、`vl`は0が設定されている状態が推奨される。

`vstart`, `vxrm` ,`vxsat`CSRはリセット時にはどのような値が設定されていても構わない。

> ベクトルユニットを使用するときはいかなる時も最初に`vsetvl{i}`を実行し、`vstart`をリセットさせる必要がある。`vxrm`および`vxsat`フィールドはソフトウェアにより使用前に明示的にリセットを行うべきである。

ベクトルレジスタはリセット時にはどのような値が設定されていても構わない。
