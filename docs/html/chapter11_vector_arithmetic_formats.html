

<!DOCTYPE html>
<html class="writer-html5" lang="ja" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>11. ベクトル算術演算命令フォーマット &mdash; riscv-v-spec-japanese  ドキュメント</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script src="_static/translations.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" />
    <link rel="next" title="12. ベクトル整数算術演算命令" href="chapter12_vector_arithmetic_insts.html" />
    <link rel="prev" title="8. ベクトルAMO操作(Zvamo)" href="chapter8_vector_amo.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> riscv-v-spec-japanese
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="chapter1_3_riscv_vector_insts.html">v0.9からの変更点</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter1_3_riscv_vector_insts.html#id2">1. イントロダクション</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter1_3_riscv_vector_insts.html#id3">2. 実装により決定される定数パラメータ</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter1_3_riscv_vector_insts.html#id4">3. ベクトル拡張のプログラミングモデル</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter4_mapping_vector_elements.html">4. ベクトル要素のベクトルレジスタへの割り付け</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter5_vector_instruction_format.html">5. ベクトル命令フォーマット</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter6_config_insts.html">6. コンフィグレーション設定命令</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter7_vector_load_store.html">7. ベクトルロードストア命令</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter8_vector_amo.html">8. ベクトルAMO操作(<code class="docutils literal notranslate"><span class="pre">Zvamo</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter8_vector_amo.html#id1">9. ベクトルメモリのアライメント制約</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter8_vector_amo.html#id2">10. ベクトルメモリのコンシステンシモデル</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">11. ベクトル算術演算命令フォーマット</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">11.1. ベクトル算術演算命令のエンコーディング</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">11.2. ビット幅が広がるベクトル算術演算命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">11.3. ビット幅を縮小するベクトル算術演算命令</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="chapter12_vector_arithmetic_insts.html">12. ベクトル整数算術演算命令</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter13_fixedpoint.html">13. ベクトル固定小数点演算命令</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter14_floatingpoint.html">14. ベクトル浮動小数点命令</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter15_reduction.html">15. ベクトルリダクション操作</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter16_vector_mask.html">16. ベクトルマスク命令</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter17_vector_permutation.html">17. ベクトル並べ替え命令</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter18_exception.html">18. 例外処理</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter19_zvediv.html">19. 要素分割拡張命令 (‘Zvediv’)</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter20_listing.html">20. ベクトル命令一覧</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendixA_examples.html">付録A: ベクトルアセンブリコード例</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">riscv-v-spec-japanese</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>11. ベクトル算術演算命令フォーマット</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/chapter11_vector_arithmetic_formats.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>11. ベクトル算術演算命令フォーマット<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>ベクトル算術演算命令は新しいメジャーオペコード(OP-V =
b1010111)を使用している。このオペコードはOP-FPと隣接しており、3ビットの<code class="docutils literal notranslate"><span class="pre">funct3</span></code>フィールドを使用してベクトル命令のサブカテゴリを定義している。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">OP</span><span class="o">-</span><span class="n">Vメジャーオペコード下におけるベクトル算術命令のフォーマット</span>

<span class="mi">31</span>       <span class="mi">26</span>  <span class="mi">25</span>   <span class="mi">24</span>      <span class="mi">20</span> <span class="mi">19</span>      <span class="mi">15</span> <span class="mi">14</span>   <span class="mi">12</span> <span class="mi">11</span>      <span class="mi">7</span> <span class="mi">6</span>     <span class="mi">0</span>
  <span class="n">funct6</span>   <span class="o">|</span> <span class="n">vm</span>  <span class="o">|</span>   <span class="n">vs2</span>    <span class="o">|</span>    <span class="n">vs1</span>   <span class="o">|</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="o">|</span>    <span class="n">vd</span>   <span class="o">|</span><span class="mi">1010111</span><span class="o">|</span> <span class="n">OP</span><span class="o">-</span><span class="n">V</span> <span class="p">(</span><span class="n">OPIVV</span><span class="p">)</span>
  <span class="n">funct6</span>   <span class="o">|</span> <span class="n">vm</span>  <span class="o">|</span>   <span class="n">vs2</span>    <span class="o">|</span>    <span class="n">vs1</span>   <span class="o">|</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="o">|</span>  <span class="n">vd</span><span class="o">/</span><span class="n">rd</span>  <span class="o">|</span><span class="mi">1010111</span><span class="o">|</span> <span class="n">OP</span><span class="o">-</span><span class="n">V</span> <span class="p">(</span><span class="n">OPFVV</span><span class="p">)</span>
  <span class="n">funct6</span>   <span class="o">|</span> <span class="n">vm</span>  <span class="o">|</span>   <span class="n">vs2</span>    <span class="o">|</span>    <span class="n">vs1</span>   <span class="o">|</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="o">|</span>  <span class="n">vd</span><span class="o">/</span><span class="n">rd</span>  <span class="o">|</span><span class="mi">1010111</span><span class="o">|</span> <span class="n">OP</span><span class="o">-</span><span class="n">V</span> <span class="p">(</span><span class="n">OPMVV</span><span class="p">)</span>
  <span class="n">funct6</span>   <span class="o">|</span> <span class="n">vm</span>  <span class="o">|</span>   <span class="n">vs2</span>    <span class="o">|</span>   <span class="n">simm5</span>  <span class="o">|</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> <span class="o">|</span>    <span class="n">vd</span>   <span class="o">|</span><span class="mi">1010111</span><span class="o">|</span> <span class="n">OP</span><span class="o">-</span><span class="n">V</span> <span class="p">(</span><span class="n">OPIVI</span><span class="p">)</span>
  <span class="n">funct6</span>   <span class="o">|</span> <span class="n">vm</span>  <span class="o">|</span>   <span class="n">vs2</span>    <span class="o">|</span>    <span class="n">rs1</span>   <span class="o">|</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="o">|</span>    <span class="n">vd</span>   <span class="o">|</span><span class="mi">1010111</span><span class="o">|</span> <span class="n">OP</span><span class="o">-</span><span class="n">V</span> <span class="p">(</span><span class="n">OPIVX</span><span class="p">)</span>
  <span class="n">funct6</span>   <span class="o">|</span> <span class="n">vm</span>  <span class="o">|</span>   <span class="n">vs2</span>    <span class="o">|</span>    <span class="n">rs1</span>   <span class="o">|</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="o">|</span>    <span class="n">vd</span>   <span class="o">|</span><span class="mi">1010111</span><span class="o">|</span> <span class="n">OP</span><span class="o">-</span><span class="n">V</span> <span class="p">(</span><span class="n">OPFVF</span><span class="p">)</span>
  <span class="n">funct6</span>   <span class="o">|</span> <span class="n">vm</span>  <span class="o">|</span>   <span class="n">vs2</span>    <span class="o">|</span>    <span class="n">rs1</span>   <span class="o">|</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span> <span class="o">|</span>  <span class="n">vd</span><span class="o">/</span><span class="n">rd</span>  <span class="o">|</span><span class="mi">1010111</span><span class="o">|</span> <span class="n">OP</span><span class="o">-</span><span class="n">V</span> <span class="p">(</span><span class="n">OPMVX</span><span class="p">)</span>
     <span class="mi">6</span>        <span class="mi">1</span>        <span class="mi">5</span>          <span class="mi">5</span>        <span class="mi">3</span>        <span class="mi">5</span>        <span class="mi">7</span>
</pre></div>
</div>
<div class="section" id="id2">
<h2>11.1. ベクトル算術演算命令のエンコーディング<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">funct3</span></code>フィールドがオペランドの型とソースオペランドの場所をエンコードしている。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 17%" />
<col style="width: 2%" />
<col style="width: 2%" />
<col style="width: 8%" />
<col style="width: 29%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>funct3[2:0]</p></th>
<th class="head"></th>
<th class="head"></th>
<th class="head"></th>
<th class="head"><p>Operands</p></th>
<th class="head"><p>スカラオペランドのソース</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>OPIVV</p></td>
<td><p>ベクトル - ベクトル</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>OPFVV</p></td>
<td><p>ベクトル - ベクトル</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>OPMVV</p></td>
<td><p>ベクトル - ベクトル</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>OPIVI</p></td>
<td><p>ベクトル - 即値</p></td>
<td><p>imm[4:0]</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>OPIVX</p></td>
<td><p>ベクトル - スカラ</p></td>
<td><p>GPR x register rs1</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>OPFVF</p></td>
<td><p>ベクトル - スカラ</p></td>
<td><p>FP f register rs1</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>OPMVX</p></td>
<td><p>ベクトル - スカラ</p></td>
<td><p>GPR x register rs1</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>OPCFG</p></td>
<td><p>スカラ - 即値</p></td>
<td><p>GPR x register rs1 &amp; rs2/imm</p></td>
</tr>
</tbody>
</table>
<p>整数算術演算は符号なし整数化、2の歩数表現での符号付整数を使用して実行される。どちらを使用するかはオペコードに依存する。</p>
<p>すべての標準的な浮動小数点算術演算はIEEE-754/2008標準に準拠する。すべてのベクトル浮動小数点演算は<code class="docutils literal notranslate"><span class="pre">frm</span></code>レジスタに基づいて動的な丸めモードを使用する。</p>
<p>ベクトル -
ベクトル算術演算はベクトルグループから<code class="docutils literal notranslate"><span class="pre">vs2</span></code>と<code class="docutils literal notranslate"><span class="pre">vs1</span></code>で指定される2つのベクトルグループを取り、算術演算を実行する。</p>
<p>ベクトル -
スカラ演算は3つの形式をとることができるが、すべてのケースにおいて<code class="docutils literal notranslate"><span class="pre">vs2</span></code>ベクトルレジスタグループにより1つのベクトルオペランドを取り、2番目のスカラソースオペランドは以下の3つのうちどれかの景色を選択する。</p>
<ol class="arabic simple">
<li><p>整数演算では、スカラ値は<code class="docutils literal notranslate"><span class="pre">rs1</span></code>フィールドからエンコードされる5ビットの即値を使用する。値は符号拡張されるか、符号なし拡張される。</p></li>
<li><p>整数演算では、スカラ値は<code class="docutils literal notranslate"><span class="pre">rs1</span></code>から指定される整数レジスタ<code class="docutils literal notranslate"><span class="pre">x</span></code>から取得される。もし<code class="docutils literal notranslate"><span class="pre">XLEN&gt;SEW</span></code>であれば、<code class="docutils literal notranslate"><span class="pre">x</span></code>レジスタのうち下位のSEWビットが使用される。XLEN&lt;SEWであれば、<code class="docutils literal notranslate"><span class="pre">x</span></code>レジスタの値はSEWビットまで符号拡張される。</p></li>
<li><p>浮動小数点演算では、スカラ値は浮動小数点スカラレジスタ<code class="docutils literal notranslate"><span class="pre">f</span></code>から取得される。FLEN&gt;SEWであれば、<code class="docutils literal notranslate"><span class="pre">f</span></code>レジスタはNaN-boxされた値かどうかをチェックし、<code class="docutils literal notranslate"><span class="pre">f</span></code>レジスタの下位のSEWビットが使用される。NaN-boxされた値でなければNaNが使用される。FLEN&lt;SEWであれば、値はNaN-boxされSEWビット長まで拡張される。</p></li>
</ol>
<blockquote>
<div><p>現在提案されているZfinxバリアントは浮動小数点スカラの引数を<code class="docutils literal notranslate"><span class="pre">x</span></code>レジスタから取ることができる。</p>
</div></blockquote>
<p>ベクトル算術演算命令は、vmフィールドの制御に基づいてマスクを適用することができる。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># ベクトルバイナリ算術演算命令のアセンブリ文法パタン</span>

<span class="c1"># Operations returning vector results, masked by vm (v0.t, &lt;nothing&gt;)</span>
<span class="c1"># ベクトル書き込みレジスタの指定により、算術演算結果はvmによりマスクされる(v0.tもしくは指定しない)</span>
<span class="n">vop</span><span class="o">.</span><span class="n">vv</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># 整数ベクトル - ベクトル演算 vd[i] = vs2[i] op vs1[i]</span>
<span class="n">vop</span><span class="o">.</span><span class="n">vx</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># 整数ベクトル - スカラ演算   vd[i] = vs2[i] op x[rs1]</span>
<span class="n">vop</span><span class="o">.</span><span class="n">vi</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">imm</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># 整数ベクトル - 即値演算     vd[i] = vs2[i] op imm</span>

<span class="n">vfop</span><span class="o">.</span><span class="n">vv</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span> <span class="c1"># 浮動小数点ベクトル - ベクトル演算 vd[i] = vs2[i] fop vs1[i]</span>
<span class="n">vfop</span><span class="o">.</span><span class="n">vf</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span> <span class="c1"># 浮動小数点ベクトル - スカラ演算   vd[i] = vs2[i] fop f[rs1]</span>
</pre></div>
</div>
<p>エンコーディング中では、<code class="docutils literal notranslate"><span class="pre">vs2</span></code>は1番目のオペランドであり、<code class="docutils literal notranslate"><span class="pre">rs1/simm5</span></code>が2番目のオペランドとなっている。これは標準的なスカラ命令の順番とは逆である。この順番になっているのは現在のエンコーディングにおける1つのスカラレジスタを読み込む命令、<code class="docutils literal notranslate"><span class="pre">rs1</span></code>からレジスタを読み込む場合および5ビットの即値を取得するものと保持しているxxx。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Assembly syntax pattern for vector ternary arithmetic instructions (multiply-add)</span>
<span class="c1"># 3つの読み込みオペランドを取るベクトル命令のアセンブリ文法パタン(乗算加算)</span>

<span class="c1"># 加算のオペランドを上書きする形式の整数演算命令</span>
<span class="n">vop</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vd[i] = vs1[i] * vs2[i] + vd[i]</span>
<span class="n">vop</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vd[i] = x[rs1] * vs2[i] + vd[i]</span>

<span class="c1"># 乗算のオペランドを上書きする形式の整数演算命令</span>
<span class="n">vop</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vd[i] = vs1[i] * vd[i] + vs2[i]</span>
<span class="n">vop</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vd[i] = x[rs1] * vd[i] + vs2[i]</span>

<span class="c1"># 加算のオペランドを上書きする形式の浮動小数点命令</span>
<span class="n">vfop</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vd[i] = vs1[i] * vs2[i] + vd[i]</span>
<span class="n">vfop</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vd[i] = f[rs1] * vs2[i] + vd[i]</span>

<span class="c1"># 乗算のオペランドを上書きする形式の浮動小数点命令</span>
<span class="n">vfop</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vd[i] = vs1[i] * vd[i] + vs2[i]</span>
<span class="n">vfop</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vd[i] = f[rs1] * vd[i] + vs2[i]</span>
</pre></div>
</div>
<p>3オペランドを取る乗算加算命令では、アセンブリ命令の構文は、常に書き込みレジスタを先頭に配置し、<code class="docutils literal notranslate"><span class="pre">rs1</span></code>もしくは<code class="docutils literal notranslate"><span class="pre">vs1</span></code>を置き、最後に<code class="docutils literal notranslate"><span class="pre">vs2</span></code>を置く。この順序により乗算のオペランドが常に2番目に来るため、アセンブリ命令の算術演算の動作を自然に読むことができる。</p>
</div>
<div class="section" id="id3">
<h2>11.2. ビット幅が広がるベクトル算術演算命令<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>いくつかのベクトル算術演算命令では<strong>ビット幅が拡張される</strong>演算命令として定義されており、書き込み先の要素は
2*SEW
ビットまで拡張され、書き込み先のベクトルレジスタグループは2つ分使用される。</p>
<p>1番目のオペランドでは、1倍幅もしくは2倍幅である。通常これらの命令はプレフィックスとして<code class="docutils literal notranslate"><span class="pre">vw*</span></code>がつけられ、ベクトル浮動小数点命令の場合は<code class="docutils literal notranslate"><span class="pre">vfw*</span></code>プレフィックスが付けられる。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ビット幅が拡張されるベクトル算術演算命令のアセンブリ文法パタン</span>

<span class="c1"># 演算結果は2倍幅、1つの1倍幅のソースオペランドを取る: 2*SEW = SEW op SEW</span>
<span class="n">vwop</span><span class="o">.</span><span class="n">vv</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># 整数ベクトル - ベクトル    vd[i] = vs2[i] op vs1[i]</span>
<span class="n">vwop</span><span class="o">.</span><span class="n">vx</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># 整数ベクトル - スカラ      vd[i] = vs2[i] op x[rs1]</span>

<span class="c1"># 最初のオペランドは2倍幅、2番目のオペランドは1倍幅で、演算結果は2倍幅: 2*SEW = 2*SEW op SEW</span>
<span class="n">vwop</span><span class="o">.</span><span class="n">wv</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># 整数ベクトル - ベクトル     vd[i] = vs2[i] op vs1[i]</span>
<span class="n">vwop</span><span class="o">.</span><span class="n">wx</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># 整数ベクトル - スカラ      vd[i] = vs2[i] op x[rs1]</span>
</pre></div>
</div>
<blockquote>
<div><p>最初は、<code class="docutils literal notranslate"><span class="pre">w</span></code>サフィックスをオペコードに使用していたが、ダブルワードの整数命令におけるワードサイズの命令を示すサフィックスである<code class="docutils literal notranslate"><span class="pre">w</span></code>と混同するため、<code class="docutils literal notranslate"><span class="pre">w</span></code>をプレフィックスに移動した。</p>
<p>浮動小数手のビット幅拡張命令は<code class="docutils literal notranslate"><span class="pre">vwf*</span></code>から<code class="docutils literal notranslate"><span class="pre">vfw*</span></code>に変更した。これはスカラの浮動小数点ビット幅拡張命令である<code class="docutils literal notranslate"><span class="pre">fw*</span></code>との一貫性を保つためである。</p>
</div></blockquote>
<blockquote>
<div><p>整数の乗算加算命令では、乗算加算命令のサイズを4SEWに増やすという選択肢があり得る(例えば
4SEW +=
SEWSEW)。これは<code class="docutils literal notranslate"><span class="pre">vw4</span></code>プレフィックスをオペコードに付与することで区別する。今回はこの命令は含まれていないが、仕様に追加される可能性がある。</p>
</div></blockquote>
<p>書き込み先のベクトルレジスタグループはSEWとLMULが現在の設定よりも2倍になったかのように配置される(例えば、書き込み先の要素のサイズが2SEWであり、書き込み先のベクトルレジスタグループのLMULは2LMULとなっているように見える)。</p>
<p>すべてのビット幅を拡張する命令のために、書き込み先の要素の幅はサポートされているビット幅の範囲であり、LMULの値もサポートされているLMULの範囲に収まっている必要がある(例えば、現在のLMULが&lt;=4であれば、&lt;=8となる)。</p>
<p>書き込み先のベクトルレジスタグループはベクトルレジスタ番号で指定し、書き込み先のLMULの値において有効な値である必要がある。そうでなければ、不正命令例外が発生する。</p>
<p>書き込み先のベクトルレジスタグループは別の要素幅を持つソースベクトルレジスタグループとオーバラップしてはならない(マスクレジスタを使用していても、マスクを含めて被ってはならない)。そうでなければ、不正命令例外が発生する。</p>
<blockquote>
<div><p>非ゼロの<code class="docutils literal notranslate"><span class="pre">vstart</span></code>をサポートする必要がある。</p>
</div></blockquote>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">vw&lt;op&gt;.wv</span> <span class="pre">vd,</span> <span class="pre">vs2,</span> <span class="pre">vs1</span></code>フォーマットの命令では、<code class="docutils literal notranslate"><span class="pre">vd</span></code>と<code class="docutils literal notranslate"><span class="pre">vs2</span></code>が同一であっても問題ない。</p>
</div></blockquote>
</div>
<div class="section" id="id4">
<h2>11.3. ビット幅を縮小するベクトル算術演算命令<a class="headerlink" href="#id4" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>いくつかの命令では、2倍幅のソースベクトルオペランドを1倍幅の書き込みベクトルレジスタに書き込む命令が存在する。この命令では、ソースベクトルレジスタのサイズは現在のLMULおよびSEWの設定よりも2倍になっているように設定されており、通常のLMUL/SEWサイズのベクトルレジスタグループに縮小するための命令である。</p>
<p>(2<em>LMUL &gt; 8)もしくは(2</em> SEW) &gt; ELENであれば、不正命令例外が発生する。</p>
<blockquote>
<div><p>別の設計方針としては、LMULの設定をソースベクトルレジスタグループのサイズとして取り扱うというものである。この選択肢は、LMULの変更量を少なくできるという利点を持つと考えられている。</p>
</div></blockquote>
<p>ソースベクトルレジスタグループと書き込みベクトルレジスタグループは、LMULの設定における有効なベクトルアドレスを指定しなければならない。そうでなければ、不正命令例外が発生する。</p>
<p>2番目路ベクトルレジスタ(<code class="docutils literal notranslate"><span class="pre">vs1</span></code>で指定される)は、書き込みベクトルレジスタと同一のサイズ(縮小されたサイズ)でなければならない。</p>
<p>書き込み先ベクトルレジスタグループは、1番目のベクトルレジスタグループ(<code class="docutils literal notranslate"><span class="pre">vs2</span></code>で指定される)とオーバラップしてはならない。書き込み先ベクトルレジスタグループは、マスクを使用する場合はLMUL=1でない限りマスクレジスタとオーバラップしてはならない。もしこの制約を違反する場合、不正命令例外が発生する。</p>
<blockquote>
<div><p>LMULと幅が同一で、要素のサイズが書き込みベクトルレジスタと同一のLMUL=1のときにマスクレジスタを上書きするために2番目のソースベクトルレジスタグループを上書きするのは安全であるxxx。</p>
</div></blockquote>
<p>アセンブラ中で命令を区別するために、<code class="docutils literal notranslate"><span class="pre">vn*</span></code>プレフィックスをオペコードに使用するか、浮動小数点命令の場合は<code class="docutils literal notranslate"><span class="pre">vfn*</span></code>プレフィックスを使用する。倍幅のソースベクトルレジスタグループは<code class="docutils literal notranslate"><span class="pre">w</span></code>をソースオペランドサフィックスに指定することで指定する(例:
<code class="docutils literal notranslate"><span class="pre">vnsra.wv</span></code>)</p>
<blockquote>
<div><p>マスクレジスタを設定する比較演算命令も、暗黙的にビット幅を縮小する演算である。</p>
</div></blockquote>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="chapter12_vector_arithmetic_insts.html" class="btn btn-neutral float-right" title="12. ベクトル整数算術演算命令" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="chapter8_vector_amo.html" class="btn btn-neutral float-left" title="8. ベクトルAMO操作(Zvamo)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; 著作権 2019, msyksphinz

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>