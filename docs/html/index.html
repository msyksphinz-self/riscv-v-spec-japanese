

<!DOCTYPE html>
<html class="writer-html5" lang="ja" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>RISC-V &#34;V&#34; ベクトル拡張 &mdash; riscv-v-spec-japanese  ドキュメント</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script src="_static/translations.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="#" class="icon icon-home" alt="Documentation Home"> riscv-v-spec-japanese
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">RISC-V &quot;V&quot; ベクトル拡張</a><ul>
<li><a class="reference internal" href="#v1-0-rc1">v1.0-rc1からの変更点</a><ul>
<li><a class="reference internal" href="#id1">現在まで変更なし。</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id2">イントロダクション</a></li>
<li><a class="reference internal" href="#id3">実装により定義される定数パラメータ</a></li>
<li><a class="reference internal" href="#id4">ベクトル拡張のプログラミングモデル</a><ul>
<li><a class="reference internal" href="#id9">ベクトルレジスタ</a></li>
<li><a class="reference internal" href="#mstatus"><cite>mstatus</cite> 内のベクトルコンテキストステータス</a></li>
<li><a class="reference internal" href="#vtype">ベクトル型レジスタ <cite>vtype</cite></a><ul>
<li><a class="reference internal" href="#vsew-2-0">ベクトル選択要素幅 <cite>vsew[2:0]</cite></a></li>
<li><a class="reference internal" href="#vlmul-2-0">ベクトルレジスタのグループ化(<cite>vlmul[2:0]</cite>)</a></li>
<li><a class="reference internal" href="#tail-agnostic-vector-mask-agnostic-vta-vma">Tail Agnostic とVector Mask Agnostic <cite>vta</cite> と <cite>vma</cite></a></li>
<li><a class="reference internal" href="#vill">不正ベクトル型 <cite>vill</cite></a></li>
</ul>
</li>
<li><a class="reference internal" href="#vl">ベクトル長レジスタ <cite>vl</cite></a></li>
<li><a class="reference internal" href="#vlenb">ベクトルバイト長 <cite>vlenb</cite></a></li>
<li><a class="reference internal" href="#csr-vstart">ベクトルスタートインデックスCSR <cite>vstart</cite></a></li>
<li><a class="reference internal" href="#vxrm">ベクトル固定小数点丸めモードレジスタ <cite>vxrm</cite></a></li>
<li><a class="reference internal" href="#vxsat">ベクトル固定小数点飽和フラグ <cite>vxsat</cite></a></li>
<li><a class="reference internal" href="#vector-vcsr">Vector 制御・ステータスレジスタ <cite>vcsr</cite></a></li>
<li><a class="reference internal" href="#id32">リセット時のベクトル拡張の状態</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id33">ベクトルレジスタ状態へのベクトル要素のマッピング</a><ul>
<li><a class="reference internal" href="#lmul-1">LMUL = 1 時のマッピング</a></li>
<li><a class="reference internal" href="#id34">LMUL &lt; 1の場合のマッピング</a></li>
<li><a class="reference internal" href="#id35">LMUL &gt; 1 のマッピング</a></li>
<li><a class="reference internal" href="#id36">混合幅演算でのマッピングについて</a></li>
<li><a class="reference internal" href="#lmul-1-elen-vlen">LMUL &gt; 1 かつ ELEN &gt; VLEN のマッピング</a></li>
<li><a class="reference internal" href="#id47">マスクレジスタのレイアウト</a><ul>
<li><a class="reference internal" href="#id48">マスク要素の場所</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#id49">ベクトル命令フォーマット</a><ul>
<li><a class="reference internal" href="#id50">スカラオペランド</a></li>
<li><a class="reference internal" href="#id51">ベクトルオペランド</a></li>
<li><a class="reference internal" href="#id52">ベクトルマスキング</a><ul>
<li><a class="reference internal" href="#id53">マスクエンコーディング</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id58">プリスタート、アクティブ、非アクティブ、ボディ、末尾要素の定義</a></li>
</ul>
</li>
<li><a class="reference internal" href="#vsetvli-vsetivl-vsetvl">コンフィグレーション設定命令 (<cite>vsetvli</cite>/<cite>vsetivl</cite>/<cite>vsetvl</cite>)</a><ul>
<li><a class="reference internal" href="#id63"><cite>vtype</cite> エンコーディング</a></li>
<li><a class="reference internal" href="#avl">AVLのエンコーディング</a></li>
<li><a class="reference internal" href="#id68"><cite>vl</cite> 設定の制約</a></li>
<li><a class="reference internal" href="#sew">ストリップマイニングとSEW変更の例</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id69">ベクトルロード・ストア命令</a><ul>
<li><a class="reference internal" href="#id70">ベクトルロードストア命令のエンコーディング</a></li>
<li><a class="reference internal" href="#id75">ベクトルロードストアアドレッシングモード</a></li>
<li><a class="reference internal" href="#id84">ベクトルロードストア幅のエンコーディング</a></li>
<li><a class="reference internal" href="#id87">ベクトルユニットストライド命令</a></li>
<li><a class="reference internal" href="#id88">ベクトルストライド命令</a></li>
<li><a class="reference internal" href="#id89">ベクトルインデックス命令</a></li>
<li><a class="reference internal" href="#fault-only-first">ユニットストライドFault-Only-Firstロード</a></li>
<li><a class="reference internal" href="#id94">ベクトルロードストアセグメント命令</a><ul>
<li><a class="reference internal" href="#id97">ベクトルユニットストライドセグメントロードストア命令</a></li>
<li><a class="reference internal" href="#id98">ベクトルストライドセグメントロードストア命令</a></li>
<li><a class="reference internal" href="#id99">ベクトルインデックスセグメントロードストア命令</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id100">ベクトル全体レジスタロードストア命令</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id111">ベクトルメモリアラインメント制約</a></li>
<li><a class="reference internal" href="#id112">ベクトルメモリコンシステンシモデル</a></li>
<li><a class="reference internal" href="#id113">ベクトル算術演算命令</a><ul>
<li><a class="reference internal" href="#id114">ベクトル算術演算命令エンコーディング</a></li>
<li><a class="reference internal" href="#id117">幅拡張ベクトル算術演算命令</a></li>
<li><a class="reference internal" href="#id118">ベクトル幅縮小算術演算命令</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id119">ベクトル整数算術演算命令</a><ul>
<li><a class="reference internal" href="#id120">ベクトル単一幅整数加算減算命令</a></li>
<li><a class="reference internal" href="#id121">ベクトル幅拡張整数加減算命令</a></li>
<li><a class="reference internal" href="#id122">ベクトル整数拡張</a></li>
<li><a class="reference internal" href="#id123">ベクトル整数 キャリー付き加算 / ボロー付き減算命令</a></li>
<li><a class="reference internal" href="#id124">ベクトル論理命令</a></li>
<li><a class="reference internal" href="#id125">ベクトル単一幅ビットシフト命令</a></li>
<li><a class="reference internal" href="#id126">ベクトルサイズ幅縮退整数右シフト命令</a></li>
<li><a class="reference internal" href="#id127">ベクトル整数比較命令</a></li>
<li><a class="reference internal" href="#id128">ベクトル整数最大/最小命令</a></li>
<li><a class="reference internal" href="#id129">ベクトル単一幅整数乗算命令</a></li>
<li><a class="reference internal" href="#id130">ベクトル整数除算命令</a></li>
<li><a class="reference internal" href="#id131">ベクトル幅拡張乗算命令</a></li>
<li><a class="reference internal" href="#id132">ベクトル単一幅整数乗算加算命令</a></li>
<li><a class="reference internal" href="#id133">ベクトル幅拡張整数乗算加算命令</a></li>
<li><a class="reference internal" href="#id134">ベクトル整数マージ命令</a></li>
<li><a class="reference internal" href="#id135">ベクトル整数移動命令</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id136">ベクトル固定小数点算術演算命令</a><ul>
<li><a class="reference internal" href="#id137">ベクトル単一幅飽和加算と飽和減算</a></li>
<li><a class="reference internal" href="#id138">ベクトル単一幅平均加算と平均減算命令</a></li>
<li><a class="reference internal" href="#id139">丸めと飽和を用いたベクトル単一幅分数乗算</a><ul>
<li><a class="reference internal" href="#id140">ベクトル単一幅スケーリングシフト命令</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id141">ベクトル固定小数点幅縮小クリップ命令</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id142">ベクトル浮動小数点命令</a><ul>
<li><a class="reference internal" href="#id143">ベクトル浮動小数点例外フラグ</a></li>
<li><a class="reference internal" href="#id144">ベクトル単一幅浮動小数点加減算命令</a></li>
<li><a class="reference internal" href="#id145">ベクトル幅拡張浮動小数点加減算命令</a></li>
<li><a class="reference internal" href="#id146">ベクトル単一幅浮動小数点乗算除算命令</a></li>
<li><a class="reference internal" href="#id147">ベクトル幅拡張浮動小数点乗算命令</a></li>
<li><a class="reference internal" href="#id148">ベクトル単一幅浮動小数点複合乗算加算命令</a></li>
<li><a class="reference internal" href="#id149">ベクトル幅拡張浮動小数点複合乗算加算命令</a></li>
<li><a class="reference internal" href="#id150">ベクトル浮動小数点平方根命令</a></li>
<li><a class="reference internal" href="#id151">ベクトル浮動小数点逆平方根推定命令</a></li>
<li><a class="reference internal" href="#id158">ベクトル浮動小数点逆数推定命令</a></li>
<li><a class="reference internal" href="#min-max">ベクトル浮動小数点MIN/MAX命令</a></li>
<li><a class="reference internal" href="#id165">ベクトル浮動小数点符号挿入命令</a></li>
<li><a class="reference internal" href="#id166">ベクトル浮動小数点比較命令</a></li>
<li><a class="reference internal" href="#id167">ベクトル浮動小数点分類命令</a></li>
<li><a class="reference internal" href="#id168">ベクトル浮動小数点マージ命令</a></li>
<li><a class="reference internal" href="#id169">ベクトル浮動小数点移動命令</a></li>
<li><a class="reference internal" href="#id170">単一幅浮動所数点/整数型変換命令</a></li>
<li><a class="reference internal" href="#id171">幅拡張浮動小数点/整数型変換命令</a></li>
<li><a class="reference internal" href="#id172">浮動小数点/整数 幅縮小型変換命令</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id173">ベクトルリダクション操作</a><ul>
<li><a class="reference internal" href="#id176">ベクトル単一幅整数リダクション命令</a></li>
<li><a class="reference internal" href="#id177">ベクトル幅拡張整数リダクション命令</a></li>
<li><a class="reference internal" href="#id178">ベクトル単一幅浮動小数点リダクション命令</a><ul>
<li><a class="reference internal" href="#id179">ベクトル順序付き単一幅浮動小数点リダクション加算命令</a></li>
<li><a class="reference internal" href="#id180">ベクトル順序無し単一幅浮動小数点リダクション加算命令</a></li>
<li><a class="reference internal" href="#id181">ベクトル単一幅浮動小数点最大・最小リダクション</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id182">ベクトル幅拡張浮動小数点リダクション命令</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id183">ベクトルマスク命令</a><ul>
<li><a class="reference internal" href="#id184">ベクトルマスクレジスタ論理命令</a></li>
<li><a class="reference internal" href="#pop-vpopc">ベクトルマスクPopカウント <cite>vpopc</cite></a></li>
<li><a class="reference internal" href="#vfirst-find-first-set"><cite>vfirst</cite> find-first-set マスクビット命令</a></li>
<li><a class="reference internal" href="#vmsbf-m-set-before-first"><cite>vmsbf.m</cite> set-before-firstマスクビット</a></li>
<li><a class="reference internal" href="#vmsif-m-set-including-first"><cite>vmsif.m</cite> set-including-first マスクビット命令</a></li>
<li><a class="reference internal" href="#vmsof-m-set-only-first"><cite>vmsof.m</cite> set-only-first マスクビット命令</a></li>
<li><a class="reference internal" href="#id189">ベクトルマスク命令の使用例</a></li>
<li><a class="reference internal" href="#iota">ベクトルIota命令</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id196">ベクトル組み合わせ命令</a><ul>
<li><a class="reference internal" href="#id197">整数スカラ移動命令</a><ul>
<li><a class="reference internal" href="#id198">浮動小数点スカラ移動命令</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id199">ベクトルスライド命令</a><ul>
<li><a class="reference internal" href="#id200">ベクトルスライドアップ命令</a></li>
<li><a class="reference internal" href="#id201">ベクトルスライドダウン命令</a></li>
<li><a class="reference internal" href="#slide1up">ベクトル Slide1up</a></li>
<li><a class="reference internal" href="#slide1down">ベクトル Slide1down 命令</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id202">ベクトルレジスタギャザー命令</a></li>
<li><a class="reference internal" href="#id203">ベクトル圧縮命令</a><ul>
<li><a class="reference internal" href="#vdecompress"><cite>vdecompress</cite> の合成</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id204">ベクトルレジスタ全体移動命令</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id205">例外処理</a><ul>
<li><a class="reference internal" href="#id206">正確なベクトル例外</a></li>
<li><a class="reference internal" href="#id207">不正確ベクトル例外</a></li>
<li><a class="reference internal" href="#id208">正確・不正確選択可能な例外</a></li>
<li><a class="reference internal" href="#id209">スワップ可能な例外</a></li>
</ul>
</li>
<li><a class="reference internal" href="#standard-vector-extensions">Standard Vector Extensions</a><ul>
<li><a class="reference internal" href="#zve-vector-extensions-for-embedded-processors">Zve*: Vector extensions for Embedded Processors</a></li>
<li><a class="reference internal" href="#v-vector-extension-for-application-processor">V: Vector Extension for Application Processor</a></li>
</ul>
</li>
<li><a class="reference internal" href="#vector-instruction-listing">Vector Instruction Listing</a></li>
</ul>
</li>
</ul>
</div>
            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">riscv-v-spec-japanese</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="#" class="icon icon-home"></a> &raquo;</li>
        
      <li>RISC-V &quot;V&quot; ベクトル拡張</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/index.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="risc-v-v">
<h1>RISC-V &quot;V&quot; ベクトル拡張<a class="headerlink" href="#risc-v-v" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>Version 1.0-rc2-draft
:doctype: article
:encoding: utf-8
:lang: en
:toc: left
:numbered:
:stem: latexmath
:le: &amp;#8804;
:ge: &amp;#8805;
:ne: &amp;#8800;
:approx: &amp;#8776;
:inf: &amp;#8734;</p>
<p>Contributors include: Alon Amid, Krste Asanovic, Allen Baum, Alex
Bradbury, Tony Brewer, Chris Celio, Aliaksei Chapyzhenka, Silviu
Chiricescu, Ken Dockser, Bob Dreyer, Roger Espasa, Sean Halle, John
Hauser, David Horner, Bruce Hoult, Bill Huffman, Nicholas Knight,
Constantine Korikov,
Ben Korpan, Hanna Kruppe, Yunsup Lee, Guy Lemieux, Grigorios Magklis,
Filip Moc, Rich Newell, Albert Ou, David Patterson, Colin Schmidt,
Alex Solomatnikov, Steve Wallach, Andrew Waterman, Jim Wilson.</p>
<dl class="field-list simple">
<dt class="field-odd">sectnums!</dt>
<dd class="field-odd"><p></p></dd>
</dl>
<div class="section" id="v1-0-rc1">
<h2>v1.0-rc1からの変更点<a class="headerlink" href="#v1-0-rc1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id1">
<h3>現在まで変更なし。<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="field-list simple">
<dt class="field-odd">sectnums</dt>
<dd class="field-odd"><p></p></dd>
</dl>
</div>
</div>
<div class="section" id="id2">
<h2>イントロダクション<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>このドキュメントは、RISC-Vベクトル拡張のバージョン1.0の第2リリース候補のドラフトであり、
パブリックレビューのためのものです。</p>
<p><em>これはパブリックレビュー用の1.0の凍結版ではありません。</em></p>
<p>NOTE: 最終的に承認され、リリース候補のタグが外されたバージョン1.0は、RISC-Vインターナショナルの批准プロセスの一環として、
パブリックレビューのために送り出されることを意図しています。
また、バージョン1.0は、上流のソフトウェアプロジェクトを含め、ツールチェイン、機能シミュレータ、
初期実装の開発を開始するのに十分な安定性があると考えられており、
批准中に重大な問題が発見された場合を除き、
大きな機能変更はないと予想されています。批准されると、仕様書のバージョンは2.0になります。</p>
<p>本仕様書ドラフトには、現在定義されているベクトル命令の全セットが含まれています。
&lt;&lt;sec-vector-extensions&gt;&gt;  セクションには、標準的なベクトル拡張機能と、
それぞれの拡張機能でサポートされる命令および要素幅が記載されています。</p>
</div>
<div class="section" id="id3">
<h2>実装により定義される定数パラメータ<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトル拡張をサポートする各hartには、2つのパラメータが定義されています。</p>
<p>. 任意の演算で生成または消費できるベクトル要素の最大サイズ(ビット) _ELEN_ {ge} 8 で、これは2の累乗でなければなりません。
. 1つのベクトルレジスタのビット数 _VLEN_ 、これは2の累乗でなければならず、2の累乗であり、2^16^以上であってはなりません。</p>
<p>標準的なベクトル拡張(&lt;&lt;sec-vector-extensions&gt;&gt; セクション)とアーキテクチャプロファイルは、 _ELEN_ と _VLEN_ にさらなる制約を設定することができます。</p>
<p>NOTE: VLENの上限により、ソフトウェアはインデックスが16ビットに収まることを前提に組み立てることができます
(LMUL=8およびSEW=8でVLEN=65,536の場合、最大のVLMAXは65,536になります)。
将来的にクトルレジスタあたり64Kib以上に拡張する場合は、
新しいコンフィグレーション命令が必要になりますが、
従来のコンフィグレーション命令を使用しているソフトウェアでは、
ベクトルの長さが大きくなることはありません。</p>
<p>ISAは、特定の制約の下で、VLENパラメータの値が異なるhart上でバイナリコードが実行されるポータブルな記述をサポートしていますが、
両方のhartが必要な要素型をサポートしていることが条件となります。</p>
<p>NOTE: 実装パラメータの違いを露呈するようなコードを書くことも可能です。</p>
<p>NOTE: 一般的に、ベクトルのステートがアクティブであるスレッドコンテキストは、
VLENまたはELENパラメータに違いのあるhart間で実行中にコンテキストを移動するとはできません。</p>
</div>
<div class="section" id="id4">
<h2>ベクトル拡張のプログラミングモデル<a class="headerlink" href="#id4" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトル拡張はRISC-VのベーススカラISAに対して、
32本のベクトルレジスタと7つの非特権CSR(<cite>vstart</cite>, <cite>vxsat</cite>, <cite>vxrm</cite>, <cite>vcsr</cite>, <cite>vl</cite>, <cite>vlenb</cite>)が追加されます。</p>
<p>.新しいベクトルCSR
[cols=&quot;2,2,2,10&quot;]
[%autowidth]
<a href="#id5"><span class="problematic" id="id6">|</span></a>===
| アドレス | 特権 | 名前   | 説明</p>
<div class="line-block">
<div class="line">0x008 | URW | vstart | ベクトル操作開始位置</div>
<div class="line">0x009 | URW | vxsat  | 固定小数点飽和フラグ</div>
<div class="line">0x00A | URW | vxrm   | 固定小数点丸めモード</div>
<div class="line">0x00F | URW | vcsr   | ベクトル制御・ステータスレジスタ</div>
<div class="line">0xC20 | URO | vl     | ベクトル長</div>
<div class="line">0xC21 | URO | vtype  | ベクトルデータ型レジスタ</div>
<div class="line">0xC22 | URO | vlenb  | VLEN/8 (バイト単位でのベクトルレジスタ長)</div>
</div>
<p><a href="#id7"><span class="problematic" id="id8">|</span></a>===</p>
<div class="section" id="id9">
<h3>ベクトルレジスタ<a class="headerlink" href="#id9" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ベクトル拡張により、RISC-VベーススカラISAに対して
32本のアーキテクチャベクトルレジスタ <cite>v0</cite>-<cite>v31</cite> が追加されます。</p>
<p>各ベクトルレジスタのサイズは固定長でVLENビットです。</p>
<p>NOTE: Zfinx (&quot;F in X&quot;) は現在議論が行われている、浮動小数点命令を
整数レジスタファイル上で実行する新しいISAオプションです。
Vector 1.0拡張はZfinxに対して互換性があります。</p>
</div>
<div class="section" id="mstatus">
<h3><cite>mstatus</cite> 内のベクトルコンテキストステータス<a class="headerlink" href="#mstatus" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ベクトルコンテキストステータスフィールド <cite>VS</cite> は、
<cite>mstatus[10:9]</cite> に追加され、
<cite>sstatus[10:9]</cite> でシャドウイングされます。
これは、浮動小数点コンテキストステータスフィールドである <cite>FS</cite> と同様に定義されます。</p>
<p><cite>VS</cite> フィールドがOFFに設定されている場合は、
ベクトル命令を実行しようとしたり、ベクトルCSRにアクセスしようとすると、
不正命令例外が発生します。</p>
<p><cite>VS</cite> フィールドがInitialまたはCleanに設定されている場合、
ベクトルCSRを含むベクトルの状態を変更する命令を実行すると、<cite>VS</cite> がDirtyに変更されます。
また、実装では、ベクトルの状態が変化していなくても、
いつでも <cite>VS</cite> フィールドをInitialまたはCleanからDirtyに変更することができます。</p>
<p>NOTE: <cite>VS</cite> フィールドの正確な設定は最適化に繋がります。
ソフトウェアは通常、コンテキストスワップのオーバーヘッドを減らすためにVSを使用します。</p>
<p>実装では、書き込み可能な <cite>misa.v</cite> フィールドを持つことができます。
浮動小数点演算ユニットの処理方法と同様に、
<cite>misa.v</cite> がクリアされていても <cite>mstatus.vs</cite> フィールドが存在する場合があります。</p>
<p>NOTE: <cite>misa.v</cite> がクリアされているときに <cite>mstatus.vs</cite> フィールドへのアクセスを許可すると、
ベクトル操作のエミュレーションが可能になり、書き込み可能な <cite>misa.v</cite> を持つシステムでの <cite>mstatus.vs</cite> の処理が簡単になります。</p>
</div>
<div class="section" id="vtype">
<h3>ベクトル型レジスタ <cite>vtype</cite><a class="headerlink" href="#vtype" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>読み取り専用のXLEN幅を持つ _ベクトル_ _型_ CSR (<cite>vtype</cite>)は、
ベクトルレジスタファイルの内容を解釈するために使用されるデフォルトの型を提供し、
<cite>vset{i}vl{i}</cite> 命令によってのみ更新することができます。
ベクトル型は、各ベクトルレジスタの要素の構成や、複数のベクトルレジスタをどのようにグループ化するかを決定します。</p>
<p>NOTE: <cite>vset{i}vl{i}</cite> 命令による更新のみを許可することで、
<cite>vtype</cite> レジスタの状態の維持が容易になります。</p>
<p><cite>vtype</cite> レジスタには、 <cite>vill</cite> 、 <cite>vma</cite> 、 <cite>vta</cite> 、 <cite>vsew[2:0]</cite> 、 <cite>vlmul[2:0]</cite> の5つのフィールドがあります。</p>
<p>include::vtype-format.adoc[]</p>
<p>NOTE: ELEN=32 をサポートする小さな実装では、<cite>vtype</cite> には 7 ビットの状態しか必要ありません:
<cite>ma</cite> と <cite>ta</cite> に 2 ビット、<cite>vsew[1:0]</cite> に 2 ビット、
<cite>vlmul[2:0]</cite> に 3 ビットです。
<cite>vill</cite> で表される不正な値は、<cite>vsew[1:0]</cite> の不正な64ビットの組み合わせを使って内部的にエンコードすることができ、
<cite>vill</cite> を保持するための追加のストレージビットを必要としません。</p>
<p>NOTE: 標準ベクトルやカスタムベクトル拡張により、これらのフィールドが拡張され、
より多様なデータ型がサポートされるようになります。</p>
<p>NOTE: 64ビット命令エンコーディングの拡張により、
これらのフィールドを命令エンコーディング内で静的に指定できるようになることが予想されます。</p>
<div class="section" id="vsew-2-0">
<h4>ベクトル選択要素幅 <cite>vsew[2:0]</cite><a class="headerlink" href="#vsew-2-0" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><cite>vsew</cite> の値は、動的な _選択要素幅_ (SEW)を設定します。
デフォルトでは、ベクトルレジスタは、
VLEN/SEW要素に分割されているとみなされます。</p>
<p>.vsew[2:0] (選択要素幅) エンコーディング
[cols=&quot;1,1,1,1,&gt;13&quot;]
[%autowidth]
<a href="#id214"><span class="problematic" id="id215">|===
3+|</span></a> vsew[2:0] | SEW |</p>
<div class="line-block">
<div class="line">0 | 0 | 0 |    8 |</div>
<div class="line">0 | 0 | 1 |   16 |</div>
<div class="line">0 | 1 | 0 |   32 |</div>
<div class="line">0 | 1 | 1 |   64 |</div>
<div class="line">1 | 0 | 0 |  128 | _予約_</div>
<div class="line">1 | 0 | 1 |  256 | _予約_</div>
<div class="line">1 | 1 | 0 |  512 | _予約_</div>
<div class="line">1 | 1 | 1 | 1024 | _予約_</div>
</div>
<p><a href="#id10"><span class="problematic" id="id11">|</span></a>===</p>
<p>NOTE: 表に示されているように、より大きなSEWをエンコードするために、
より大きな <cite>vsew[2:0]</cite> エンコーディング (<cite>100</cite>-<cite>111</cite>) が使用されることが予想されますが、
このエンコーディングは、現時点では正式には _予約_ です。</p>
<p>.例: VLEN = 128 ビット
[cols=&quot;&gt;,&gt;&quot;]
[%autowidth]
<a href="#id12"><span class="problematic" id="id13">|</span></a>===
| SEW | ベクトルレジスタあたりの要素数</p>
<div class="line-block">
<div class="line">64 |  2</div>
<div class="line">32 |  4</div>
<div class="line">16 |  8</div>
<div class="line-block">
<div class="line">8 | 16</div>
</div>
</div>
<p><a href="#id14"><span class="problematic" id="id15">|</span></a>===</p>
<p>サポートされる要素の幅はLMULによって異なりますが、
プロファイルはLMUL=1でサポートされなければならない最小のSEWを義務付けている場合があります。</p>
<p>NOTE: 一部の実装では、複数のベクトルレジスタのビットを組み合わせた場合にのみ、
大きなSEWをサポートする場合があります。
大きなSEWに依存しているソフトウェアは、コードを実行できる実装の数を増やすために、
最大のLMULを使用し、したがって最小のベクトルレジスタグループを使用するようにしてください。
また、<cite>vtype</cite> を設定した後に、<cite>vtype</cite> の <cite>vill</cite> ビットをチェックして、
その構成がサポートされているかどうかを確認し、
サポートされていない場合には、代替のコードパスを提供する必要があります。
また、プロファイルでは、各LMULの設定で最小のSEWを義務付けることもできます。</p>
</div>
<div class="section" id="vlmul-2-0">
<h4>ベクトルレジスタのグループ化(<cite>vlmul[2:0]</cite>)<a class="headerlink" href="#vlmul-2-0" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>複数のベクトルレジスタをグループ化することで、1つのベクトル命令で複数のベクトルレジスタを操作することができます。
本仕様書では、ベクトル命令の単一オペランドとして使用される1つまたは複数のベクトルレジスタを指すために _ベクトルレジスタグループ_ という用語を使用しています。
ベクトルレジスタグループは、2倍以上の幅の要素を、選択された幅の要素と同じベクトル長で操作することを可能にします。
また、ベクトルレジスタグループは、長いアプリケーションベクトルの実行効率を高めます。</p>
<p>ベクトル長 の倍数 _LMUL_ が1より大きい場合は、ベクトルレジスタグループ形成するために
結合されるベクトルレジスタのデフォルト数を表します。
実装では、LMULは整数値1,2,4,8をサポートする必要があります。</p>
<p>LMUL は、ベクトルレジスタで使用されるビット数を減らすために、小数値を取ることもできます。
LMUL は、1/2、1/4、1/8 の分数値を持つことができます。
小数点以下のLMULは、幅の広いベクトルが複数のベクトルレジスタを使用する必要がないため、
幅の異なる値を操作する際に使用可能なアーキテクチャーレジスタの数を増やすために使用されます。
その代わり、幅の広い値は1つのベクトルレジスタを占有し、
幅の狭い値はベクトルレジスタの端数を占有することができます。</p>
<p>実装では、LMUL {ge}  SEW~LMUL1MIN~/SEW~LMUL1MAX~ の小数の LMUL 設定をサポートする必要があります。
SEW~LMUL1MIN~ はLMUL=1でサポートされる最も狭いSEW値で、
SEW~LMUL1MAX~ はLMUL=1でサポートされる最も広いSEW値です。
サポートされていないSEWとLMULの設定を行おうとすると、 <cite>vtype</cite> の <cite>vill</cite> ビットが設定されます。</p>
<p>サポートされている小数のLMUL設定に対して、
実装はSEW~LMUL1MIN~ とLMUL * SEW~LMUL1MAX~ の間のSEW設定をサポートしなければなりません。</p>
<p>NOTE: LMUL {ge} SEW~LMUL1MIN~/SEW~LMUL1MAX~ を必要とすることで、
幅の広い要素を保持するために1つのベクトルレジスタのみを使用し、幅の狭い要素を保持するために小数のLMULを使用することができます。
LMUL &lt; SEW~LMUL1MIN~/SEW~LMUL1MAX~ の場合、VLEN=SEW~LMUL1MAX~ が有効な実装選択であるため、
少なくとも1つの要素を格納するのに十分なビットが小数ベクトル・レジスタにあるという保証はありません。</p>
<p>NOTE: システムによっては、LMUL&gt;1 に対してより大きなSEW値しかサポートしない場合があるため、
この制約はELENではなくSEW~LMUL1MAX~ を使用して記述されています。
このような場合には、コードがより狭い幅の演算も実行しているときに、単一のベクトルレジスタに保持できる最も広くサポートされた要素を保持するために、
単一のベクトルレジスタ以上のものが必要とされないように、制約が保証されることに注意してください。</p>
<p>LMUL &lt; SEW~LMUL1MIN~/SEW~LMUL1MAX~ での <cite>vtype</cite> エンコーディングの使用は__予約__ですが、
実装はこれらの構成をサポートしていない場合、 <cite>vill</cite> を設定することができます。</p>
<p>NOTE: このケースですべての実装に <cite>vill</cite> を設定することを要求すると、
将来的に拡張機能でこのケースを使用することができなくなるため、
LMUL&lt;SEW~LMUL1MIN~/SEW~LMUL1MAX~ の動作を将来的に定義できるように、
このケースの使用は __予約__ であると考えます。</p>
<p>NOTE: アセンブラは、<cite>vsetvli</cite> 命令が LMUL &lt; SEW~LMUL1MIN~/SEW~LMUL1MAX~ を書こうとした場合、
エラーではなく警告を出すことを推奨します。</p>
<p>LMULは、<cite>vtype</cite> の符号付き <cite>vlmul</cite> フィールドで設定されます (LMUL = 2^`vlmul[2:0]`^)。</p>
<p>VLMAX = LMUL*VLEN/SEW の導出値は、以下の表に示すように、
現在のSEWとLMULの設定があれば、1つのベクト命令で操作できる要素の最大数を表します。</p>
<p>[cols=&quot;1,1,1,2,2,5,5&quot;]
[%autowidth]
<a href="#id16"><span class="problematic" id="id17">|</span></a>===</p>
<blockquote>
<div><p>3+| vlmul[2:0] | LMUL | #groups | VLMAX      | Registers grouped with register __n__</p>
</div></blockquote>
<div class="line-block">
<div class="line">1 | 0 | 0 |   -  |     -   |     -      | reserved</div>
<div class="line">1 | 0 | 1 |   1/8|     32  | VLEN/SEW/8 | <cite>v</cite> __n__ (single register in group)</div>
<div class="line">1 | 1 | 0 |   1/4|     32  | VLEN/SEW/4 | <cite>v</cite> __n__ (single register in group)</div>
<div class="line">1 | 1 | 1 |   1/2|     32  | VLEN/SEW/2 | <cite>v</cite> __n__ (single register in group)</div>
<div class="line">0 | 0 | 0 |   1  |     32  |   VLEN/SEW | <cite>v</cite> __n__ (single register in group)</div>
<div class="line">0 | 0 | 1 |   2  |     16  | 2*VLEN/SEW | <cite>v</cite> __n__, <cite>v</cite> __n__+1</div>
<div class="line">0 | 1 | 0 |   4  |      8  | 4*VLEN/SEW | <cite>v</cite> __n__, ..., <cite>v</cite> __n__+3</div>
<div class="line">0 | 1 | 1 |   8  |      4  | 8*VLEN/SEW | <cite>v</cite> __n__, ..., <cite>v</cite> __n__+7</div>
</div>
<p><a href="#id18"><span class="problematic" id="id19">|</span></a>===</p>
<p>LMUL=2の場合、ベクトレジスタグループには、ベクトレジスタ <cite>v</cite> __n__とベクトレジスタ <cite>v</cite> __n__+1が含まれ、
ビット単位で2倍のベクト長になります。
LMUL=2のベクトレジスタグループで、奇数番号のベクトレジスタを指定する命令は予約されています。</p>
<p>LMUL=4 の場合、ベクトレジスタグループには 4 個のベクトレジスタが含まれ、
4 の倍数ではないベクトレジスタ番号を使用して
LMUL=4 のベクトレジスタグループを指定する命令は予約されます。</p>
<p>LMUL=8 の場合、ベクトレジスタグループには 8 個のベクトレジスタが含まれ、
8 の倍数ではないレジスタ番号を使用して LMUL=8 ベクトレジスタグループを指定する命令は予約されています。</p>
<p>マスクレジスタは、LMULにかかわらず、常に1つのベクトレジスタとして取り扱われます。</p>
<p>[[sec-agnostic]]
.. // ==== Vector Tail Agnostic and Vector Mask Agnostic <cite>vta</cite> and <cite>vma</cite></p>
</div>
<div class="section" id="tail-agnostic-vector-mask-agnostic-vta-vma">
<h4>Tail Agnostic とVector Mask Agnostic <cite>vta</cite> と <cite>vma</cite><a class="headerlink" href="#tail-agnostic-vector-mask-agnostic-vta-vma" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>これらの2つのビットは、ベクトル命令の実行中に、書き込みレジスタのTail要素および
書き込みレジスタの非アクティブなマスクオフされた要素の動作をそれぞれ変更します。
Tailセットと非アクティブセットには、&lt;&lt;sec-inactive-defs&gt;&gt; 項で定義されているように、
ベクトル演算中に新しい結果を受け取らない要素の位置を含んでいます。</p>
<p>すべてのシステムは、4つのオプションすべてをサポートしなければなりません。</p>
<p>[cols=&quot;1,1,3,3&quot;]
[%autowidth]
<a href="#id20"><span class="problematic" id="id21">|</span></a>===
| <cite>vta</cite> | <cite>vma</cite> | 末尾要素 | 非アクティブ要素</p>
<div class="line-block">
<div class="line">0   |   0   | undisturbed   | undisturbed</div>
<div class="line">0   |   1   | undisturbed   | agnostic</div>
<div class="line">1   |   0   | agnostic      | undisturbed</div>
<div class="line">1   |   1   | agnostic      | agnostic</div>
</div>
<p><a href="#id22"><span class="problematic" id="id23">|</span></a>===</p>
<p>セットがundisturbedに設定されている場合、ベクトルレジスタグループ内の対応するセットの書き込み要素は、
以前の値を保持します。
マスクの書き込み値は、<cite>vta</cite> の設定にかかわらず、
常にTail Agnosticとして扱われます。</p>
<p>セットがAgnosticとして設定されている場合、任意のベクトル書き込みオペランドの要素における対応するセットは、
以前保持していた値か、1で上書きされるかのいずれかになります。
1つのベクトル命令の中で、各書き込み要素は、任意の組み合わせで、値を保持したり、1で上書きしたりすることができ、
同じ入力で命令を実行したときに、値を保持するか1で上書きしたりするパタンは、常に決定している必要はありません。
また、マスクロード命令を除き、マスク結果の末尾にある任意の要素には、
マスク生成演算が <a href="#id24"><span class="problematic" id="id25">`</span></a>vl`=VLMAX で計算したであろう値を書き込むこともできます。</p>
<p>NOTE: Agnosticポリシは、ベクトルレジスタをリネームするマシンや、
深い一時的なベクトルレジスタを持つマシンに対応するために追加されました。
Agnosticなポリシでは、新しい物理書き込みベクトルレジスタにコピーするために、
すべての要素を古い物理書き込みベクトルレジスタから読み込まなければなりません。
これは、これらの非アクティブまたは末尾の要素値が後続の計算に必要でない場合、効率が悪くなります。</p>
<p>NOTE: マスクされた末尾要素は、ビット単位で記述可能なマスクデータの管理の複雑さを軽減するために、常にAgnosticに扱われます。
マスクレジスタ値のTail Undisturbedをサポートするソフトウェアの必要性はほとんどないと思われます。
マスクを生成する命令が命令の結果を書き戻すことを許可すると、末尾をマスクアウトするロジックの必要性がなくなります。
ただし、マスクロードは、ソフトウェアの意図を超えてメモリにアクセスすることになるため、
宛先のマスクテールにメモリ値を書き込むことはできません。</p>
<p>NOTE: 上書き値として、All-0ではなくAll-1を選択したのは、
ソフトウェア開発者が書き込まれた値に依存しないようにするためです。</p>
<p>NOTE: シンプルなインオーダー実装であれば、この設定を無視して、単純にundisturbedポリシですべてのベクトル命令を実行することができます。
互換性とスレッドの移行をサポートするために、<cite>vta</cite> と <cite>vma</cite> のステートビットは <cite>vtype</cite> で提供されなければなりません。</p>
<p>NOTE: アウトオブオーダーの実装では、実装の複雑さを軽減するために、
tail-agnostic + mask-agnostic を tail-agnostic + mask-undisturbed を使って実装することを選択できます。</p>
<p>NOTE: Agnosticポリシの定義は、小さなインオーダコア上のhart(おそらくagnostic領域は保持される)と、
レジスタリネーミングのある大きなアウトオブオーダコア上のhart(おそらくagnostic要素を1で上書きする)の間でアプリケーションスレッドを
移行することに対応するため、緩く残されています。
途中で再起動する必要があるかもしれないので、1つのベクトル命令の中で、Agnosticなポリシを任意に混在させることができます。
このようなポリシの混在を許容することで、
例えば、アクティブに操作されている要素内ではundisturbedを使用し、テールの要素ではすべて1にリネームするなど、
ベクトルレジスタの異なる要素に対してポリシを変更するような実装も可能になります。</p>
<p>アセンブリ構文では、 <cite>vsetvli</cite> 命令に2つのフラグが追加されています。</p>
<dl>
<dt>::</dt><dd><p>ta   # Tail agnostic
tu   # Tail undisturbed
ma   # Mask agnostic
mu   # Mask undisturbed</p>
<p>vsetvli t0, a0, e32, m4, ta, ma   # Tail agnostic, mask agnostic
vsetvli t0, a0, e32, m4, tu, ma   # Tail undisturbed, mask agnostic
vsetvli t0, a0, e32, m4, ta, mu   # Tail agnostic, mask undisturbed
vsetvli t0, a0, e32, m4, tu, mu   # Tail undisturbed, mask undisturbed</p>
</dd>
</dl>
<p>NOTE: 短期的には後方互換性を維持し、0.9 への移行時にはソフトウェアの変更を減らすために、これらのフラグが <cite>vsetvli</cite> に指定されていない場合は、
デフォルトで mask-undisturbed/tail-undisturbed とすべきです。
しかし、これらのフラグを持たない <cite>vsetvli</cite> の使用は非推奨とし、
フラグ設定の指定が必須となるようにします。
どちらかというと、デフォルトはtail-agnostic/mask-agnosticにすべきなので、
ソフトウェアは非アクティブ要素を気にするタイミングを指定する必要がありますが、
これらのフラグが導入される前の命令の歴史的な意味を考えると、
将来のアセンブリコードでは常にフラグを要求するのが最も安全です。</p>
</div>
<div class="section" id="vill">
<h4>不正ベクトル型 <cite>vill</cite><a class="headerlink" href="#vill" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><cite>vill</cite> ビットは、過去の <cite>vset{i}vl{i}</cite> 命令がサポートされていない値を <cite>vtype</cite> に書き込もうとしたことをエンコードするために使用されます。</p>
<p>NOTE: <cite>vill</cite> ビットはCSRのXLEN-1ビットに配置され、
符号を検査する分岐命令で不正な値をチェックできます。</p>
<p><cite>vill</cite> ビットがセットされている場合、<cite>vtype</cite> に依存するベクトル命令を実行しようとすると、
不正命令例外が発生します。</p>
<p>NOTE: <cite>vset{i}vl{i}</cite> とwhole-registerロード、ストア命令、データ移動命令は <cite>vtype</cite> に依存しません。</p>
<p><cite>vill</cite> ビットがセットされているときは、
<cite>vtype</cite> の他のXLEN-1ビットはゼロでなければなりません。</p>
</div>
</div>
<div class="section" id="vl">
<h3>ベクトル長レジスタ <cite>vl</cite><a class="headerlink" href="#vl" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>_XLEN_ ビット幅の読み込み専用 <cite>vl</cite> CSRは、<cite>vset{i}vl{i}</cite> 命令と、
_fault-<a href="#id236"><span class="problematic" id="id237">only-first_</span></a> ベクトルロード命令によってのみ更新することができます。</p>
<p><cite>vl</cite> レジスタは、セクション &lt;&lt;sec-inactive-defs&gt;&gt; で詳しく説明されているように、
ベクトル命令の結果で更新される要素数を指定する符号なし整数を保持します。</p>
<p>NOTE: <cite>vl</cite> に実装されているビット数は、サポートされている最小のタイプの実装の最大ベクトル長に依存します。
VLEN=32 で SEW=8 をサポートする最小のベクトル実装では、0～32 の値を保持するために、
<cite>vl</cite> に少なくとも 6 ビットが必要になります (VLEN=32 で LMUL=8 と SEW=8 を使用すると、VLMAX=32 になります)。</p>
</div>
<div class="section" id="vlenb">
<h3>ベクトルバイト長 <cite>vlenb</cite><a class="headerlink" href="#vlenb" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>_XLEN_ ビット幅の読み取り専用CSR <cite>vlenb</cite> は、値VLEN/8、すなわち、
バイト単位でのベクトルレジスタの長さを保持します。</p>
<p>NOTE: <cite>vlenb</cite> の値は、どのような実装でも設計時の定数となります。</p>
<p>NOTE: このCSRがないと、バイト単位のVLENを計算するためにいくつかの命令が必要になり、
コードは現在の <cite>vl</cite> と <cite>vtype</cite> の設定を乱す必要があり、
それらを保存したり復元したりする必要があります。</p>
</div>
<div class="section" id="csr-vstart">
<h3>ベクトルスタートインデックスCSR <cite>vstart</cite><a class="headerlink" href="#csr-vstart" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>読み書き可能なCSRである <cite>vstart</cite> は、 &lt;&lt;sec-inactive-defs&gt;&gt; 項で説明したように、
ベクトル命令で実行される最初の要素のインデックスを指定します。</p>
<p>通常、<cite>vstart</cite> はベクトル命令の例外発生時にハードウェアによってのみ書き込まれ、
<cite>vstart</cite> の値は例外発生した要素 (同期例外または非同期割り込み) を表し、
再開可能な例外が処理された後に実行が再開されるべき要素を表します。</p>
<p>すべてのベクトル命令は、 <cite>vstart</cite> CSR で指定された要素インデックスから実行を開始し、
書き込みベクトル内の以前の要素には影響を与えず、実行終了時には <cite>vstart</cite> CSR をゼロにリセットするように定義されています。</p>
<p>NOTE: <cite>vset{i}vl{i}</cite> を含むすべてのベクトル命令は、<cite>vstart</cite> CSR をゼロにリセットします。</p>
<p><cite>vstart</cite>  は、不正命令例外を発生させるベクトル命令によって変更されません。</p>
<p><cite>vstart</cite> CSR は、最大の要素インデックスを保持するのに十分な書き込み可能なビットのみを持つように定義されます (最大 VLMAX より 1 つ少ない)。</p>
<p>NOTE: 最大のベクトル長は、最大のLMUL設定(8)と最小のSEW設定(8)で得られるため、VLMAX_max = 8*VLEN/8 = VLENとなります。
例えば、VLEN=256の場合、<cite>vstart</cite> は、0から255までのインデックスを表す8ビットを持つことになります。</p>
<p>現在のSEW設定の最大要素インデックスよりも大きい <cite>vstart</cite> 値の使用は予約されています。</p>
<p>NOTE: <cite>vstart</cite> が範囲外の場合には、実装で例外を発生させることが推奨されています。
上位の <cite>vstart</cite> ビットの将来的な使用法として、
不正確な例外情報を保存することが考えられるため、
例外を発生させることは必須ではありません。</p>
<p><cite>vstart</cite> CSR は非特権コードによって書き込み可能ですが、
非ゼロの <cite>vstart</cite> 値はいくつかの実装でベクトル命令の実行速度を大幅に低下させる可能性があるため、
<cite>vstart</cite> はアプリケーション・プログラマーが使用すべきではありません。
いくつかのベクトル命令は、非ゼロの <cite>vstart</cite> 値では実行できず、
以下に定義するような不正な命令例外を発生させます。</p>
<p>NOTE: <cite>vstart</cite> を非特権コードから見えるようにすることは、
ユーザレベルのスレッディングライブラリをサポートします。</p>
<p>実装は、同じ <cite>vtype</cite> 設定で同じ命令を実行した場合でも、
実装が決して生成できない <cite>vstart</cite> の値を持つベクトル命令を実行しようとした場合、
不正命令例外を発生させることが許可されています。</p>
<p>NOTE: 例えば、ある実装では、ベクトル演算命令の実行中には決して割り込みを受け取らず、
命令が完了するまで待って割り込みを受け取ります。
そのような実装では、 <cite>vstart</cite> が0でないときにベクトル演算命令を実行しようとすると、
不正な命令例外を発生させることができます。</p>
<p>NOTE: マイクロアーキテクチャの異なる 2 つの hart 間でソフトウェア・スレッドを移行する場合、
<cite>vstart</cite> 値は新しい hart のマイクロアーキテクチャーではサポートされていない可能性があります。
その場合、受信側の hart のランタイムは、サポートされている vstart 要素の位置への命令実行をエミュレートしなければならないかもしれません。
あるいは、移行イベントは、相互にサポートされる <cite>vstart</cite> 位置でのみ発生するように制約することもできます。</p>
</div>
<div class="section" id="vxrm">
<h3>ベクトル固定小数点丸めモードレジスタ <cite>vxrm</cite><a class="headerlink" href="#vxrm" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ベクトル固定小数点丸めモード・レジスタは、2ビットの読み書き可能な丸め込みモード・フィールドを保持します。
ベクトル固定小数点丸め込みモードは、独立してアクセスできるように、
別のCSRアドレスが与えられていますが、 <cite>vcsr</cite> のフィールドとしても反映されています。</p>
<p>固定小数点丸めのアルゴリズムは以下のように規定されています。
丸め前の結果を <cite>v</cite> とし、その結果の <cite>d</cite> ビットを丸めるとします。
このとき、丸められた結果は <cite>(v &gt;&gt; d) + r</cite> となり、 <cite>r</cite>  は次の表にあるように丸めモードに依存します。</p>
<p>.vxrm encoding
[cols=&quot;1,1,4,10,5&quot;]
[%autowidth]
<a href="#id216"><span class="problematic" id="id217">|===
2+|</span></a> <cite>vxrm[1:0]</cite> | Abbreviation | Rounding Mode | Rounding increment, <cite>r</cite></p>
<div class="line-block">
<div class="line">0 | 0 | rnu | round-to-nearest-up (add +0.5 LSB)          | <cite>v[d-1]</cite></div>
<div class="line">0 | 1 | rne | round-to-nearest-even                       | <cite>v[d-1] &amp; (v[d-2:0]{ne}0 | v[d])</cite></div>
<div class="line">1 | 0 | rdn | round-down (truncate)                       | <cite>0</cite></div>
<div class="line">1 | 1 | rod | round-to-odd (OR bits into LSB, aka &quot;jam&quot;)  | <cite>!v[d] &amp; v[d-1:0]{ne}0</cite></div>
</div>
<p><a href="#id26"><span class="problematic" id="id27">|</span></a>===</p>
<p>以下の命令の説明では、丸め関数を表すために以下の操作が使用されています。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">roundoff_unsigned</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">unsigned</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="n">r</span>
<span class="n">roundoff_signed</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">signed</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="n">r</span>
</pre></div>
</div>
<p><cite>vxrm[XLEN-1:2]</cite> はゼロが書き込まれるべきです。</p>
<p>NOTE: <cite>csrwi</cite> 1命令を使って、元の丸め込みモードを保存しながら、
新しい丸め込みモードを設定することができます。</p>
</div>
<div class="section" id="vxsat">
<h3>ベクトル固定小数点飽和フラグ <cite>vxsat</cite><a class="headerlink" href="#vxsat" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><cite>vxsat</cite> CSRは読み書き可能な1ビットを保持しており、
固定小数点命令が出力値を出力先のフォーマットに収めるために飽和させる必要があったかどうかを示します。</p>
<p><cite>vxsat</cite> ビットは <cite>vcsr</cite> のミラーです。</p>
</div>
<div class="section" id="vector-vcsr">
<h3>Vector 制御・ステータスレジスタ <cite>vcsr</cite><a class="headerlink" href="#vector-vcsr" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><cite>vxrm</cite> と <cite>vxsat</cite> CSRは、ベクトル制御・ステータスCSRである <cite>vcsr</cite> のフィールドを介してアクセスすることもできます。</p>
<p>.vcsr layout
[cols=&quot;&gt;2,4,10&quot;]
[%autowidth]
<a href="#id28"><span class="problematic" id="id29">|</span></a>===
| Bits | Name   | Description</p>
<div class="line-block">
<div class="line">2:1 | vxrm[1:0] | Fixed-point rounding mode</div>
<div class="line-block">
<div class="line">0 | vxsat     | Fixed-point accrued saturation flag</div>
</div>
</div>
<p><a href="#id30"><span class="problematic" id="id31">|</span></a>===</p>
</div>
<div class="section" id="id32">
<h3>リセット時のベクトル拡張の状態<a class="headerlink" href="#id32" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ベクトル拡張は、リセット時に一貫した状態を持っている必要があります。
特に、<cite>vtype</cite> と <cite>vl</cite> は、1つの <cite>vsetvl</cite> 命令で読み取ってから復元できる値を持っていなければなりません。</p>
<p>NOTE: リセット時には、<cite>vtype.vill</cite> が設定され、<cite>vtype</cite> の残りのビットはゼロになり、<cite>vl</cite> はゼロになることが推奨されます。</p>
<p><cite>vstart</cite>, <cite>vxrm</cite>, <cite>vxsat</cite> CSR は、リセット時に任意の値を持つことができます。</p>
<p>NOTE: ベクトルユニットを使用する場合は、初期化のための <cite>vset{i}vl{i}</cite> が必要で、
これにより <cite>vstart</cite> がリセットされます。
<cite>vxrm</cite> と <cite>vxsat</cite> フィールドは、使用前にソフトウェアで明示的にリセットする必要があります。</p>
<p>ベクトルレジスタはリセット時に任意の値を持つことができます。</p>
</div>
</div>
<div class="section" id="id33">
<h2>ベクトルレジスタ状態へのベクトル要素のマッピング<a class="headerlink" href="#id33" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下の図は、現在のSEWおよびLMULの設定と、実装のVLENに応じて、
異なる幅の要素がどのようにベクトルレジスタのバイトに詰め込まれるかを示しています。
要素は、最下位バイトが最下位ビットになるように各ベクトルレジスタに詰め込まれます。</p>
<div class="section" id="lmul-1">
<h3>LMUL = 1 時のマッピング<a class="headerlink" href="#lmul-1" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>LMUL=1の場合、要素はベクトルレジスタの最下位ビットから最上位ビットの順に単純にパックされます。</p>
<p>NOTE: 読みやすさを向上させるために、ベクトルレジスタのレイアウトは、
バイトアドレスが右から左に向かって増加するように並べられています。
要素内のビットはリトルエンディアン形式で番号付けされており、
右から左へのビットインデックスの増加は大きさの増加に対応します。</p>
<dl>
<dt>::</dt><dd><p>// LMUL=1 examples.
LMUL=1の例</p>
<p>The element index is given in hexadecimal and is shown placed at the
least-significant byte of the stored element.</p>
<p>要素のインデックスは16進数で与えられ、
格納された要素の最下位バイトに配置されて表示されます。</p>
<blockquote>
<div><p>VLEN=32b</p>
<p>Byte         3 2 1 0</p>
<p>SEW=8b       3 2 1 0
SEW=16b        1   0
SEW=32b            0</p>
<p>VLEN=64b</p>
<p>Byte        7 6 5 4 3 2 1 0</p>
<p>SEW=8b      7 6 5 4 3 2 1 0
SEW=16b       3   2   1   0
SEW=32b           1       0
SEW=64b                   0</p>
<p>VLEN=128b</p>
<p>Byte        F E D C B A 9 8 7 6 5 4 3 2 1 0</p>
<p>SEW=8b      F E D C B A 9 8 7 6 5 4 3 2 1 0
SEW=16b       7   6   5   4   3   2   1   0
SEW=32b           3       2       1       0
SEW=64b                   1               0
SEW=128b                                  0</p>
<p>VLEN=256b</p>
<p>Byte     1F1E1D1C1B1A19181716151413121110 F E D C B A 9 8 7 6 5 4 3 2 1 0</p>
<p>SEW=8b   1F1E1D1C1B1A19181716151413121110 F E D C B A 9 8 7 6 5 4 3 2 1 0
SEW=16b     F   E   D   C   B   A   9   8   7   6   5   4   3   2   1   0
SEW=32b         7       6       5       4       3       2       1       0
SEW=64b                 3               2               1               0
SEW=128b                                1                               0</p>
</div></blockquote>
</dd>
</dl>
</div>
<div class="section" id="id34">
<h3>LMUL &lt; 1の場合のマッピング<a class="headerlink" href="#id34" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>LMUL &lt; 1 の場合、ベクトルレジスタの最初の LMUL*VLEN/SEW 要素のみが使用される。
ベクトルレジスタ内の残りのスペースはテールの一部として扱われるため、
vtaの設定に従わなければなりません。</p>
<dl>
<dt>::</dt><dd><p>// Example, VLEN=128b, LMUL=1/4
VLEN=128b, LMUL=1/4の例</p>
<p>Byte        F E D C B A 9 8 7 6 5 4 3 2 1 0</p>
<p>SEW=8b      - - - - - - - - - - - - 3 2 1 0
SEW=16b       -   -   -   -   -   -   1   0
SEW=32b           -       -       -       0</p>
</dd>
</dl>
</div>
<div class="section" id="id35">
<h3>LMUL &gt; 1 のマッピング<a class="headerlink" href="#id35" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ベクトルレジスタがグループ化されると、ベクトルレジスタグループの要素は、構成するベクトルレジスタ間でストライプされます。
要素は、グループ内の各ベクトルレジスタに要素順に連続して詰められ、
各ベクトルレジスタが満たされると、グループ内の次の最高番号(訳注:ここが上手く訳せない)のベクトルレジスタに移動します。</p>
<dl>
<dt>::</dt><dd><p>// LMUL &gt; 1 examples</p>
<p>LMUL &gt; 1の例</p>
<blockquote>
<div><p>VLEN=32b, SEW=8b, LMUL=2</p>
<p>Byte         3 2 1 0
v2*n         3 2 1 0
v2*n+1       7 6 5 4</p>
<p>VLEN=32b, SEW=16b, LMUL=2</p>
<p>Byte         3 2 1 0
v2*n           1   0
v2*n+1         3   2</p>
<p>VLEN=32b, SEW=16b, LMUL=4</p>
<p>Byte         3 2 1 0
v4*n           1   0
v4*n+1         3   2
v4*n+2         5   4
v4*n+3         7   6</p>
<p>VLEN=32b, SEW=32b, LMUL=4</p>
<p>Byte         3 2 1 0
v4*n               0
v4*n+1             1
v4*n+2             2
v4*n+3             3</p>
<p>VLEN=64b, SEW=32b, LMUL=2</p>
<p>Byte         7 6 5 4 3 2 1 0
v2*n               1       0
v2*n+1             3       2</p>
<p>VLEN=64b, SEW=32b, LMUL=4</p>
<p>Byte         7 6 5 4 3 2 1 0
v4*n               1       0
v4*n+1             3       2
v4*n+2             5       4
v4*n+3             7       6</p>
<p>VLEN=128b, SEW=32b, LMUL=2</p>
<p>Byte        F E D C B A 9 8 7 6 5 4 3 2 1 0
v2*n              3       2       1       0
v2*n+1            7       6       5       4</p>
<p>VLEN=128b, SEW=32b, LMUL=4</p>
<p>Byte          F E D C B A 9 8 7 6 5 4 3 2 1 0
v4*n                3       2       1       0
v4*n+1              7       6       5       4
v4*n+2              B       A       9       8
v4*n+3              F       E       D       C</p>
</div></blockquote>
</dd>
</dl>
</div>
<div class="section" id="id36">
<h3>混合幅演算でのマッピングについて<a class="headerlink" href="#id36" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ベクトルISAは、明示的な追加再配置命令を必要とせずに、混合幅の演算をサポートするように設計されています。
異なる精度のベクトルを操作する場合、推奨されるソフトウェア戦略は、<cite>vtype</cite> を動的に変更して、
SEW/LMULを一定に保つことです(したがって、VLMAXも一定になります)。</p>
<p>次の例では、VLEN=128bの実装において、4つの異なるパックエレメント幅(8b、16b、32b、64b)を示しています。
ベクトルレジスタのグループ化係数(LMUL)は、各グループが同じ数のベクトル要素(この例ではVLMAX=8)を保持できるように、
相対的な要素サイズによって増加し、ストリップマイニングコードを簡素化します。</p>
<dl>
<dt>::</dt><dd><p>Example VLEN=128b, with SEW/LMUL=16</p>
<p>Byte      F E D C B A 9 8 7 6 5 4 3 2 1 0
vn        - - - - - - - - 7 6 5 4 3 2 1 0  SEW=8b, LMUL=1/2</p>
<p>vn          7   6   5   4   3   2   1   0  SEW=16b, LMUL=1</p>
<p>v2*n            3       2       1       0  SEW=32b, LMUL=2
v2*n+1          7       6       5       4</p>
<p>v4*n                    1               0  SEW=64b, LMUL=4
v4*n+1                  3               2
v4*n+2                  5               4
v4*n+3                  7               6</p>
</dd>
</dl>
<p>次の表は、幅が混在しているループで考えられる一定のSEW/LMULの動作点を示しています。
各列は一定のSEW/LMUL動作点を表しています。
表のエントリは、その行のデータ幅に対して、その列のSEW/LMUL値をもたらすLMUL値です。
各列のデータ幅のLMUL設定は、同じ列のLMUL設定を持つ他のデータ幅と、すべてが同じVLMAXになるように整列できることを示しています。</p>
<p><a href="#id37"><span class="problematic" id="id38">|</span></a>===
| SEW/LMUL | 1 |  2 |  4 |  8 | 16  | 32  |  64  | 128 |  256 | 512 | 1024 <a href="#id39"><span class="problematic" id="id40">|</span></a>2048 <a href="#id41"><span class="problematic" id="id42">|</span></a>4096 <a href="#id43"><span class="problematic" id="id44">|</span></a>8192</p>
<div class="line-block">
<div class="line">SEW=   8 | 8 |  4 |  2 |  1 | 1/2 | 1/4 |  1/8 |     |      |     |      |     |     |</div>
<div class="line">SEW=  16 |   |  8 |  4 |  2 |  1  | 1/2 |  1/4 | 1/8 |      |     |      |     |     |</div>
<div class="line">SEW=  32 |   |    |  8 |  4 |  2  |  1  |  1/2 | 1/4 |  1/8 |     |      |     |     |</div>
<div class="line">SEW=  64 |   |    |    |  8 |  4  |  2  |   1  | 1/2 |  1/4 | 1/8 |      |     |     |</div>
<div class="line">SEW= 128 |   |    |    |    |  8  |  4  |   2  |  1  |  1/2 | 1/4 |  1/8 |     |     |</div>
<div class="line">SEW= 256 |   |    |    |    |     |  8  |   4  |  2  |   1  | 1/2 |  1/4 | 1/8 |     |</div>
<div class="line">SEW= 512 |   |    |    |    |     |     |   8  |  4  |   2  |  1  |  1/2 | 1/4 | 1/8 |</div>
<div class="line">SEW=1024 |   |    |    |    |     |     |      |  8  |   4  |  2  |   1  | 1/2 | 1/4 | 1/8</div>
</div>
<p><a href="#id45"><span class="problematic" id="id46">|</span></a>===</p>
<p>LMULの設定を大きくすると、単純にベクトルの長さを長くして命令のフェッチとディスパッチのオーバーヘッドを減らすことができ、
ベクトルレジスタグループの数が少なくて済む場合にも使用できます。</p>
<p>NOTE: SEW/LMULの値が2048以上の場合、完全性を保つために表に示していますが、これらの値はレジスタ容量をフルに使用しておらず、
より多くのアーキテクチャレジスタを有効にしていないため、有用な動作ポイントを追加していません。</p>
</div>
<div class="section" id="lmul-1-elen-vlen">
<h3>LMUL &gt; 1 かつ ELEN &gt; VLEN のマッピング<a class="headerlink" href="#lmul-1-elen-vlen" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>より大きなSEWをサポートするためにベクトルレジスタがグループ化され、ELEN &gt; VLENとなった場合、
グループ内のベクトルレジスタは連結されて1つのバイト配列となり、
グループ内で最も番号の低いレジスタが、メモリレイアウトから最も低いアドレスのバイトを保持します。</p>
<dl>
<dt>::</dt><dd><p>LMUL &gt; 1 ELEN&gt;VLEN, examples</p>
<p>VLEN=32b, SEW=64b, LMUL=2</p>
<p>Byte         3 2 1 0
v2*n               0
v2*n+1</p>
<p>VLEN=32b, SEW=64b, LMUL=4</p>
<p>Byte         3 2 1 0
v4*n               0
v4*n+1
v4*n+2             1
v4*n+3</p>
<p>VLEN=32b, SEW=64b, LMUL=8</p>
<p>Byte         3 2 1 0
v8*n               0
v8*n+1
v8*n+2             1
v8*n+3
v8*n+4             2
v8*n+5
v8*n+6             3
v8*n+7</p>
</dd>
</dl>
<p>[[sec-mask-register-layout]]
.. // === Mask Register Layout</p>
</div>
<div class="section" id="id47">
<h3>マスクレジスタのレイアウト<a class="headerlink" href="#id47" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ベクトルマスクは、SEWやLMULに関係なく、1つのベクトルレジスタのみを占有します。
各要素には、マスクベクトルレジスタに1つのマスクビットが割り当てられます。</p>
<p>NOTE: 初期のデザイン(0.9以前)では、マスク値あたりのビット数(MLEN)が変化していました。
0.9デザインでは、MLEN=1です。</p>
<div class="section" id="id48">
<h4>マスク要素の場所<a class="headerlink" href="#id48" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>要素 _i_ のマスクビットは、SEWやLMULとは関係なく、マスクレジスタのビット _i_ に配置されます。</p>
<dl>
<dt>::</dt><dd><p>VLEN=32b</p>
<blockquote>
<div><p>Byte    3   2   1   0</p>
</div></blockquote>
<dl>
<dt>LMUL=1,SEW=8b</dt><dd><blockquote>
<div><p>3   2   1   0  Element</p>
</div></blockquote>
<p>[03][02][01][00] Mask bit position in decimal</p>
</dd>
<dt>LMUL=2,SEW=16b</dt><dd><blockquote>
<div><p>1       0</p>
</div></blockquote>
<dl class="simple">
<dt>[01]    [00]</dt><dd><p>3       2</p>
</dd>
</dl>
<p>[03]    [02]</p>
</dd>
<dt>LMUL=4,SEW=32b               0</dt><dd><dl class="simple">
<dt>[00]</dt><dd><p>1</p>
</dd>
<dt>[01]</dt><dd><p>2</p>
</dd>
<dt>[02]</dt><dd><p>3</p>
</dd>
</dl>
<p>[03]</p>
</dd>
</dl>
</dd>
</dl>
<dl>
<dt>::</dt><dd><dl>
<dt>LMUL=2,SEW=8b</dt><dd><blockquote>
<div><p>3   2   1   0</p>
</div></blockquote>
<dl class="simple">
<dt>[03][02][01][00]</dt><dd><p>7   6   5   4</p>
</dd>
</dl>
<p>[07][06][05][04]</p>
</dd>
<dt>LMUL=8,SEW=32b</dt><dd><blockquote>
<div><p>0</p>
</div></blockquote>
<dl class="simple">
<dt>[00]</dt><dd><p>1</p>
</dd>
<dt>[01]</dt><dd><p>2</p>
</dd>
<dt>[02]</dt><dd><p>3</p>
</dd>
<dt>[03]</dt><dd><p>4</p>
</dd>
<dt>[04]</dt><dd><p>5</p>
</dd>
<dt>[05]</dt><dd><p>6</p>
</dd>
<dt>[06]</dt><dd><p>7</p>
</dd>
</dl>
<p>[07]</p>
</dd>
<dt>LMUL=8,SEW=8b</dt><dd><blockquote>
<div><p>3   2   1   0</p>
</div></blockquote>
<dl class="simple">
<dt>[03][02][01][00]</dt><dd><p>7   6   5   4</p>
</dd>
<dt>[07][06][05][04]</dt><dd><p>B   A   9   8</p>
</dd>
<dt>[11][10][09][08]</dt><dd><p>F   E   D   C</p>
</dd>
<dt>[15][14][13][12]</dt><dd><p>13  12  11  10</p>
</dd>
<dt>[19][18][17][16]</dt><dd><p>17  16  15  14</p>
</dd>
<dt>[23][22][21][20]</dt><dd><p>1B  1A  19  18</p>
</dd>
<dt>[27][26][25][24]</dt><dd><p>1F  1E  1D  1C</p>
</dd>
</dl>
<p>[31][30][29][28]</p>
</dd>
</dl>
</dd>
</dl>
</div>
</div>
</div>
<div class="section" id="id49">
<h2>ベクトル命令フォーマット<a class="headerlink" href="#id49" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトル拡張の命令は、既存の2つのメジャーオペコード(LOAD-FP、STORE-FP)と1つの新しいメジャーオペコード(OP-V)に当てはまります。</p>
<p>ベクトルのロードとストアは、スカラ浮動小数点のロードとストアのメジャーオペコード(LOAD-FP/STORE-FP)の中にエンコードされます。
ベクトルロード/ストアのエンコーディングは、標準的なスカラ浮動小数点ロード/ストアの12ビット即値フィールドの一部を再利用して、
さらにベクトル命令のエンコーディングを行い、ビット25には標準的なベクトルマスクビット ( &lt;&lt;sec-vector-mask-encoding&gt;&gt; を参照)を格納します。</p>
<p>include::vmem-format.adoc[]</p>
<p>include::valu-format.adoc[]</p>
<p>include::vcfg-format.adoc[]</p>
<p>ベクトル命令は、スカラまたはベクトルのソースオペランドを持ち、
スカラまたはベクトルの結果を生成することができ、
ほとんどのベクトル命令は、無条件またはマスクの下で条件付きで実行することができます。</p>
<p>ベクトルのロードとストアは、ベクトルのレジスタ要素とメモリの間でビットパタンを移動させます。
ベクトル演算命令は、ベクトルレジスタ要素に保持された値を演算します。</p>
<div class="section" id="id50">
<h3>スカラオペランド<a class="headerlink" href="#id50" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>スカラオペランドは即値、または <cite>x</cite> レジスタ、<cite>f</cite>  レジスタ、またはベクトルレジスタの要素 0 から取得することができます。
スカラの結果は <cite>x</cite> または <cite>f</cite> レジスタ、またはベクトルレジスタの要素 0 に書き込まれます。
現在の LMUL の設定に関わらず、どのベクトルレジスタもスカラを保持するために使用できます。</p>
<p>NOTE: v0.6 からの変更点として、浮動小数点レジスタがベクトルレジスタをオーバーレイしなくなり、スカラは整数または浮動小数点レジスタから得られるようになりました。
<cite>f</cite> レジスタをオーバーレイしないことで、ベクトルレジスタが圧迫させないようにし、
標準的な呼び出し規則との相互作用を避け、高性能なスカラ浮動小数点の設計を簡素化し、Zfinx ISA オプションとの互換性を実現します。
<cite>f</cite> と <cite>v</cite> を重ねると、実装によってはステート・ビット数を減らせるというメリットがありますが、
高性能な設計が複雑になり、Zfinx ISAオプションとの互換性もなくなります。</p>
</div>
<div class="section" id="id51">
<h3>ベクトルオペランド<a class="headerlink" href="#id51" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>各ベクトルオペランドは、ベクトルレジスタグループ内のすべての要素のサイズと位置を決定するために使用される _effective_ _element_ _width_ (EEW) と _effective_ _LMUL_ (EMUL)を持っています。
デフォルトでは、ほとんどの命令のほとんどのオペランドで、EEW=SEW、EMUL=LMULとなります。</p>
<p>ベクトル命令の中には、ソースと書き込みベクトルオペランドの要素数が同じでも幅が異なるものがあり、
その場合、EEWとEMULはそれぞれSEWとLMULと異なりますが、EEW/EMUL = SEW/LMULとなります。
例えば、Widening演算命令の多くは、ソースグループがEEW=SEW、EMUL=LMULで、
書き込みグループがEEW=2*SEW、EMUL=2*LMULとなっています。
Narrowing命令は、ソースオペランドはEEW=2*SEW、EMUL=2*LMULですが、
書き込みレジスタはEEW=SEW、EMUL=LMULです。</p>
<p>ベクトルオペランドまたは演算結果は、EMULに応じて1つまたは複数のベクトルレジスタを占めることがありますが、
常にグループ内で最も低い番号のベクトルレジスタを使用して指定されます。
ベクトルレジスタグループの指定に最下位のベクトルレジスタ以外を使用するエンコーディングは予約されています。</p>
<p>書き込みベクトルレジスタグループは、次のいずれかが成立する場合に限り、
ソースベクトルレジスタグループとオーバーラップすることができます。</p>
<ul class="simple">
<li><p>書き込みレジスタのEEWとソースのEEWが等しい。</p></li>
<li><p>書き込みレジスタのEEWがソースのEEWよりも小さく、オーバーラップする部分がソースのレジスタグループの最も低い番号の部分である(例えば、LMUL=1の場合、 <cite>vnsrl.wi v0, v0, 3</cite> は合法だが、<cite>v1</cite> の書き込みは合法ではない)。</p></li>
<li><p>書き込みレジスタのEEWがソースのEEWよりも大きく、ソースのEMULが少なくとも1であり、オーバーラップが書き込みレジスタグループの最も高い番号の部分にある場合(例えば、LMUL=8の場合、 <cite>vzext.vf4 v0, v6</cite> は合法ですが、ソースの <cite>v0</cite> 、 <cite>v2</cite> 、<cite>v4</cite> は合法ではない)。</p></li>
</ul>
<p>レジスタグループのオーバーラップ制約のために、マスク要素はEEW=1となります。</p>
<p>ある命令で使用される最大のベクトルレジスタグループは、8個以上のベクトル・レジスタであってはならず(すなわち、EMUL{le}8)、
ベクトル命令が8個以上のベクトルレジスタグループを必要とする場合には、その命令エンコーディングは予約されます。
例えば、LMUL=8のときにWideringされたベクトルレジスタ群の結果を得るWidening演算は、EMUL=16の結果を意味するため、予約されます。</p>
<p>Wideningされたスカラ値(Wideningリダクション演算の結果など)は、
ベクトルレジスタの最初の要素に保持され、EMUL=1となる。</p>
<p>NOTE: 現在のリダクション演算は、入力値と出力値を単一のベクトルレジスタに保持するように定義されており、
暗黙のうちにEMULが1となるため、wide スカラリダクションの結果を保持するためにベクトルレジスタグループを使用することはできません。
この場合、スカラリダクション要素のEMULを指定する独立したパラメータが必要になります。</p>
</div>
<div class="section" id="id52">
<h3>ベクトルマスキング<a class="headerlink" href="#id52" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>マスキングは多くのベクトル命令でサポートされています。
マスクオフされた(非アクティブな)要素の操作は、例外を発生させません。
マスクオフされた要素に対応する書き込みベクトルレジスタの要素は、<cite>vtype</cite> の <cite>vma</cite> ビットの
設定に応じて、mask-undisturbedまたはmask-agnosticのいずれかのポリシで処理されます(セクション &lt;&lt;sec-agnostic&gt;&gt; )。</p>
<p>マスクされたベクトル命令の実行を制御するために使用されるマスク値は、
常にベクトルレジスタ <cite>v0</cite> によって提供されます。</p>
<p>NOTE: 将来のベクトル拡張は、完全なマスクレジスタ指定のためのスペースを持つ、
より長い命令エンコーディングを提供するかもしれません。</p>
<p>マスクド・ベクトル命令の書き込みベクトルレジスタグループは、書き込みベクトルレジスタにマスク値(比較など)やリダクションのスカラ結果が書き込まれていない限り、
ソースマスクレジスタ(<cite>v0</cite>)とオーバーラップすることはできません。
これらの命令エンコーディングは予約済みです。</p>
<p>NOTE: この制約は、非ゼロの <cite>vstart</cite> 値でのリスタートをサポートします。</p>
<p>NOTE: v0.8では有効だった <cite>v0</cite> を対象としたいくつかのマスクされた命令は、v1.0の新しいMLEN=1のマスク・レイアウトでは違法となります。
例えば、 <cite>vadd.vv v0, v1, v2, v0.m</cite> は、以前は LMUL=1 の場合には合法でしたが、現在は常に違法です。</p>
<p>作業用マスクの値を保持するために他のベクトルレジスタを使用することができ、
述語計算を行うためのマスクベクトル論理演算が提供されています。
[[sec-mask-vector-logical]]を参照してください。</p>
<p>&lt;&lt;sec-agnostic&gt;&gt;  で規定されているように、マスクの書き込み値は <cite>vta</cite> の設定にかかわらず、
常に tail-agnostic として扱われます。</p>
<p>[[sec-vector-mask-encoding]]
.. // ==== Mask Encoding</p>
<div class="section" id="id53">
<h4>マスクエンコーディング<a class="headerlink" href="#id53" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>マスキングが可能な場合は、命令内の1ビットの <cite>vm</cite> フィールドにエンコードされます( <cite>inst[25]</cite> )。</p>
<p>[cols=&quot;1,15&quot;]
<a href="#id54"><span class="problematic" id="id55">|</span></a>===
| vm | 説明</p>
<div class="line-block">
<div class="line">0 | ベクトル演算の結果は v0.mask[i]=1の領域にのみ書き込まれる</div>
<div class="line">1 | マスクされない</div>
</div>
<p><a href="#id56"><span class="problematic" id="id57">|</span></a>===</p>
<p>NOTE: 初期の提案では、<cite>vm</cite> は2ビットのフィールド <cite>vm[1:0]</cite> で、
<cite>v0</cite> を使った真と補填マスキングと、スカラ演算の符号化を行っていました。</p>
<p>ベクトルのマスキングはアセンブラのコードでは別のベクトルオペランドとして表現され、<cite>.t</cite> は <cite>v0.mask[i]</cite> が <cite>1</cite> のときに演算が行われるかどうかを示します。
マスキングオペランドが指定されていない場合は、ベクトル実行はマスクされていない(<cite>vm=1</cite>)とされます。</p>
<dl class="simple">
<dt>::</dt><dd><p>vop.v*    v1, v2, v3, v0.t  # マスク有効、v0.mask[i]=1の部分がマスクされる
vop.v*    v1, v2, v3        # マスク無効</p>
</dd>
</dl>
<p>NOTE: 現在のベクトル拡張では、1つのベクトルマスクレジスタ <cite>v0</cite> と真の形式のプレディケートしかサポートしていませんが、
アセンブリ構文では、マスクレジスタ指定子を追加し、真のマスキングと負のマスキングの両方をサポートする可能性のある将来の拡張と互換性を持たせるために、完全な文法を書き出します。
マスキングオペランドの接尾辞 <cite>.t</cite> は、マスクの使用を視覚的に符号化するのにも役立ちます。</p>
<p>NOTE: <cite>.mask</cite> という接尾辞は、アセンブリの構文には含まれていません。
<cite>v0.mask[i]</cite> のように文章中にマスクベクトルに添え字として使用されるだけです。</p>
<p>[[sec-inactive-defs]]
.. // === Prestart, Active, Inactive, Body, and Tail Element Definitions</p>
</div>
</div>
<div class="section" id="id58">
<h3>プリスタート、アクティブ、非アクティブ、ボディ、末尾要素の定義<a class="headerlink" href="#id58" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ベクトル命令の実行時に操作される出力要素のインデックスは、3つのサブセットに分けられます。</p>
<ul class="simple">
<li><p>_プリスタート_ 要素は、要素のインデックスが <cite>vstart</cite> レジスタの初期値よりも小さいものです。</p></li>
</ul>
<p>プリスタート要素は、例外を発生させず、書き込みベクトルレジスタも更新しません。</p>
<ul class="simple">
<li><p>_ボディ_ 要素は、要素のインデックスが <cite>vstart</cite> レジスタの初期値以上で、</p></li>
</ul>
<p><cite>vl</cite> の現在のベクトル長設定よりも小さいものです。ボディは2つの分離したサブセットに分割することができます。</p>
<p>** ベクトル命令の実行中の _アクティブ_ 要素は、ボディ内の要素で、
その要素位置で現在のマスクが有効になっているところです。
アクティブな要素は、例外を発生させたり、書き込みベクトルレジスタグループを更新することができます。</p>
<p>** _非アクティブ_ 要素は、ボディ内の要素で、その要素の位置で現在のマスクが無効になっている要素です。
非アクティブな要素は、 masked agnostic が指定されていない限り (<a href="#id59"><span class="problematic" id="id60">`</span></a>vtype.vma`=1)、
例外を発生させず、書き込みベクトルレジスタグループを更新しません。
この場合、非アクティブな要素は 1 で上書きされる可能性があります。</p>
<ul class="simple">
<li><p>ベクトル命令実行中の _末尾_ 要素は、<cite>vl</cite> で指定された現在のベクトル長設定を超えた要素です。</p></li>
</ul>
<p>末尾要素は例外を発生させず、Tail Agunostics指定されていない限り (<a href="#id61"><span class="problematic" id="id62">`</span></a>vtype.vta`=1)、
書き込みベクトルレジスタグループを更新しません。
この場合、末尾要素は 1 で上書きされるか、マスクロードを除くマスク生成命令の場合は命令の結果で上書きされる可能性があります。
LMUL &lt; 1の場合、末尾には同じベクトルレジスタに保持されているVLMAX以降の要素が含まれます。</p>
<dl class="simple">
<dt>::</dt><dd><p>for element index x
prestart(x) = (0 &lt;= x &lt; vstart)
body(x)     = (vstart &lt;= x &lt; vl)
tail(x)     = (vl &lt;= x &lt; max(VLMAX,VLEN/SEW))
mask(x)     = unmasked || v0.mask[x] == 1
active(x)   = body(x) &amp;&amp; mask(x)
inactive(x) = body(x) &amp;&amp; !mask(x)</p>
</dd>
</dl>
<p><cite>vstart</cite> {ge} <cite>vl</cite> のとき、ボディの要素はなく、どの書き込みベクトルレジスタグループの要素も更新されず、
これは末尾要素がagnosticな値で更新されないことも含みます。</p>
<p>NOTE: 結果として、<cite>vl`=0のときには、 `vstart</cite> にかかわらず、
書き込みベクトルレジスタグループはAgnosticな要素を含めて、いかなる要素も更新されません。</p>
<p><cite>x</cite> レジスタや <cite>f</cite> レジスタを書き込む命令は、
<cite>vl</cite> =0のときも含めて、<cite>vstart</cite> {ge} <cite>vl</cite> のときにも実行されます。</p>
<p>NOTE: <cite>vslidedown</cite> や <cite>vrgather</cite> などの一部の命令は、ソースベクトルレジスタグループの
<cite>vl</cite> または VLMAX を超えるインデックスを読み取ることがあります。
一般的なポリシは、インデックスがソースベクトルレジスタグループのVLMAXよりも大きい場合、値0を返します。</p>
<p>[[sec-vector-config]]
.. // == Configuration-Setting Instructions (<cite>vsetvli</cite>/<cite>vsetivl</cite>/<cite>vsetvl</cite>)</p>
</div>
</div>
<div class="section" id="vsetvli-vsetivl-vsetvl">
<h2>コンフィグレーション設定命令 (<cite>vsetvli</cite>/<cite>vsetivl</cite>/<cite>vsetvl</cite>)<a class="headerlink" href="#vsetvli-vsetivl-vsetvl" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>多数の要素を処理するための一般的なアプローチの一つに、ループの各イタレーションでいくつかの要素を処理し、
すべての要素が処理されるまでイタレーションを続ける&quot;ストリップマイニング&quot;があります。
RISC-Vのベクトル仕様では、この手法を直接かつポータブルにサポートしています。
アプリケーションは、処理する要素の総数(アプリケーションベクトル長、AVL)を <cite>vl</cite> の候補値として指定し、
ハードウェアは、マイクロアーキテクチャの実装と <cite>vtype</cite> の設定に基づいて、
ハードウェアが反復ごとに処理する要素数( <cite>vl</cite> に格納されている) を、汎用レジスタを介して応答します。
&lt;&lt;example-stripmin-sew&gt;&gt; に示されている簡単なループ構造は、コードが残りの要素数とハードウェアが処理する1回あたりの量を簡単に追跡していることを示しています。</p>
<p>アプリケーションのニーズに合わせて <cite>vl</cite> と <cite>vtype</cite> の値を迅速に設定できるように、一連の命令が提供されています。
<cite>vset{i}vl{i}</cite> 命令は、その引数に基づいて、<cite>vtype</cite> と <cite>vl</cite> の CSR を設定し、<cite>rd</cite> に <cite>vl</cite> の新しい値を書き込みます。</p>
<dl class="simple">
<dt>::</dt><dd><p>vsetvli rd, rs1, vtypei   # rd = new vl, rs1 = AVL, vtypei = new vtype setting
vsetivli rd, uimm, vtypei # rd = new vl, uimm = AVL, vtypei = new vtype setting
vsetvl  rd, rs1, rs2      # rd = new vl, rs1 = AVL, rs2 = new vtype value</p>
</dd>
</dl>
<p>include::vcfg-format.adoc[]</p>
<div class="section" id="id63">
<h3><cite>vtype</cite> エンコーディング<a class="headerlink" href="#id63" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>include::vtype-format.adoc[]</p>
<p>新しい <cite>vtype</cite> の設定は、 <cite>vsetvli</cite> と <cite>vsetivli</cite> の即時フィールド、および <cite>vsetvl</cite> の <cite>rs2</cite> レジスタにエンコードされます。</p>
<dl>
<dt>::</dt><dd><blockquote>
<div><p>vset{i}vli の即値vtipeiで提案されるアセンブラ名</p>
<p>e8    # SEW=8b
e16   # SEW=16b
e32   # SEW=32b
e64   # SEW=64b
e128  # SEW=128b
e256  # SEW=256b
e512  # SEW=512b
e1024 # SEW=1024b</p>
<p>mf8  # LMUL=1/8
mf4  # LMUL=1/4
mf2  # LMUL=1/2
m1   # LMUL=1, mの設定を省略した場合
m2   # LMUL=2
m4   # LMUL=4
m8   # LMUL=8</p>
</div></blockquote>
<dl class="simple">
<dt>例:</dt><dd><p>vsetvli t0, a0, e8          # SEW= 8, LMUL=1
vsetvli t0, a0, e8, m2      # SEW= 8, LMUL=2
vsetvli t0, a0, e32, mf2    # SEW=32, LMUL=1/2</p>
</dd>
</dl>
</dd>
</dl>
<p><cite>vsetvl</cite> の動作は、<cite>rs2</cite> から <cite>vtype</cite> の値を受け取ることと、
コンテキストの復元に使えることを除いて、<cite>vsetvli</cite> と同様になります。</p>
<p><cite>vtype</cite> の設定が実装でサポートされていない場合には、<cite>vtype</cite> に <cite>vill</cite> ビットが設定され、
<cite>vtype</cite> の残りのビットは 0 に設定され、<cite>vl</cite> レジスタも 0 に設定されます。</p>
<p>NOTE: 以前のドラフトでは、<cite>vtype</cite> に不正な値を設定した場合、例外が必要でした。
しかし、これはISAへのCSRの書き込み時に最初のデータ依存の例外を追加することになりました。
実装では、 <cite>vill</cite> を設定する代わりに、 <cite>vtype</cite> に不正な値が書き込まれたときに例外することを選択して、
エミュレーションで新しい構成をサポートできるようにして、将来の互換性を確保することができます。
現在のスキームは、ある設定に対して <cite>vill</cite> がクリアされているかどうかをチェックすることで、
サポートされているベクトルユニットの設定をランタイムに軽く照会することをサポートしています。</p>
</div>
<div class="section" id="avl">
<h3>AVLのエンコーディング<a class="headerlink" href="#avl" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>新しいベクトル長の設定はAVLに基づいており、 <cite>vsetvli</cite> と <cite>vsetvl</cite> では、 <cite>rs1</cite> と <cite>rd</cite> のフィールドに以下のようにエンコードされます。</p>
<p>.`vsetvli` と <cite>vsetvl</cite> 命令に使用されるAVL
[cols=&quot;2,2,10,10&quot;]
[%autowidth]
<a href="#id64"><span class="problematic" id="id65">|</span></a>===
|  <cite>rd</cite>  | <cite>rs1</cite>  | AVL値             | <cite>vl</cite> を更新する
|  -     | !x0    | <cite>x[rs1]</cite> の値     | 通常のストリップマイニング
| !x0    |  x0    | ~0                | <cite>vl</cite> を VLMAXに設定する
|  x0    |  x0    | <cite>vl</cite> レジスタの値 | <cite>vl</cite> をキープする(もちろん、 <cite>vtype</cite> は変更される)
<a href="#id66"><span class="problematic" id="id67">|</span></a>===</p>
<p><cite>rs1</cite> が <cite>x0</cite> でない場合、AVL は <cite>rs1</cite> で指定された <cite>x</cite> レジスタに保持される符号なし整数となり、
新しい <cite>vl</cite> 値も <cite>rd</cite> で指定された <cite>x</cite> レジスタに書き込まれます。</p>
<p><cite>rs1=x0</cite> であるが、 <cite>rd!=x0</cite> のときは、符号なし整数の最大値 (<cite>~0</cite>) が AVL として使用され、
結果として VLMAX が <cite>vl</cite> に書き込まれ、 <cite>rd</cite> で指定された <cite>x</cite> レジスタにも書き込まれます。</p>
<p><cite>rs1=x0</cite> かつ <cite>rd=x0</cite> の場合、この命令は <cite>vl</cite> の現在のベクトル長をAVLとして使用し、
結果の値は <cite>vl</cite> に書き込まれますが、書き込みレジスタには書き込まれません。
この形式はVLMAXの場合にのみ使用でき、したがって <cite>vl</cite> は新しいSEW/LMUL比によって実際には変更されません。
VLMAXの変更をもたらすような新しいSEW/LMUL比率の命令の使用は予約済みです。
この場合、実装では <cite>vill</cite> を設定することができます。</p>
<p>NOTE: この命令の最後の形式では、VLMAXが減少しないことを条件に、現在の <cite>vl</cite> を維持しながら <cite>vtype</cite> レジスタを変更することができます。
この設計は、現在の <cite>vtype</cite> 設定に対して <cite>vl</cite> が常に正当な値を保持するように選択されました。
現在の <cite>vl</cite> 値は <cite>vl</cite> CSR から読み取ることができます。
新しいSEW/LMUL比率によってVLMAXが縮小する場合、この命令によって <cite>vl</cite> 値が減少する可能性がありますが、
これが一般的に有用な動作であることは明らかではないため、このケースは留保されています。
また、実装は、マイクロアーキテクチャを最適化するために、この命令によって <cite>vl</cite> が変更されないと仮定することができます。</p>
<p><cite>vsetivli</cite> 命令では、AVLは <cite>rs1</cite> フィールドの
5ビットのゼロ拡張即時値(0～31)としてエンコードされます。</p>
<p>NOTE: <cite>vsetivli</cite> のAVLのエンコーディングは、通常のCSRの即値と同じです。</p>
<p><cite>vsetivli</cite> 命令は、ベクトルサイズが小さく、ベクトルレジスタ内に収まることがわかっているため、
ストリップマイニングのオーバーヘッドが不要な場合に、よりコンパクトなコードを提供します。</p>
</div>
<div class="section" id="id68">
<h3><cite>vl</cite> 設定の制約<a class="headerlink" href="#id68" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><cite>vset{i}vl{i}</cite> 命令は、まず引数の <cite>vtype</cite> にしたがってVLMAXを設定し、
次に以下の制約にしたがって <cite>vl</cite> を設定します。</p>
<p>. <cite>AVL {le} VLMAX</cite> のときは <cite>vl = AVL</cite>
. <cite>AVL W (2 * VLMAX)</cite> のときは <cite>ceil(AVL / ) {le} vl {le} VLMAX</cite>
. <cite>AVL {ge} (2 * VLMAX)</cite> のときは <cite>vl = VLMAX</cite>
. 同一の入力AVLおよびVLMAX値に対して、任意の実装で決定される
. これらの具体的な特性は、事前のルールから導かれます。
.. <cite>AVL = 0</cite> なら <cite>vl = 0</cite>
.. <cite>AVL &gt; 0</cite> なら <cite>vl &gt; 0</cite>
.. <cite>vl {le} VLMAX</cite>
.. <cite>vl {le} AVL</cite>
.. <cite>vl</cite> から読み込んだ値を <cite>vset{i}vl{i}</cite> の AVL 引数として使用すると、<cite>vl</cite> 内の同じ値になります。 ただし、結果として得られる VLMAX が <cite>vl</cite> が読み込まれた時点での VLMAX の値と同じであることが条件です。</p>
<p>[NOTE]
--
<cite>vl</cite> の設定ルールは、<cite>AVL {le} VLMAX</cite> では、レジスタの流出やコンテキストの入れ替えがあっても <cite>vl</cite> の動作を維持できるよう、
十分に厳密に設計されています。しかし、 <cite>AVL &gt; VLMAX</cite> の場合は、ベクトルレーンの使用率を向上させることができる柔軟性を備えています。
例えば、 <cite>VLMAX &lt; AVL &lt; 2*VLMAX</cite> の場合、<cite>vl = ceil(AVL / 2)</cite> と設定することで、ストリップマイニングループの最後の2回の反復に作業を均等に分散させることができます。
要件2は、 <cite>AVL &lt; 2*VLMAX</cite> の場合であっても、リダクションループの最初のストリップミン反復では、
すべての反復の中で最大のベクトル長を使用することを保証する。
これにより、ソフトウェアは、ストリップマイニングループで観測されたベクトル長の実行最大値を明示的に計算する必要がなくなります。
また、要件2では、 <cite>VLMAX &lt; AVL &lt; 2*VLMAX</cite> の場合、vlをVLMAXに設定することができます。</p>
<p>--</p>
<p>[[example-stripmine-sew]]
.. // === Example of stripmining and changes to SEW</p>
</div>
<div class="section" id="sew">
<h3>ストリップマイニングとSEW変更の例<a class="headerlink" href="#sew" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>SEWとLMULの設定を動的に変更することで、1つのループで幅が混在するオペレーションでも高い処理能力を発揮します。
..</p>
<blockquote>
<div><p># Example: Load 16-bit values, widen multiply to 32b, shift 32b result
# right by 3, store 32b values.
# On entry:
#  a0 holds the total number of elements to process
#  a1 holds the address of the source array
#  a2 holds the address of the destination array</p>
<dl>
<dt>loop:</dt><dd><dl class="simple">
<dt>vsetvli a3, a0, e16, m4, ta, ma  # vtype = 16-bit integer vectors;</dt><dd><p># also update a3 with vl (# of elements this iteration)</p>
</dd>
</dl>
<p>vle16.v v4, (a1)        # Get 16b vector
slli t1, a3, 1          # Multiply # elements this iteration by 2 bytes/source element
add a1, a1, t1          # Bump pointer
vwmul.vx v8, v4, x10    # Widening multiply into 32b in &lt;v8--v15&gt;</p>
<p>vsetvli x0, x0, e32, m8, ta, ma  # Operate on 32b values
vsrl.vi v8, v8, 3
vse32.v v8, (a2)        # Store vector of 32b elements
slli t1, a3, 2          # Multiply # elements this iteration by 4 bytes/destination element
add a2, a2, t1          # Bump pointer
sub a0, a0, a3          # Decrement count by vl
bnez a0, loop           # Any more?</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>::</dt><dd><p># 例: 16ビットの値をロードし、32ビットに拡張し乗算を行い、
# 結果の32ビットを3ビット右にシフトし、結果の32ビットをストアする
# プログラムの先頭では:
#  a0は処理を行う全体の要素数を保持している
#  a1はソース配列のアドレスを保持している
#  a2は書き込み配列のアドレスを保持している
loop:</p>
<blockquote>
<div><dl class="simple">
<dt>vsetvli a3, a0, e16, m4, ta, ma  # vtype = 16-bit 整数ベクトル</dt><dd><p># a3をvlに更新する(個のイタレーションにおける要素の個数)</p>
</dd>
</dl>
<p>vle16.v v4, (a1)        # 16ビットのベクトルを取得する
slli t1, a3, 1          # このイタレーションで処理する要素の個数から要素の2バイト数を計算する
add a1, a1, t1          # ポインタを進める
vwmul.vx v8, v4, x10    # v4の値を32ビットに拡張して&lt;v8--v15&gt;に格納する</p>
<p>vsetvli x0, x0, e32, m8, ta, ma  # 32ビット操作に変更する
vsrl.vi v8, v8, 3
vse32.v v8, (a2)        # 32ビットの値をベクトルにストアする
slli t1, a3, 2          # このイタレーションで処理する要素の個数から要素の4バイト数を計算する
add a2, a2, t1          # ポインタを進める
sub a0, a0, a3          # vlだけカウンタを減少させる
bnez a0, loop           # これ以上処理する？</p>
</div></blockquote>
</dd>
</dl>
<p>[[sec-vector-memory]]</p>
</div>
</div>
<div class="section" id="id69">
<h2>ベクトルロード・ストア命令<a class="headerlink" href="#id69" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトルのロードとストアは、ベクトルレジスタとメモリの間で値を移動させます。
ベクトルロードとストアはマスクされ、非アクティブな要素で例外を発生させません。
マスク付きベクトルロード命令は、マスク付きAgnostics (<cite>vtype.vma`=1) が指定されていない限り、
書き込みベクトルレジスタグループの非アクティブな要素を更新しません。
マスク付きベクトルストアは、アクティブなメモリ要素のみを更新します。
すべてのベクトルロードとストアは、ゼロではない `vstart</cite> 値を生成して受け入れることができます。</p>
<div class="section" id="id70">
<h3>ベクトルロードストア命令のエンコーディング<a class="headerlink" href="#id70" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>include::vmem-format.adoc[]</p>
<p>[cols=&quot;4,12&quot;]
<a href="#id71"><span class="problematic" id="id72">|</span></a>===
| フィールド | 説明</p>
<div class="line-block">
<div class="line">rs1[4:0]   | ベースアドレスを保持する x レジスタを指定する</div>
<div class="line">rs2[4:0]   | ストライドを保持する x レジスタを指定する</div>
<div class="line">vs2[4:0]   | アドレスオフセットを保持するための v レジスタを指定する</div>
<div class="line">vs3[4:0]   | ストアデータを保持する v レジスタを指定する</div>
<div class="line">vd[4:0]    | ロードの書き込み v レジスタを指定する</div>
<div class="line">vm         | ベクトルマスキングが有効かどうか (0 = mask enabled, 1 = mask disabled) を指定する</div>
<div class="line">width[2:0] | メモリ要素のサイズを指定しする。FPスカラレジスタとは区別される</div>
<div class="line">mew        | 拡張メモリ要素幅、 &lt;&lt;sec-vector-loadstore-width-encoding&gt;&gt; を参照のこと</div>
<div class="line">mop[1:0]   | メモリアドレッシングモードを指定する</div>
<div class="line">nf[2:0]    | セグメントロードストア命令において、各セグメントのフィールド数を指定する</div>
<div class="line">lumop[4:0]/sumop[4:0] | ユニットストライドの種類を指定するエンコーディングを指定する</div>
</div>
<p><a href="#id73"><span class="problematic" id="id74">|</span></a>===</p>
<p>ベクトルメモリユニットストライドおよびコンスタントストライド操作では、転送するデータのEEWを命令内で直接静的にエンコードすることで、
幅が混在するルーチンでメモリをアクセスする際の <cite>vtype</cite> の変更回数を減らすことができます。
インデックス付き演算では、命令内の明示的なEEWエンコーディングにより、
使用するインデックスのサイズを設定し、SEW/LMULによりデータ幅を指定します。</p>
</div>
<div class="section" id="id75">
<h3>ベクトルロードストアアドレッシングモード<a class="headerlink" href="#id75" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ベクトル拡張は、ユニットストライド、ストライド、インデックス(スキャッター/ギャザー)のアドレッシングモードをサポートしています。
ベクトルのロード/ストアベースレジスタとストライドは、GPRの <cite>x</cite> レジスタから取得されます。</p>
<p>すべてのベクトルアクセスのベースとなる実効アドレスは、
<cite>rs1</cite> で指定された <cite>x</cite> レジスタの内容で与えられます。</p>
<p>ベクトルのユニットストライド演算は、ベース有効アドレスからメモリ内に連続して格納されている要素をアクセスします。</p>
<p>ベクトルの定数ストライド演算では、ベース実効アドレスで最初のメモリ要素をアクセスし、
その後、 <cite>rs2</cite> で指定される <cite>x</cite> レジスタに含まれるバイトオフセットで与えられるアドレス増分で後続の要素をアクセスします。</p>
<p>ベクトルインデックス演算では、 <cite>vs2</cite> で指定されたベクトルオフセットオペランドの各要素の内容をベース実効アドレスに加算し、
各要素の実効アドレスを得ることができます。
データベクトルレジスタ群は、EEW=SEW、EMUL=LMUL、オフセットベクトルレジスタ群は、
命令内でEEW符号化、EMUL=(EEW/SEW)*LMULとなります。</p>
<p>ベクトル・オフセット・オペランドは、バイトアドレス・オフセットのベクトルとして扱われます。</p>
<p>NOTE: インデックス付き演算は、オブジェクトのベクトル内のフィールドをアクセスするためにも使用できます。
この場合、<cite>vs2</cite> ベクトルはオブジェクトのベースへのポインタを保持し、スカラ <cite>x</cite> レジスタは各オブジェクト内のメンバ・フィールドのオフセットを保持します。
このケースをサポートすることが、要素のインデックスをデータEEWでスケーリングするインデックス付き演算が定義されなかった理由です。</p>
<p>ベクトルオフセットの要素がXLENより狭い場合は、ベースの実効アドレスに追加する前にXLENまでゼロ拡張されます。
ベクトルオフセット要素の幅がXLENよりも広い場合は、アドレスの計算に最下位のXLENビットが使用されます。
EEWがオフセット要素に対してサポートされていない場合、実装は不正な命令例外を発生させることができます。</p>
<p>NOTE: プロファイルは、サポートされる最大のインデックスEEWに、ELENよりも小さい上限を設けることができます(例えば、XLENまでのみ)。</p>
<p>ベクトルアドレッシングモードは、2ビットの <cite>mop[1:0]</cite> フィールドを使ってエンコードされます。</p>
<p>.ロード命令のエンコーディング
[cols=&quot;1,1,7,6&quot;]
<a href="#id218"><span class="problematic" id="id219">|===
2+|</span></a> mop [1:0] | 説明 | オペコード</p>
<div class="line-block">
<div class="line">0 | 0 | unit-stride       | VLE&lt;EEW&gt;</div>
<div class="line">0 | 1 | indexed-unordered | VLUXEI&lt;EEW&gt;</div>
<div class="line">1 | 0 | strided           | VLSE&lt;EEW&gt;</div>
<div class="line">1 | 1 | indexed-ordered   | VLOXEI&lt;EEW&gt;</div>
</div>
<p><a href="#id76"><span class="problematic" id="id77">|</span></a>===</p>
<p>.ストア命令のエンコーディング
[cols=&quot;1,1,7,6&quot;]
<a href="#id220"><span class="problematic" id="id221">|===
2+|</span></a> mop [1:0] | 説明 | オペコード</p>
<div class="line-block">
<div class="line">0 | 0 | unit-stride       | VSE&lt;EEW&gt;</div>
<div class="line">0 | 1 | indexed-unordered | VSUXEI&lt;EEW&gt;</div>
<div class="line">1 | 0 | strided           | VSSE&lt;EEW&gt;</div>
<div class="line">1 | 1 | indexed-ordered   | VSOXEI&lt;EEW&gt;</div>
</div>
<p><a href="#id78"><span class="problematic" id="id79">|</span></a>===</p>
<p>ベクトルのユニットストライドおよびコンスタントストライドのメモリアクセスでは、個々の要素のアクセス間の順序付けは保証されません。
ベクトルのインデックス付きロードおよびストアのメモリ操作には、順序付きと非順序付きの2つの形式があります。
indexed-ordered の場合は、メモリアクセス時の要素の順序を保持します。</p>
<p>順序なしの命令(<cite>mop</cite>!=11)では、要素アクセスの順序は保証されません。
強く順序付けられたIO領域へのアクセスの場合、要素のアクセスはどのような順序でも開始できます。</p>
<p>NOTE: 強く順序付けられたIO領域への順序付けられたベクトルアクセスを提供するためには、
順序付けられたインデックス付き命令を使用する必要があります。</p>
<p>精密なベクトル例外を備えた実装では、
インデックス付きの非順序型ストアの例外も精密でなければなりません。</p>
<p>追加のユニットストライドベクトルアドレッシングモードは、
ユニットストライドロード命令およびストア命令のエンコーディングにおいて、
それぞれ5ビットの <cite>lumop</cite> および <cite>sumop</cite> フィールドにエンコードされます。</p>
<p>.lumop
[cols=&quot;1,1,1,1,1,11&quot;]
<a href="#id222"><span class="problematic" id="id223">|===
5+|</span></a> lumop[4:0] | Description</p>
<div class="line-block">
<div class="line">0 | 0 | 0 | 0 | 0 | unit-stride load</div>
<div class="line">0 | 1 | 0 | 0 | 0 | unit-stride, whole register load</div>
<div class="line">0 | 1 | 0 | 1 | 1 | unit-stride, mask load, EEW=8</div>
<div class="line">1 | 0 | 0 | 0 | 0 | unit-stride fault-only-first</div>
<div class="line">x | x | x | x | x | other encodings reserved</div>
</div>
<p><a href="#id80"><span class="problematic" id="id81">|</span></a>===</p>
<p>.sumop
[cols=&quot;1,1,1,1,1,11&quot;]
<a href="#id224"><span class="problematic" id="id225">|===
5+|</span></a> sumop[4:0] | Description</p>
<div class="line-block">
<div class="line">0 | 0 | 0 | 0 | 0 | unit-stride store</div>
<div class="line">0 | 1 | 0 | 0 | 0 | unit-stride, whole register store</div>
<div class="line">0 | 1 | 0 | 1 | 1 | unit-stride, mask store, EEW=8</div>
<div class="line">x | x | x | x | x | other encodings reserved</div>
</div>
<p><a href="#id82"><span class="problematic" id="id83">|</span></a>===</p>
<p><cite>nf[2:0]</cite> フィールドは、各セグメントのフィールドの数をエンコードします。
通常のベクトルロード/ストアでは、 <cite>nf`=0で、各要素の位置でベクトルレジスタグループとメモリーの間で1つの値が移動することを示します。
より大きな値の `nf</cite> フィールドは、後述の &lt;&lt;sec-aos&gt;&gt; 項で説明するように、
セグメント内の複数の連続したフィールドにアクセスするために使用されます。</p>
<p>NOTE: セグメントロード/ストアのための <cite>nf</cite> フィールドは、
アドレスオフセットフィールドのための同じビットの使用に取って代わりました。
セグメントロード/ストアは、メモリとの間でアイテムを移動するためのより強力なプリミティブを追加する一方で、
オフセットは単一のスカラ整数の計算で置き換えることができます。</p>
<p>また、 <cite>nf[2:0]</cite> フィールドは、全体ベクトルレジスタの
ロード/ストア命令で転送する全体ベクトルレジスタの数をエンコードします。</p>
<p>[[sec-vector-loadstore-width-encoding]]</p>
</div>
<div class="section" id="id84">
<h3>ベクトルロードストア幅のエンコーディング<a class="headerlink" href="#id84" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ベクトルのロードとストアは、命令に直接EEWがエンコードされています。
対応するEMULはEMUL = (EEW/SEW)*LMULとして計算されます。
EMULが範囲外(EMUL&gt;8またはEMUL&lt;1/8)になる場合は、命令のエンコーディングは予約されます。
ベクトルレジスタグループには、選択されたEMULに対応する正当なレジスタ指定子がなければならず、
それ以外の命令エンコーディングは予約済みとみなされます。</p>
<p>ベクトルユニットストライドおよび定数ストライドでは、データ値に命令でエンコードされたEEW/EMULを使用し、
ベクトルインデックスロードおよびストアでは、インデックス値に命令でエンコードされたEEW/EMULを使用し、
データ値に <cite>vtype</cite> でエンコードされたSEW/LMULを使用します。</p>
<p>ベクトルのロード・ストアは、標準的なスカラ浮動小数点の
ロード・ストアが明示していない幅の値を使ってエンコードされます。</p>
<p><cite>mew</cite> ビット(<cite>inst[28]</cite>)は、128ビット以上の拡張メモリサイズをエンコードするために使用されることが期待されますが、
これらのエンコードは現時点では _予約_ です。</p>
<p>サポートされているすべてのSEW設定のEEWのベクトルロード/ストアは、実装で提供されなければなりません。
サポートされていないEEW幅のベクトルロード・ストアエンコーディングは予約済みです。</p>
<p>.ベクトルロードストアのアクセス幅エンコーディング
[cols=&quot;5,1,1,1,1,&gt;3,&gt;3,&gt;3,3,2&quot;]
<a href="#id226"><span class="problematic" id="id227">|===
|                  | mew 3+|</span></a> width [2:0] | Mem bits | Data Reg bits | Index bits | Opcodes |</p>
<div class="line-block">
<div class="line">Standard scalar FP   | x |   0 | 0 | 1 |   16| FLEN | -  | FLH/FSH             |</div>
<div class="line">Standard scalar FP   | x |   0 | 1 | 0 |   32| FLEN | -  | FLW/FSW             |</div>
<div class="line">Standard scalar FP   | x |   0 | 1 | 1 |   64| FLEN | -  | FLD/FSD             |</div>
<div class="line">Standard scalar FP   | x |   1 | 0 | 0 |  128| FLEN | -  | FLQ/FSQ             |</div>
<div class="line">Vector 8b element    | 0 |   0 | 0 | 0 |    8|    8 | -  | VLxE8/VSxE8         |</div>
<div class="line">Vector 16b element   | 0 |   1 | 0 | 1 |   16|   16 | -  | VLxE16/VSxE16       |</div>
<div class="line">Vector 32b element   | 0 |   1 | 1 | 0 |   32|   32 | -  | VLxE32/VSxE32       |</div>
<div class="line">Vector 64b element   | 0 |   1 | 1 | 1 |   64|   64 | -  | VLxE64/VSxE64       |</div>
<div class="line">Vector 128b element  | 1 |   0 | 0 | 0 |  128|  128 | -  | VLxE128/VSxE128     | _Reserved_</div>
<div class="line">Vector 256b element  | 1 |   1 | 0 | 1 |  256|  256 | -  | VLxE256/VSxE256     | _Reserved_</div>
<div class="line">Vector 512b element  | 1 |   1 | 1 | 0 |  512|  512 | -  | VLxE512/VSxE512     | _Reserved_</div>
<div class="line">Vector 1024b element | 1 |   1 | 1 | 1 | 1024| 1024 | -  | VLxE1024/VSxE1024   | _Reserved_</div>
<div class="line">Vector 8b index      | 0 |   0 | 0 | 0 | SEW | SEW  |  8 | VLxEI8/VSxEI8       |</div>
<div class="line">Vector 16b index     | 0 |   1 | 0 | 1 | SEW | SEW  | 16 | VLxEI16/VSxEI16     |</div>
<div class="line">Vector 32b index     | 0 |   1 | 1 | 0 | SEW | SEW  | 32 | VLxEI32/VSxEI32     |</div>
<div class="line">Vector 64b index     | 0 |   1 | 1 | 1 | SEW | SEW  | 64 | VLxEI64/VSxEI64     |</div>
</div>
<p><a href="#id85"><span class="problematic" id="id86">|</span></a>===</p>
<p>Mem bits は、メモリにアクセスされる各要素のサイズです。</p>
<p>Data reg bits は、レジスタにアクセスされる各データ要素のサイズです。</p>
<p>Index bits は、レジスタにアクセスされる各インデックスのサイズです。</p>
<p>64b以上のデータおよびインデックスビットのEEWエンコーディングは現在予約済みです。</p>
<p>NOTE: RV128では、データおよびインデックスのEEWが128となります。</p>
</div>
<div class="section" id="id87">
<h3>ベクトルユニットストライド命令<a class="headerlink" href="#id87" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl>
<dt>::</dt><dd><p># ベクトルユニットストライドロードストア命令</p>
<p># vd は書き込みレジスタ, rs1 はベースアドレス, vm はマスクエンコーディング (v0.t or &lt;missing&gt;)
vle8.v    vd, (rs1), vm  #    8-bit ユニットストライドロード
vle16.v   vd, (rs1), vm  #   16-bit ユニットストライドロード
vle32.v   vd, (rs1), vm  #   32-bit ユニットストライドロード
vle64.v   vd, (rs1), vm  #   64-bit ユニットストライドロード
# vle128.v  vd, (rs1), vm  #  128-bit ユニットストライドロード、予約済み
# vle256.v  vd, (rs1), vm  #  256-bit ユニットストライドロード、予約済み
# vle512.v  vd, (rs1), vm  #  512-bit ユニットストライドロード、予約済み
# vle1024.v vd, (rs1), vm  # 1024-bit ユニットストライドロード、予約済み</p>
<p># vs3はストアデータ, rs1はベースアドレス, vmはマスクエンコーディング (v0.t or &lt;missing&gt;)
vse8.v    vs3, (rs1), vm  #    8-bit ユニットストライドストア
vse16.v   vs3, (rs1), vm  #   16-bit ユニットストライドストア
vse32.v   vs3, (rs1), vm  #   32-bit ユニットストライドストア
vse64.v   vs3, (rs1), vm  #   64-bit ユニットストライドストア
# vse128.v  vs3, (rs1), vm  #  128-bit ユニットストライドストア、予約済み
# vse256.v  vs3, (rs1), vm  #  256-bit ユニットストライドストア、予約済み
# vse512.v  vs3, (rs1), vm  #  512-bit ユニットストライドストア、予約済み
# vse1024.v vs3, (rs1), vm  # 1024-bit ユニットストライドストア、予約済み</p>
</dd>
</dl>
<p>マスク値をメモリとの間で転送するために、ユニットストライドのロード/ストアが追加されました。
これは、実効ベクトル長が <code class="docutils literal notranslate"><span class="pre">evl``=ceil(``vl</span></code>/8) (つまりEMUL=1)であることと、
転送先のレジスタが常にテールアグノスティックポリシで書き込まれることを除けば、
マスクなしのバイトロード/ストア(EEW=8)と同じ動作をします。</p>
<dl>
<dt>::</dt><dd><p># ベクトルユニットストライドマスクロード命令
vlm.v vd, (rs1)   #  ceil(vl/8)バイト長だけバイトデータをロードする</p>
<p># ベクトルユニットストライドマスクストア命令
vsm.v vs3, (rs1)  #  ceil(vl/8)バイト長だけバイトデータをストアする</p>
</dd>
</dl>
<p><cite>vlm.v</cite> と <cite>vsm.v</cite> は、<cite>vle8.v</cite> と <cite>vse8.v</cite> と同様に <cite>width[2:0]`=0 でエンコードされますが、
`lumop</cite> と <cite>sumop</cite> のエンコードが異なることで区別されます。
<cite>vlm.v</cite> と <cite>vsm.v</cite> はバイトロードとストアとして動作するので、
これらの命令では <cite>vstart</cite> はバイト単位になります。</p>
<p>NOTE: 以前のアセンブラのニーモニックである <cite>vle1.v</cite> と <cite>vse1.v</cite> は、
これらの命令と他の要素のロード/ストア命令で長さの扱いが異なるため、混乱を招きました。
ソフトウェアの混乱を避けるために、これらの古いアセンブラニーモニックはエイリアスとして残されています。</p>
<p>NOTE: マスクロード/ストアを提供する主な動機は、
データパス間の配線を減らすためにデータを内部で再配置するマシンをサポートすることです。
また、 <cite>vl</cite> を変更する必要がないため、マスクのスピル/フィルのコストを削減することができます。</p>
</div>
<div class="section" id="id88">
<h3>ベクトルストライド命令<a class="headerlink" href="#id88" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl>
<dt>::</dt><dd><p># ベクトルストライドロードストア命令</p>
<p># vdは書き込みレジスタ, rs1はベースレジスタ, rs2はバイトストライド
vlse8.v    vd, (rs1), rs2, vm  #    8-bit ストライドロード命令
vlse16.v   vd, (rs1), rs2, vm  #   16-bit ストライドロード命令
vlse32.v   vd, (rs1), rs2, vm  #   32-bit ストライドロード命令
vlse64.v   vd, (rs1), rs2, vm  #   64-bit ストライドロード命令
# vlse128.v  vd, (rs1), rs2, vm  #  128-bit ストライドロード命令、予約済み
# vlse256.v  vd, (rs1), rs2, vm  #  256-bit ストライドロード命令、予約済み
# vlse512.v  vd, (rs1), rs2, vm  #  512-bit ストライドロード命令、予約済み
# vlse1024.v vd, (rs1), rs2, vm  # 1024-bit ストライドロード命令、予約済み</p>
<p># vs3 store data, rs1 base address, rs2 byte stride
vsse8.v    vs3, (rs1), rs2, vm  #    8-bit ストライドストア命令
vsse16.v   vs3, (rs1), rs2, vm  #   16-bit ストライドストア命令
vsse32.v   vs3, (rs1), rs2, vm  #   32-bit ストライドストア命令
vsse64.v   vs3, (rs1), rs2, vm  #   64-bit ストライドストア命令
# vsse128.v  vs3, (rs1), rs2, vm  #  128-bit ストライドストア命令、予約済み
# vsse256.v  vs3, (rs1), rs2, vm  #  256-bit ストライドストア命令、予約済み
# vsse512.v  vs3, (rs1), rs2, vm  #  512-bit ストライドストア命令、予約済み
# vsse1024.v vs3, (rs1), rs2, vm  # 1024-bit ストライドストア命令、予約済み</p>
</dd>
</dl>
<p>負の数のストライドとゼロストライドに対応しています。</p>
<p>ストライド命令内の要素アクセスは、互いに順序付けられていません。</p>
<p><cite>rs2`=`x0</cite> の場合、実装はアクティブな要素の数よりも少ないメモリ操作を実行することが許されますが、必須ではありません。
また、同じ静的に同じ命令の異なる動的な実行において、異なる数のメモリ操作を実行することができます。</p>
<p>NOTE: すべてのメモリ・アクセスの実行を要求する意図がある場合は、
即時ストライドが <cite>0</cite> のときに rs2 に <cite>x0</cite> 形式を使用しないように、
コンパイラーは注意しなければなりません。</p>
<p><cite>rs2!=x0</cite> で <cite>x[rs2]=0</cite> の場合、実装はアクティブな要素ごとに1回のメモリアクセスを
行わなければなりません(ただし、これらのアクセスは順序付けられません)。</p>
<p>NOTE: 同じメモリアドレスへの順序付きベクトルアクセスを繰り返す必要がある場合は、
順序付きインデックス操作を使用することができます。</p>
</div>
<div class="section" id="id89">
<h3>ベクトルインデックス命令<a class="headerlink" href="#id89" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl>
<dt>::</dt><dd><p># ベクトルインデックスロードストア命令</p>
<p># ベクトル順序無しインデックスロード命令
# vdは書き込みベクトルレジスタ, rs1はベースアドレス, vs2はインデックス
vluxei8.v    vd, (rs1), vs2, vm  # unordered  8-bit SEWデータのインデックスロード命令
vluxei16.v   vd, (rs1), vs2, vm  # unordered 16-bit SEWデータのインデックスロード命令
vluxei32.v   vd, (rs1), vs2, vm  # unordered 32-bit SEWデータのインデックスロード命令
vluxei64.v   vd, (rs1), vs2, vm  # unordered 64-bit SEWデータのインデックスロード命令</p>
<p># ベクトル順序付きインデックスロード命令
# vdは書き込みベクトルレジスタ, rs1はベースアドレス, vs2はインデックス
vloxei8.v    vd, (rs1), vs2, vm  # ordered  8-bit SEWデータのインデックスロード命令
vloxei16.v   vd, (rs1), vs2, vm  # ordered 16-bit SEWデータのインデックスロード命令
vloxei32.v   vd, (rs1), vs2, vm  # ordered 32-bit SEWデータのインデックスロード命令
vloxei64.v   vd, (rs1), vs2, vm  # ordered 64-bit SEWデータのインデックスロード命令</p>
<p># ベクトル順序無しインデックスストア命令
# vs3はストアデータ, rs1はベースアドレス, vs2はインデックス
vsuxei8.v   vs3, (rs1), vs2, vm # unordered  8-bit SEWデータのインデックスストア命令
vsuxei16.v  vs3, (rs1), vs2, vm # unordered 16-bit SEWデータのインデックスストア命令
vsuxei32.v  vs3, (rs1), vs2, vm # unordered 32-bit SEWデータのインデックスストア命令
vsuxei64.v  vs3, (rs1), vs2, vm # unordered 64-bit SEWデータのインデックスストア命令</p>
<p># ベクトル順序付きインデックスストア命令
# vs3はストアデータ, rs1はベースアドレス, vs2はインデックス
vsoxei8.v    vs3, (rs1), vs2, vm  # ordered  8-bit SEWデータのインデックスストア命令
vsoxei16.v   vs3, (rs1), vs2, vm  # ordered 16-bit SEWデータのインデックスストア命令
vsoxei32.v   vs3, (rs1), vs2, vm  # ordered 32-bit SEWデータのインデックスストア命令
vsoxei64.v   vs3, (rs1), vs2, vm  # ordered 64-bit SEWデータのインデックスストア命令</p>
</dd>
</dl>
<p>NOTE: インデックス付きロード/ストアのアセンブラ構文では、
静的にエンコードされたEEWがデータではなくインデックスであることを示すために、
<a href="#id90"><span class="problematic" id="id91">``</span></a>e``__x__ の代わりに <a href="#id92"><span class="problematic" id="id93">``</span></a>ei``__x__ を使用しています。</p>
<p>NOTE: インデックス付き操作のニーモニックには、順序なしと順序付きを区別するための&quot;U&quot;または&quot;O&quot;がありますが、
他のベクトルアドレッシングモードには文字がありません。
この方法は、一貫性に欠けるかもしれませんが、VSXEIが以前は&quot;順序付き&quot;を意味していたように、
既存のソフトウェアの混乱を最小限に抑えることができます。
また、移行中にオペコードを別名として保持することで、ソフトウェアの解約を減らすことができます。</p>
</div>
<div class="section" id="fault-only-first">
<h3>ユニットストライドFault-Only-Firstロード<a class="headerlink" href="#fault-only-first" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ユニットストライドfault-only-first load命令は、データに依存した終了条件を持つループ(&quot;while &quot;ループ)をベクトル化するために使用されます。
これらの命令は、要素0で発生した同期例外による例外のみを取得することを除いて、
通常のロードと同様に実行されます。 要素 &gt; 0 で例外が発生した場合、対応する例外は取られず、
ベクトル長 <cite>vl</cite> は例外が発生したであろう要素のインデックスに縮小されます。</p>
<p>ロード命令は、例外が報告された要素のインデックスを超えて、アクティブな書き込みベクトルレジスタグループの要素を上書きする可能性があります。
同様に、fault-only-firstのロード命令では、書き込みレジスタの要素が、ベクトルの長さを切り詰める原因となる要素を超えて更新されることがあります(ただし、元のベクトルの長さを超えることはありません)。
これらの疑似更新の値は、アドレスされたメモリ位置のメモリ内の値と一致する必要はありません。
非占有のメモリ位置は、対応する要素のロード操作が例外やベクトル長のトリミングによって再起動されないことがわかっている場合にのみアクセスできます。</p>
<dl>
<dt>::</dt><dd><p># ベクトルユニットストライドfault-only-firstロード</p>
<p># vdは書き込みレジスタ, rs1はベースアドレス, vmはマスクエンコーディング (v0.t もしくは&lt;指定なし&gt;)
vle8ff.v    vd, (rs1), vm  #    8-bit ユニットストライドfault-only-firstロード
vle16ff.v   vd, (rs1), vm  #   16-bit ユニットストライドfault-only-firstロード
vle32ff.v   vd, (rs1), vm  #   32-bit ユニットストライドfault-only-firstロード
vle64ff.v   vd, (rs1), vm  #   64-bit ユニットストライドfault-only-firstロード
# vle128ff.v  vd, (rs1), vm  #  128-bit ユニットストライドfault-only-firstロード(予約)
# vle256ff.v  vd, (rs1), vm  #  256-bit ユニットストライドfault-only-firstロード(予約)
# vle512ff.v  vd, (rs1), vm  #  512-bit ユニットストライドfault-only-firstロード(予約)
# vle1024ff.v vd, (rs1), vm  # 1024-bit ユニットストライドfault-only-firstロード(予約)</p>
</dd>
</dl>
<dl>
<dt>::</dt><dd><p>ユニットストライドfault-only-first命令によるstrlenの例</p>
<p>include::example/strlen.s[lines=4..-1]</p>
</dd>
</dl>
<p>NOTE: fault-on-firstのロードは、有効な実効アドレスを調べるために使用される可能性があるため、
セキュリティ上の懸念があります。 ストライドおよびスキャッター/ギャザーのfault-on-firstロード命令は、エンコーディング空間がないため提供されていません。
また、より大きなセキュリティ全体となる可能性があり、ソフトウェアは例外を経験することなく、
複数のランダムなページのアクセス性を簡単にチェックすることができます。
ユニットストライド版では、既知の領域とすぐに隣接する領域のプロービングしかできないため、セキュリティに大きな影響はありません。
将来のベクトル拡張では、非連続アクセスの fault-only-first を可能にするセキュリティ緩和策が実装される可能性があります。</p>
<p>例外が発生しない場合でも、実装では <cite>vl</cite> より少ない要素を処理し、それに応じて <cite>vl</cite> を減らすことが許可されていますが、
<cite>vstart`=0 かつ `vl</cite>&gt;0 の場合は、少なくとも 1 つの要素を処理する必要があります。</p>
<p>fault-on-firstロード命令が割り込みによる例外を発生する場合、
実装は <cite>vl</cite> を削減せず、代わりに <cite>vstart</cite> の値を設定する必要があります。</p>
<p>NOTE: fault-only-first 命令が最初の要素の後にデバッグ・データ・ウォッチポイント・例外をトリガーする場合、
実装は <cite>vl</cite> を減らすのではなく、イベントが失われる可能性があるため、
デバッグ・例外をトリガーするべきです。</p>
<p>[[sec-aos]]
.. // === Vector Load/Store Segment Instructions</p>
</div>
<div class="section" id="id94">
<h3>ベクトルロードストアセグメント命令<a class="headerlink" href="#id94" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>この命令サブセットには、ISAの文字列名 <cite>Zvlsseg</cite> が与えられています。</p>
<p>ベクトルロード/ストアセグメント命令は、メモリ上の複数の連続したフィールドを、
連続した番号のベクトルレジスタとの間で移動します。</p>
<p>NOTE: これらの操作は、構造体の各フィールドを別々のベクトルレジスタにアンパックすることで、
&quot;構造体の配列&quot;データタイプの操作をサポートします。</p>
<p>ベクトル命令の符号化における3ビットの <cite>nf</cite> フィールドは、セグメントごとのフィールド数 _NFIELDS_ よりも1つ少ない符号なし整数です。</p>
<p>[cols=&quot;1,1,1,13&quot;]
<a href="#id228"><span class="problematic" id="id229">|===
3+|</span></a> nf[2:0] | NFIELDS</p>
<div class="line-block">
<div class="line">0 | 0 | 0 | 1</div>
<div class="line">0 | 0 | 1 | 2</div>
<div class="line">0 | 1 | 0 | 3</div>
<div class="line">0 | 1 | 1 | 4</div>
<div class="line">1 | 0 | 0 | 5</div>
<div class="line">1 | 0 | 1 | 6</div>
<div class="line">1 | 1 | 0 | 7</div>
<div class="line">1 | 1 | 1 | 8</div>
</div>
<p><a href="#id95"><span class="problematic" id="id96">|</span></a>===</p>
<p>EMULの設定は、EMUL * NFIELDS {le} 8となるようにしなければならず、
そうでない場合は、命令のエンコーディングは予約されています。</p>
<p>EMUL * NFIELDSは、セグメント化されたロード/ストア命令でタッチされる基本的なベクトルレジスタの数を表しています。
この制約により、この合計はアーキテクチャレジスタファイルの1/4以下となり、EMUL=8の通常の演算と同じになります。</p>
<p>各フィールドは、連続した番号のベクトルレジスタグループに保持されます。
EMUL&gt;1の場合、各フィールドは複数の連続した番号のベクトルレジスタで保持されるベクトルレジスタグループを占有し、
各フィールドのベクトルレジスタグループは通常のベクトルレジスタアライメント制約に従わなければなりません
(例えば、EMUL=2、NFIELDS=4の場合、各フィールドのベクトルレジスタグループは偶数のベクトルレジスタで開始しなければなりませんが、
8の倍数のベクトルレジスタ番号で開始する必要はありません)。</p>
<p>セグメント・ロードまたはストアによってアクセスされるベクトルレジスタ番号が31を超えてインクリメントされる場合、
その命令エンコーディングは予約されています。</p>
<p>NOTE: この制約は、より多くのアドレス可能なベクトルレジスタを持つ、
将来のより長い命令エンコーディングとの前方互換性を確保するためのものです。</p>
<p><cite>vl</cite> レジスタは、移動する構造体の数を示しており、
これは各ベクトルレジスタグループに転送される要素の数と同じです。
マスキングは構造体全体のレベルでも適用されます。</p>
<p>セグメントロードおよびストアでは、各セグメント内のフィールドにアクセスするために使用される個々のメモリアクセスは、
順序付きのインデックス付きのセグメントロードおよびストアであっても、お互いに順序付けられていません。</p>
<p>例外が発生した場合、<cite>vstart</cite> は構造体の単位になります。
構造体へのアクセスの途中で例外が発生した場合、
構造体へのアクセスのサブセットを実行するかどうかは、実装で定義されています。</p>
<div class="section" id="id97">
<h4>ベクトルユニットストライドセグメントロードストア命令<a class="headerlink" href="#id97" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>ベクトルユニットストライドのセグメントロードおよびセグメントストア命令は、
パックされた連続したセグメント(&quot;array-of-structures&quot;)を
複数の書き込みベクトルレジスタグループに移動させます。</p>
<p>NOTE: 異なるサイズのフィールドを持つ構造体の場合、セグメント・ロードでデータをベクトルレジスタに取り込んだ後、
ソフトウェアは追加の命令を使ってセグメントから構造体フィールドをアンパックすることができます。</p>
<p>ユニットストライドのセグメントロードとストアには、
それぞれ <cite>vlseg</cite>/<cite>vsseg</cite> というアセンブラのプレフィックスが使われます。</p>
<dl>
<dt>::</dt><dd><p># フォーマット
vlseg&lt;nf&gt;e&lt;eew&gt;.v vd, (rs1), vm       # ユニットストライドセグメントロードのテンプレート
vsseg&lt;nf&gt;e&lt;eew&gt;.v vs3, (rs1), vm       # ユニットストライドセグメントストア命令のテンプレート</p>
<p># Examples
vlseg8e8.v vd, (rs1), vm   # 1バイトフィールドを8つ持つ要素を8つのベクトルレジスタにロードする</p>
<p>vsseg3e32.v vs3, (rs1), vm  # 3*4バイトセグメントの要素をvs3,vs3+1,vs3+2からメモリにストアする</p>
</dd>
</dl>
<p>ロードの場合、<cite>vd</cite> レジスタはセグメントからロードされる最初のフィールドを保持します。
ストアの場合は、 <cite>vs3</cite> レジスタが読み込まれ、各セグメントに格納される最初のフィールドが提供されます。</p>
<dl>
<dt>::</dt><dd><p># 例1
# パッキングされたRGBピクセル(8bppの24ビットデータ構造)
vsetvli a1, t0, e8, ta, ma
vlseg3e8.v v8, (a0), vm
# v8 は赤ピクセルを持っている
# v9 は緑ピクセルを持っている
# v10 青ピクセルを持っている</p>
<p># 例2
# メモリ構造は複素数を持っている。32ビットの実数と32ビットの虚数を持っている
vsetvli a1, t0, e32, ta, ma
vlseg2e32.v v8, (a0), vm
# v8 は実数を持っている
# v9 虚数を持っている</p>
</dd>
</dl>
<p>ユニットストライド命令については、fault-only-first版も定義されている。</p>
<dl class="simple">
<dt>::</dt><dd><p># ベクトルfault-only-firstユニットストライドセグメントロード命令の例
vlseg&lt;nf&gt;e&lt;eew&gt;ff.v vd, (rs1),  vm          # ユニットストライドfault-only-firstセグメントロード</p>
</dd>
</dl>
<p>fault-only-firstセグメントのロードでは、セグメントへのアクセスの途中で例外が検出された場合、
要素のインデックスがゼロであるかどうかにかかわらず、セグメントのサブセットをロードするかどうかは実装で定義されます。</p>
<p>これらの命令は、例外が報告された時点や、ベクトル長がトリムされた時点を過ぎても、
書き込みベクトルレジスタグループの要素を上書きすることがあります。</p>
</div>
<div class="section" id="id98">
<h4>ベクトルストライドセグメントロードストア命令<a class="headerlink" href="#id98" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>ベクトルのストライドセグメントは、GPRの引数 <cite>rs2</cite> で指定されたバイトストライドの
オフセットで区切られた連続したセグメントを移動してロード、ストアします。</p>
<p>NOTE: 負のストライドとゼロのストライドがサポートされています。</p>
<dl>
<dt>::</dt><dd><p># フォーマット
vlsseg&lt;nf&gt;e&lt;eew&gt;.v vd, (rs1), rs2, vm          # ストライドセグメントロード
vssseg&lt;nf&gt;e&lt;eew&gt;.v vs3, (rs1), rs2, vm         # ストライドセグメントストア</p>
<p># 例
vsetvli a1, t0, e8, ta, ma
vlsseg3e8.v v4, (x5), x6   # アドレスx5+i*x6をv4[i]に格納する</p>
<blockquote>
<div><p>#  x5+i*x6+1をv5[i]に格納する
#  x5+i*x6+2をv6[i]に格納する</p>
</div></blockquote>
<p># 例
vsetvli a1, t0, e32, ta, ma
vssseg2e32.v v2, (x5), x6   # v2[i]のワードをアドレスx5+i*x6にストアする</p>
<blockquote>
<div><p>#   また、v3[i]のワードをx5+i*x6+4にストアする</p>
</div></blockquote>
</dd>
</dl>
<p>各セグメント内のフィールドへのアクセスは、
セグメントがメモリ内で重なるようなバイトストライドの場合も含め、
どのような順序でも行うことができます。</p>
</div>
<div class="section" id="id99">
<h4>ベクトルインデックスセグメントロードストア命令<a class="headerlink" href="#id99" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>各セグメントは、<cite>rs1</cite> フィールドのスカラのベースアドレスと、ベクトルレジスタ <cite>vs2</cite> のバイトオフセットを足したアドレスに位置します。
Index-Ordered形式とIndex-Unordered形式の両方が提供されており、
Index-Ordered形式はセグメントを要素順にアクセスします。
しかし、順序付けられた形式でも、個々のセグメント内のフィールドへのアクセスは、お互いに順序付けられていません。</p>
<p>データベクトルレジスタ群はEEW=SEW、EMUL=LMUL、
インデックスベクトルレジスタ群はEEWがEMUL=(EEW/SEW)*LMULで命令にエンコードされています。</p>
<dl>
<dt>::</dt><dd><p># 例
vluxseg&lt;nf&gt;ei&lt;eew&gt;.v vd, (rs1), vs2, vm   # Indexed-unorderedセグメントロード
vloxseg&lt;nf&gt;ei&lt;eew&gt;.v vd, (rs1), vs2, vm   # Indexed-orderedセグメントロード
vsuxseg&lt;nf&gt;ei&lt;eew&gt;.v vs3, (rs1), vs2, vm  # Indexed-unorderedセグメントストア
vsoxseg&lt;nf&gt;ei&lt;eew&gt;.v vs3, (rs1), vs2, vm  # Indexed-orderedセグメントストア</p>
<p># 例
vsetvli a1, t0, e8, ta, ma
vluxseg3ei32.v v4, (x5), v3   # アドレスx5+v3[i]のバイトデータをv4[i]にロードする</p>
<blockquote>
<div><p>#  アドレスx5+v3[i]+1のバイトデータをv5[i]にロードする
#  アドレスx5+v3[i]+2のバイトデータをv6[i]にロードする</p>
</div></blockquote>
<p># 例
vsetvli a1, t0, e32, ta, ma
vsuxseg2ei32.v v2, (x5), v5   # v2[i]中のワードをアドレスx5+v5[i]にストアする</p>
<blockquote>
<div><p>#   v3[i]中のワードをアドレスx5+v5[i]+4にストアする</p>
</div></blockquote>
</dd>
</dl>
<p>ベクトルインデックスセグメントロードでは、
書き込みベクトルレジスタグループはソースベクトルレジスタグループ(<cite>vs2</cite> で指定)と重なることはできません。</p>
<p>NOTE: この制約は、構造体のロードの途中で例外が発生したインデックス付きセグメント・ロードの再起動をサポートします。</p>
</div>
</div>
<div class="section" id="id100">
<h3>ベクトル全体レジスタロードストア命令<a class="headerlink" href="#id100" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>LOAD-FPメジャーオペコードのベクトルロード全体レジスタ命令のフォーマット</p>
<p><a href="#id101"><span class="problematic" id="id102">``</span></a><a href="#id103"><span class="problematic" id="id104">`</span></a>wavedrom
{reg: [</p>
<blockquote>
<div><p>{bits: 7, name: 0x07, attr: 'VL*R*'},
{bits: 5, name: 'vd', attr: 'destination of load', type: 2},
{bits: 3, name: 'width'},
{bits: 5, name: 'rs1', attr: 'base address', type: 4},
{bits: 5, name: 8, attr: 'lumop'},
{bits: 1, name: 1, attr: 'vm'},
{bits: 2, name: 0x10000, attr: 'mop'},
{bits: 1, name: 'mew'},
{bits: 3, name: 'nf'},</p>
</div></blockquote>
<p><a href="#id105"><span class="problematic" id="id106">``</span></a><a href="#id107"><span class="problematic" id="id108">`</span></a>wavedrom
{reg: [</p>
<blockquote>
<div><p>{bits: 7, name: 0x27, attr: 'VS*R*'},
{bits: 5, name: 'vs3', attr: 'store data', type: 2},
{bits: 3, name: 0x1000},
{bits: 5, name: 'rs1', attr: 'base address', type: 4},
{bits: 5, name: 8, attr: 'sumop'},
{bits: 1, name: 1, attr: 'vm'},
{bits: 2, name: 0x100, attr: 'mop'},
{bits: 1, name: 0x100, attr: 'mew'},
{bits: 3, name: 'nf'},</p>
</div></blockquote>
<p>これらの命令は、ベクトルレジスタグループ全体をロードおよびストアします。</p>
<p>NOTE: これらの命令は、ベクトル・レジスタの現在の内容のタイプや長さがわからない場合や、
<cite>vl</cite> や <cite>vtype</cite> を変更するとコストがかかる場合に、ベクトル・レジスタの保存や復元に使用することを目的としています。
例えば、コンパイラのレジスタ・スピル、ベクトル・レジスタで値が渡されるベクトル関数呼び出し、割り込みハンドラ、OSのコンテキスト・スイッチなどです。
ソフトウェアは、 <cite>vlenb</cite> レジスタを読むことで、転送されたバイト数を知ることができます。</p>
<p>ロード命令では、通常のユニットストライド・ロードのパターンに従って、
<cite>mew</cite> および <cite>width</cite> フィールドにEEWがエンコードされています。</p>
<p>NOTE: レジスタ内ののバイトレイアウトはメモリ内のバイトレイアウトと同じなので、
EEWに関係なく同じデータが出力先のレジスタ群に書き込まれます。
そのため、EEW=8 のバリエーションだけを用意すれば十分でした。
EEWのバリエーションをすべて用意したのは、エンコードされたEEWをヒントにして、
次にこのEEWでアクセスされる書き込みレジスタグループを示すことができるようにするためで、
これは内部的にデータを再配置する実装の助けになります。</p>
<p>ベクトル全体レジスタストア命令は、EEW=8 のマスクされていない
ユニットストライドストアと同様にエンコードされます。</p>
<p>フィールド <cite>nf</cite> は、ロードおよびストアするベクトルレジスタの数をエンコードします。
符号化されたレジスタ数は2の累乗でなければならず、
ベクトルレジスタ番号はベクトルレジスタグループと同様にアラインメントされていなければならず、
そうでなければ命令の符号化は予約されます。
<cite>nf</cite> フィールドは、転送するベクトルレジスタの数をエンコードするもので、
ベースの後に連続して番号が付けられます。
<cite>nf</cite> の値は1、2、4、8のみがサポートされており、その他の値は予約されています。
複数のレジスタを転送する場合、最も低い番号のベクトルレジスタは最も低い番号のメモリアドレスに保持され、
連続したベクトルレジスタ番号はメモリに連続して配置されます。</p>
<p>この命令は、 <cite>vtype</cite> や <cite>vl</cite> の現在の設定にかかわらず、 <cite>evl`=`nf</cite> <a href="#id109"><span class="problematic" id="id110">*</span></a>VLEN/EEWという実効ベクトル長で動作します。
<cite>vstart</cite> {ge} <cite>vl</cite> の場合には要素が書き込まれないという通常の特性は、 <cite>vtype</cite> や <cite>vl</cite> の現在の設定に関係なく動作します。
<cite>vstart</cite> {ge} <cite>vl</cite> の場合には要素が書き込まれないという通常の特性は、
これらの命令には適用されません。
代わりに、<cite>vstart</cite> {ge} <cite>evl</cite> の場合には要素は書き込まれません。</p>
<p>この命令は、要素のマスクされていないユニットストライドロードおよびストア命令と同様に動作し、
ベースアドレスは <cite>rs1</cite> で指定されるスカラ <cite>x</cite> レジスタで渡されます。</p>
<p>実装では、ベースアドレスが、エンコードされたEEWのサイズ(バイト)(EEW/8)と実装でサポートされている
SEWの最小サイズ(バイト)(SEW~MIN~/8)のいずれか大きい方に自然にアラインされていない場合、
レジスタ全体のロードとストアでアドレスのずれの例外を発生させることができます。</p>
<p>NOTE: エンコードされたEEWへの非アラインメントに基づいてミスアラインの例外を発生させることができるため、
これらの命令の実装が簡素化されます。
サブセットの実装によっては、より小さなSEW幅をサポートしていない場合があるため、
エンコードされたEEWよりも大きくても、サポートされている最小のSEWに対してミスアラインド例外を報告することが許可されています。
極端な実装では、例えば SEW~MIN~&gt;XLEN のようになります。
ソフトウェア環境は、ABIをサポートするための最小アラインメント要件を義務付けることができます。</p>
<dl>
<dt>::</dt><dd><p># 全体レジスタロードストア命令のフォーマット
vl1r.v v3, (a0)       # vl1re8.vの疑似命令</p>
<p>vl1re8.v    v3, (a0)  # a0に保持されているアドレスからVLEN/8バイトだけロードしv3に格納する
vl1re16.v   v3, (a0)  # a0に保持されているアドレスからVLEN/16バイトだけロードしv3に格納する
vl1re32.v   v3, (a0)  # a0に保持されているアドレスからVLEN/32バイトだけロードしv3に格納する
vl1re64.v   v3, (a0)  # a0に保持されているアドレスからVLEN/64バイトだけロードしv3に格納する
# vl1re128.v  v3, (a0)
# vl1re256.v  v3, (a0)
# vl1re512.v  v3, (a0)
# vl1re1024.v v3, (a0)</p>
<p>vl2r.v v2, (a0)       # vl2re8.v v2, (a0)の疑似命令</p>
<p>vl2re8.v    v2, (a0)  # a0に保持されているアドレスから2*VLEN/8バイトだけロードしv2-v3に格納する
vl2re16.v   v2, (a0)  # a0に保持されているアドレスから2*VLEN/16バイトだけロードしv2-v3に格納する
vl2re32.v   v2, (a0)  # a0に保持されているアドレスから2*VLEN/32バイトだけロードしv2-v3に格納する
vl2re64.v   v2, (a0)  # a0に保持されているアドレスから2*VLEN/64バイトだけロードしv2-v3に格納する
# vl2re128.v  v2, (a0)
# vl2re256.v  v2, (a0)
# vl2re512.v  v2, (a0)
# vl2re1024.v v2, (a0)</p>
<p>vl4r.v v4, (a0)       # vl4re8.vの疑似命令</p>
<p>vl4re8.v    v4, (a0)  # a0に保持されているアドレスから4*VLEN/8バイトだけロードしv4-v7に格納する
vl4re16.v   v4, (a0)
vl4re32.v   v4, (a0)
vl4re64.v   v4, (a0)
# vl4re128.v  v4, (a0)
# vl4re256.v  v4, (a0)
# vl4re512.v  v4, (a0)
# vl4re1024.v v4, (a0)</p>
<p>vl8r.v v8, (a0)       # vl8re8.vの疑似命令</p>
<p>vl8re8.v    v8, (a0)  # a0に保持されているアドレスから8*VLEN/8バイトだけロードしv8-v15に格納する
vl8re16.v   v8, (a0)
vl8re32.v   v8, (a0)
vl8re64.v   v8, (a0)
# vl8re128.v  v8, (a0)
# vl8re256.v  v8, (a0)
# vl8re512.v  v8, (a0)
# vl8re1024.v v8, (a0)</p>
<p>vs1r.v v3, (a1)      # v3をa1に保持されているアドレスにストアする
vs2r.v v2, (a1)      # v2-v3をa1に保持されているアドレスにストアする
vs4r.v v4, (a1)      # v4-v7をa1に保持されているアドレスにストアする
vs8r.v v8, (a1)      # v8-v15をa1に保持されているアドレスにストアする</p>
</dd>
</dl>
<p>NOTE: サポートされていないEEWの値に対する <cite>vl&lt;nf&gt;r</cite> 命令では、
実装上、不正命令例外を発生させる必要があります。</p>
<p>NOTE: マスクヒントとして、レジスタ全体のマスクロード命令(<code class="docutils literal notranslate"><span class="pre">vl1re1.vd,</span> <span class="pre">(rs1)</span></code>)を追加することを検討しましたが、
これは現在PoRにはありません。</p>
</div>
</div>
<div class="section" id="id111">
<h2>ベクトルメモリアラインメント制約<a class="headerlink" href="#id111" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトルメモリ命令でアクセスした要素のサイズが自然にアラインされていない場合、
その要素は正常に転送されるか、その要素に対してアドレスミスアラインの例外が発生します。</p>
<p>ベクトルメモリアクセスのミスアラインメントのサポートは、
スカラメモリアクセスのミスアラインメントのサポートとは独立しています。</p>
<p>NOTE: 実装によっては、スカラおよびベクトルメモリアクセスのどちらも、あるいは一方が、あるいは両方が、一部またはすべてのミスアラインドアクセスをハードウェアでサポートすることができます。
関連するアドレス範囲でベクトルのミスアラインドアクセスがサポートされているかどうかを判断するために、別のPMAを定義する必要があります。</p>
<p>ベクトルのミスアラインドメモリアクセスは、
スカラのミスアラインドメモリアクセスと同じアトミック性のルールに従います。</p>
</div>
<div class="section" id="id112">
<h2>ベクトルメモリコンシステンシモデル<a class="headerlink" href="#id112" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトルメモリアクセス命令は、ローカルのhartではプログラム順に実行されているように見えます。</p>
<p>ベクトルメモリアクセス命令は、命令レベルではRVWMOに従います。</p>
<p>Index-Ordered形式以外のロード・ストア命令を除き、要素操作は命令内では順不同です。</p>
<p>Index-Ordered形式ロード・ストア命令は、
要素をメモリに読み書きする際に、それぞれ要素順に行います。</p>
<p>NOTE: より正式な定義が必要です。</p>
<p>ベクトル長レジスタ <cite>vl</cite> の影響を受ける命令は、データ依存ではなく、
<cite>vl</cite> への制御依存を持ちます。
同様に、マスクされたベクトル命令は、データ依存ではなく、ソースマスクレジスタへの制御依存を持ちます。</p>
<p>NOTE: ベクトル長とマスクをデータではなく制御として扱うことは、通常、対応するスカラコードのセマンティクスと一致し、
ここでは通常、分岐命令が使用されていました。
マスクを制御として扱うことで、マスクされたベクトルロード命令は、
マスク値が判明する前にメモリにアクセスすることができ、
分岐予測失敗時に回復するメカニズムを必要としません。</p>
</div>
<div class="section" id="id113">
<h2>ベクトル算術演算命令<a class="headerlink" href="#id113" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトル演算命令では、OP-FPに隣接する新しいメジャーオペコード(OP-V = 1010111~2~)を使用します。
3ビットの <cite>funct3</cite> フィールドは、ベクトル命令のサブカテゴリを定義するのに使われます。</p>
<p>include::valu-format.adoc[]</p>
<p>[[sec-arithmetic-encoding]]
.. // === Vector Arithmetic Instruction encoding</p>
<div class="section" id="id114">
<h3>ベクトル算術演算命令エンコーディング<a class="headerlink" href="#id114" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><cite>funct3</cite> フィールによりオペランドのタイプとソース位置をエンコードします。</p>
<p>.funct3
[cols=&quot;1,1,1,3,5,5&quot;]
<a href="#id230"><span class="problematic" id="id231">|===
3+|</span></a> funct3[2:0] | カテゴリ | オペランド | スカラオペランドの型</p>
<div class="line-block">
<div class="line">0 | 0 | 0 | OPIVV | ベクトル-ベクトル  |       N/A</div>
<div class="line">0 | 0 | 1 | OPFVV | ベクトル-ベクトル  |       N/A</div>
<div class="line">0 | 1 | 0 | OPMVV | ベクトル-ベクトル  |       N/A</div>
<div class="line">0 | 1 | 1 | OPIVI | ベクトル-即値      | <cite>imm[4:0]</cite></div>
<div class="line">1 | 0 | 0 | OPIVX | ベクトル-スカラ    | GPR <cite>x</cite> レジスタ <cite>rs1</cite></div>
<div class="line">1 | 0 | 1 | OPFVF | ベクトル-スカラ    | FP <cite>f</cite> レジスタ <cite>rs1</cite></div>
<div class="line">1 | 1 | 0 | OPMVX | ベクトル-スカラ    | GPR <cite>x</cite> レジスタ <cite>rs1</cite></div>
<div class="line">1 | 1 | 1 | OPCFG | スカラ-即値        | GPR <cite>x</cite> レジスタ <cite>rs1</cite> &amp; <cite>rs2</cite>/<cite>imm</cite></div>
</div>
<p><a href="#id115"><span class="problematic" id="id116">|</span></a>===</p>
<p>整数演算は、オペコードに応じて符号なしまたは2の補数の符号付き整数演算で行われます。</p>
<p>NOTE: ここでは、固定小数点演算を整数演算とみなします。</p>
<p>すべての標準ベクトル浮動小数点演算は、IEEE-754/2008 規格に準拠しています。
すべてのベクトル浮動小数点演算は、<cite>frm</cite> レジスタのダイナミック丸めモードを使用します。
丸めモードに依存しない命令であっても、ベクトル浮動小数点演算命令で無効な丸めモードが含まれている場合や、
<cite>vl`=0 の場合、または `vstart</cite> {ge} <cite>vl</cite> の場合の <cite>frm</cite> フィールドの使用は予約されています。</p>
<p>NOTE: すべてのベクトル浮動小数点コードは、<cite>frm</cite> に有効な値があるかどうかに依存します。
実装では、制御ロジックを単純化するために、丸めモードが無効なときにすべてのベクトルFP命令が例外を報告するようにすることができます。</p>
<p>ベクトル演算は、<cite>vs2</cite> と <cite>vs1</cite> でそれぞれ指定されたベクトルレジスタグループから、
オペランドの2つのベクトルを取ります。</p>
<p>ベクトル・スカラ演算には3つの形式がありますが、いずれの場合も、
<cite>vs2</cite> で指定されたベクトルレジスタ群から1つのベクトルのオペランドを取り、
3つの代替ソースのうちの1つから2つ目のスカラソースのオペランドを取ります。</p>
<p>. 整数演算の場合、スカラは <cite>rs1</cite> フィールドでエンコードされた5ビットの即値になります。
この値は、特に指定がない限り、SEWビットに符号拡張されます。
. 整数演算では、スカラは <cite>rs1</cite> で指定されたスカラ <cite>x</cite> レジスタから取ることができます。
XLEN&gt;SEWの場合、特に指定がない限り、<cite>x</cite> レジスタの最下位SEWビットが使用されます。
XLEN&lt;SEWの場合、<cite>x</cite> レジスタからの値はSEWビットに符号拡張されます。
浮動小数点演算の場合、スカラはスカラ <cite>f</cite> レジスタから取得できます。
FLEN &gt; SEWの場合、 <cite>f</cite> レジスタの値が有効なNaNボックス値であるかどうかがチェックされ、
その場合は <cite>f</cite> レジスタの最下位SEWビットが使用され、そうでない場合は正規のNaN値が使用されます。
浮動小数点ベクトルオペランドのEEWがサポートされていない浮動小数点型の幅であるベクトル命令(FLEN &lt; SEWの場合を含む)は予約されています。</p>
<p>NOTE: 一部の命令では、5ビット即値をゼロ拡張し、アセンブリ構文で即値を <cite>uimm</cite> と命名してこれを示します。</p>
<p>NOTE: 提案されているZfinxのバリエーションは、<cite>x</cite> レジスタから浮動小数点のスカラ引数を取ります。</p>
<p>ベクトル演算命令は、<cite>vm</cite> フィールドの制御下でマスクされます。</p>
<dl>
<dt>::</dt><dd><p># ベクトル2項算術演算命令のアセンブリ構文パタン</p>
<p># ベクトル演算の結果はvm(v0.t, &lt;指定なし&gt;)によりマスクされる
vop.vv  vd, vs2, vs1, vm  # 整数 ベクトル-ベクトル vd[i] = vs2[i] op vs1[i]
vop.vx  vd, vs2, rs1, vm  # 整数 ベクトル-スカラ   vd[i] = vs2[i] op x[rs1]
vop.vi  vd, vs2, imm, vm  # 整数 ベクトル-即値     vd[i] = vs2[i] op imm</p>
<p>vfop.vv  vd, vs2, vs1, vm # 浮動小数点 ベクトル-ベクトル 演算 vd[i] = vs2[i] fop vs1[i]
vfop.vf  vd, vs2, rs1, vm # 浮動小数点 ベクトル-スカラ 演算   vd[i] = vs2[i] fop f[rs1]</p>
</dd>
</dl>
<p>NOTE: このエンコーディングでは、<cite>vs2</cite> が第1オペランドで、<cite>rs1/imm</cite> が第2オペランドです。
これは、標準的なスカラの順序とは逆です。
この配列は、1つのスカラレジスタのみを読み出す命令は <cite>rs1</cite> から読み出すという既存のエンコーディング規約を維持し、
5ビットの即値は <cite>rs1</cite> フィールドから供給されます。</p>
<dl>
<dt>::</dt><dd><p># ベクトル3項算術演算命令(multiply-add)のアセンブリ構文パタン</p>
<p># 加算入力値を上書きする整数演算
vop.vv vd, vs1, vs2, vm  # vd[i] = vs1[i] * vs2[i] + vd[i]
vop.vx vd, rs1, vs2, vm  # vd[i] = x[rs1] * vs2[i] + vd[i]</p>
<p># 乗算入力値を上書きする整数演算
vop.vv vd, vs1, vs2, vm  # vd[i] = vs1[i] * vd[i] + vs2[i]
vop.vx vd, rs1, vs2, vm  # vd[i] = x[rs1] * vd[i] + vs2[i]</p>
<p># 加算入力値を上書きする浮動小数点演算
vfop.vv vd, vs1, vs2, vm  # vd[i] = vs1[i] * vs2[i] + vd[i]
vfop.vf vd, rs1, vs2, vm  # vd[i] = f[rs1] * vs2[i] + vd[i]</p>
<p># 乗算入力値を上書きする浮動小数点演算
vfop.vv vd, vs1, vs2, vm  # vd[i] = vs1[i] * vd[i] + vs2[i]
vfop.vf vd, rs1, vs2, vm  # vd[i] = f[rs1] * vd[i] + vs2[i]</p>
</dd>
</dl>
<p>NOTE: 三項乗算加算演算では、アセンブラの構文において常に書き込みベクトルレジスタが最初に置かれ、
次に <cite>rs1</cite> または <cite>vs1</cite> 、そして <cite>vs2</cite> の順になります。
この順序では、乗算オペランドが常に隣り合っているため、
これらの三項演算のアセンブラをより自然に読むことができます。</p>
<p>[[sec-widening]]
.. // === Widening Vector Arithmetic Instructions</p>
</div>
<div class="section" id="id117">
<h3>幅拡張ベクトル算術演算命令<a class="headerlink" href="#id117" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>いくつかのベクトル演算命令は、書き込みベクトルレジスタグループがEEW=2*SEWおよびEMUL=2*LMULを持つ__幅拡張__ 演算が定義されています。</p>
<p>第1ベクトルレジスタグループのオペランドは、単一幅または二倍幅のいずれかです。
これらは通常、オペコードの前に <cite>vw*</cite> というプレフィックスを付けて記述され、
ベクトル浮動小数点演算の場合は <cite>vfw*</cite> となります。</p>
<dl>
<dt>::</dt><dd><p>ベクトル幅拡張算術演算命令のアセンブリ構文パタン</p>
<p># 2つの1倍幅ソースで2倍幅の結果: 2*SEW = SEW op SEW
vwop.vv  vd, vs2, vs1, vm  # 整数 vector-vector      vd[i] = vs2[i] op vs1[i]
vwop.vx  vd, vs2, rs1, vm  # 整数 vector-scalar      vd[i] = vs2[i] op x[rs1]</p>
<p># 1番目のソースオペランドが2倍幅, 2番目のソースオペランドが1倍幅, 結果が2倍幅: 2*SEW = SEW op SEW
vwop.wv  vd, vs2, vs1, vm  # 整数 vector-vector      vd[i] = vs2[i] op vs1[i]
vwop.wx  vd, vs2, rs1, vm  # 整数 vector-scalar      vd[i] = vs2[i] op x[rs1]</p>
</dd>
</dl>
<p>NOTE: 元々、オペコードには <cite>w</cite> という接尾語が使われていましたが、
2倍幅整数のワードサイズの演算を意味する <cite>w</cite> という接尾語と混同される恐れがあったため、 <cite>w</cite> はプレフィックスに移されました。</p>
<p>NOTE: 浮動小数点の拡大演算は、<cite>fw*</cite> と書かれるスカラ拡大浮動小数点演算との整合性をとるために、
<cite>vwf*</cite> から <cite>vfw*</cite> に変更されました。</p>
<p>NOTE: 整数の乗算加算では、アキュムレータのサイズを EEW=4*SEW (すなわち、4*SEW += SEW*SEW) に増やすという別の幅拡張オプションが考えられます。
これらは4倍にするために、オペコードの前に <cite>vq*</cite> という接頭語を付けることで区別されます。
これらは、現時点では含まれていませんが、将来の拡張で追加される可能性があります。</p>
<p>すべての幅拡張命令において、書き込みのEEWおよびEMULの値はサポートされているコンフィギュレーションでなければならず、
そうでない場合は命令のエンコーディングは予約されています。</p>
<p>書き込みベクトルレジスタグループは、書き込みのEMULに有効なベクトルレジスタ番号を使って指定しなければならず、
そうでない場合は命令エンコーディングは予約されます。</p>
<p>NOTE: この制約は、非ゼロの <cite>vstart</cite> による再起動をサポートするために必要です。</p>
<p>NOTE: <cite>vw&lt;op&gt;.wv vd, vs2, vs1</cite> 形式の命令では、vd が vs2 に等しくても許されます。</p>
<p>[[sec-narrowing]]
.. // === Narrowing Vector Arithmetic Instructions</p>
</div>
<div class="section" id="id118">
<h3>ベクトル幅縮小算術演算命令<a class="headerlink" href="#id118" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>2 倍幅のソースベクトルを 1 倍幅の書き込みベクトルに変換する命令がいくつか用意されています。
これらの命令は、EEW/EMUL=2*SEW/2*LMULのベクトルレジスタグループを、
現在のSEW/LMUL設定のベクトルレジスタグループに変換します。</p>
<p>EEW &gt; ELENまたはEMUL &gt; 8の場合、命令のエンコーディングは予約されています。</p>
<p>NOTE: 別の設計上の候補は、SEW/LMULをソースベクトルレジスタグループのサイズを定義するものとして扱うことでした。
ここでの選択は、選択されたアプローチがより少ない <cite>vtype</cite> の変更を必要とするという信念に基づいています。</p>
<p>ソースおよび書き込みベクトルレジスタグループは、ソースおよび書き込みのEMUL値に対してそれぞれ正当な
ベクトルレジスタ番号で指定されなければならず、そうでなければ命令エンコーディングは予約されます。</p>
<p>第2のソースベクトルレジスタグループ(<cite>vs1</cite> で指定)がある場合、
これは結果と同じ(より狭い)幅を持ちます(すなわち、EEW=SEW)。</p>
<p>NOTE: 結果と同じEEWとEMULを持つ第2のソースベクトルレジスタ群を上書きしても安全です。</p>
<p>アセンブラでこれらの命令を区別するためにオペコードに <cite>vn*</cite> というプレフィックスをつけたり、
浮動小数点オペコードを絞り込むために <cite>vfn*</cite> というプレフィックスをつけたりします。
2倍幅ソースベクトルレジスタグループは、
ソースオペランドのサフィックスに <cite>w</cite> を付けて表します(例: <cite>vnsra.wv</cite>)。</p>
<p>NOTE: マスク・レジスタを設定する比較演算も、暗黙のうちに幅縮小演算となります。</p>
<p>[[sec-vector-integer]]
.. // == Vector Integer Arithmetic Instructions</p>
</div>
</div>
<div class="section" id="id119">
<h2>ベクトル整数算術演算命令<a class="headerlink" href="#id119" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>整数ベクトル算術演算命令が提供されています。</p>
<div class="section" id="id120">
<h3>ベクトル単一幅整数加算減算命令<a class="headerlink" href="#id120" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ベクトル整数加減算命令が提供されています。
ベクトル・スカラ形式においては逆減算命令も提供されています。</p>
<dl>
<dt>::</dt><dd><p># 整数加算
vadd.vv vd, vs2, vs1, vm   # ベクトル-ベクトル
vadd.vx vd, vs2, rs1, vm   # ベクトル-スカラ
vadd.vi vd, vs2, imm, vm   # ベクトル-即値</p>
<p># 整数減算
vsub.vv vd, vs2, vs1, vm   # ベクトル-ベクトル
vsub.vx vd, vs2, rs1, vm   # ベクトル-スカラ</p>
<p># 整数逆減算
vrsub.vx vd, vs2, rs1, vm   # vd[i] = x[rs1] - vs2[i]
vrsub.vi vd, vs2, imm, vm   # vd[i] = imm - vs2[i]</p>
</dd>
</dl>
<p>ベクトル内の整数値は、<cite>x0</cite> とのスカラ逆減算によって符号を反転することができます。
これは <cite>vneg vd,vs</cite> = <cite>vrsub.vx vd,vs,x0</cite> としてアセンブリ疑似命令を定義することができます。</p>
</div>
<div class="section" id="id121">
<h3>ベクトル幅拡張整数加減算命令<a class="headerlink" href="#id121" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>符号付きと符号なしの両方で、幅拡張加減算命令が定義されています。
これらは幅の小さいオペランドが最初に符号拡張かゼロ拡張され、
倍幅での加減算が行われます。</p>
<dl>
<dt>::</dt><dd><p># 符号なし整数の幅拡張加減算命令, 2*SEW = SEW +/- SEW
vwaddu.vv  vd, vs2, vs1, vm  # vector-vector
vwaddu.vx  vd, vs2, rs1, vm  # vector-scalar
vwsubu.vv  vd, vs2, vs1, vm  # vector-vector
vwsubu.vx  vd, vs2, rs1, vm  # vector-scalar</p>
<p># 符号付き整数の幅拡張加減算命令, 2*SEW = SEW +/- SEW
vwadd.vv  vd, vs2, vs1, vm  # vector-vector
vwadd.vx  vd, vs2, rs1, vm  # vector-scalar
vwsub.vv  vd, vs2, vs1, vm  # vector-vector
vwsub.vx  vd, vs2, rs1, vm  # vector-scalar</p>
<p># 符号なし整数の幅拡張加減算命令, 2*SEW = 2*SEW +/- SEW
vwaddu.wv  vd, vs2, vs1, vm  # vector-vector
vwaddu.wx  vd, vs2, rs1, vm  # vector-scalar
vwsubu.wv  vd, vs2, vs1, vm  # vector-vector
vwsubu.wx  vd, vs2, rs1, vm  # vector-scalar</p>
<p># 符号付き整数の幅拡張加減算命令, 2*SEW = 2*SEW +/- SEW
vwadd.wv  vd, vs2, vs1, vm  # vector-vector
vwadd.wx  vd, vs2, rs1, vm  # vector-scalar
vwsub.wv  vd, vs2, vs1, vm  # vector-vector
vwsub.wx  vd, vs2, rs1, vm  # vector-scalar</p>
</dd>
</dl>
<p>NOTE: スカラオペランド <cite>x0</cite> との幅拡張加算命令を使用することにより整数値の幅を2倍に拡張することができます。
<cite>vwcvt.x.x.v vd,vs,vm = vwadd.vx vd,vs,x0,vm</cite> と <cite>vwcvtu.x.x.v vd,vs,vm = vwaddu.vx vd,vs,x0,vm</cite> により
疑似アセンブリ命令を定義することができます。</p>
</div>
<div class="section" id="id122">
<h3>ベクトル整数拡張<a class="headerlink" href="#id122" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ゼロ拡張と符号拡張のベクトル整数拡張命令は、SEWよりも小さいEEWの整数オペランドを
SEWの幅まで拡張して書き込みレジスタに転送します。
ソースのEEWはSEWの1/2, 1/4, 1/8であり、ソースのEMULは(EEW/SEW)*LMULです。
書き込み側のEEWはSEWと同一であり、EMULはLMULと同一です。</p>
<dl class="simple">
<dt>::</dt><dd><p>vzext.vf2 vd, vs2, vm  # SEW/2のソースオペランドをゼロ拡張してSEW幅化し書き込む
vsext.vf2 vd, vs2, vm  # SEW/2のソースオペランドを符号拡張してSEW幅化し書き込む
vzext.vf4 vd, vs2, vm  # SEW/4のソースオペランドをゼロ拡張してSEW幅化し書き込む
vsext.vf4 vd, vs2, vm  # SEW/4のソースオペランドを符号拡張してSEW幅化し書き込む
vzext.vf8 vd, vs2, vm  # SEW/8のソースオペランドをゼロ拡張してSEW幅化し書き込む
vsext.vf8 vd, vs2, vm  # SEW/8のソースオペランドを符号拡張してSEW幅化し書き込む</p>
</dd>
</dl>
<p>ソースのEEWがサポートされていない場合もしくはEMULがLMULの最小値よりも小さい場合、
命令エンコーディングは予約されています。</p>
</div>
<div class="section" id="id123">
<h3>ベクトル整数 キャリー付き加算 / ボロー付き減算命令<a class="headerlink" href="#id123" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>複数ワードの整数演算をサポートするために、キャリービットを操作する命令が用意されています。
各演算(加算または減算)には2つの命令が用意されています。
1つは演算結果(SEW幅)を提供し、
もう1つはキャリー出力(マスク・ブールとしてエンコードされた1ビット)を生成します。</p>
<p>キャリー入出力は、 &lt;sec-mask-register-layout&gt; 節で説明したマスクレジスタのレイアウトを用いて表現されます。
エンコーディングの制約により、キャリー入力は暗黙の <cite>v0</cite> レジスタから出力されなければなりませんが、
キャリー出力はソース/書き込みのオーバーラップの制約を満たす任意のベクトルレジスタに書き込むことができます。</p>
<p><cite>vadc</cite> と <cite>vsbc</cite> は、ソースオペランドとキャリーインまたはボローインの加算または減算を行い、
その結果をベクトルレジスタ <cite>vd</cite> に書き込みます。
これらの命令は、マスクされた命令 (<cite>vm=0</cite>) としてエンコードされていますが、すべてのボディ要素を操作し、書き戻します。
マスクされていないバージョン(<cite>vm=1</cite>)に対応するエンコーディングは予約されています。</p>
<p><cite>vvmadc</cite> と <cite>vmsbc</cite> は、ソースオペランドを加算または減算し、マスクされている (<cite>vm=0</cite>) 場合にはオプションでキャリーインを加算またはボローインを減算し、
その結果をマスクレジスタ <cite>vd</cite> に書き戻します。
マスクされていない場合 (<cite>vm=1</cite>)、キャリーインやボローインはありません。
これらの命令は、マスクされていても、すべてのボディ要素を操作し、書き戻します。
これらの命令はマスク値を生成するため、常に末尾Agnosticポリシで動作します。</p>
<dl>
<dt>::</dt><dd><p># キャリー付き加算命令</p>
<p># vd[i] = vs2[i] + vs1[i] + v0.mask[i]
vadc.vvm   vd, vs2, vs1, v0  # ベクトル-ベクトル</p>
<p># vd[i] = vs2[i] + x[rs1] + v0.mask[i]
vadc.vxm   vd, vs2, rs1, v0  # ベクトル-スカラ</p>
<p># vd[i] = vs2[i] + imm + v0.mask[i]
vadc.vim   vd, vs2, imm, v0  # ベクトル-即値</p>
<p># マスクレジスタフォーマットにキャリーアウトを生成する</p>
<p># vd.mask[i] = carry_out(vs2[i] + vs1[i] + v0.mask[i])
vmadc.vvm   vd, vs2, vs1, v0  # ベクトル-ベクトル</p>
<p># vd.mask[i] = carry_out(vs2[i] + x[rs1] + v0.mask[i])
vmadc.vxm   vd, vs2, rs1, v0  # ベクトル-スカラ</p>
<p># vd.mask[i] = carry_out(vs2[i] + imm + v0.mask[i])
vmadc.vim   vd, vs2, imm, v0  # ベクトル-即値</p>
<p># vd.mask[i] = carry_out(vs2[i] + vs1[i])
vmadc.vv    vd, vs2, vs1      # ベクトル-ベクトル, no carry-in</p>
<p># vd.mask[i] = carry_out(vs2[i] + x[rs1])
vmadc.vx    vd, vs2, rs1      # ベクトル-スカラ, no carry-in</p>
<p># vd.mask[i] = carry_out(vs2[i] + imm)
vmadc.vi    vd, vs2, imm      # ベクトル-即値, no carry-in</p>
</dd>
</dl>
<p>キャリー伝搬を実装するには、入力が変更されていない状態で2つの命令を実行する必要があるため、
破壊的な蓄積を行うと、正しい結果を得るために追加の移動が必要になります。</p>
<dl class="simple">
<dt>::</dt><dd><p># v4に値を蓄積する複数ワード算術演算命令列
vmadc.vvm v1, v4, v8, v0  # 一時レジスタv1にキャリーを格納する
vadc.vvm v4, v4, v8, v0   # 加算を行う
vmmv.m v0, v1             # 次のワードのために一時キャリーをv0に移動する</p>
</dd>
</dl>
<p>ボロー付き減算命令 <cite>vsbc</cite> は、減算のためのロングワード演算をサポートするための機能を果たします。
即値での減算命令はありません。</p>
<dl>
<dt>::</dt><dd><p># ボロー付きの差分を計算する</p>
<p># vd[i] = vs2[i] - vs1[i] - v0.mask[i]
vsbc.vvm   vd, vs2, vs1, v0  # Vector-vector</p>
<p># vd[i] = vs2[i] - x[rs1] - v0.mask[i]
vsbc.vxm   vd, vs2, rs1, v0  # Vector-scalar</p>
<p># マスクレジスタフォーマットでボロー出力を生成する</p>
<p># vd.mask[i] = borrow_out(vs2[i] - vs1[i] - v0.mask[i])
vmsbc.vvm   vd, vs2, vs1, v0  # Vector-vector</p>
<p># vd.mask[i] = borrow_out(vs2[i] - x[rs1] - v0.mask[i])
vmsbc.vxm   vd, vs2, rs1, v0  # Vector-scalar</p>
<p># vd.mask[i] = borrow_out(vs2[i] - vs1[i])
vmsbc.vv    vd, vs2, vs1      # Vector-vector, no borrow-in</p>
<p># vd.mask[i] = borrow_out(vs2[i] - x[rs1])
vmsbc.vx    vd, vs2, rs1      # Vector-scalar, no borrow-in</p>
</dd>
</dl>
<p><cite>vmsbc</cite> では、切り捨て前の差が負であるときに限りボローは1と定義される。</p>
<p><cite>vadc</cite> と <cite>vsbc</cite> では書き込みベクトルレジスタが <cite>v0</cite> の場合、命令エンコーディングが予約されます。</p>
<p>NOTE: この制約は、マスクレジスタを上書きするマスク付きベクトル演算の制約に相当します。</p>
</div>
<div class="section" id="id124">
<h3>ベクトル論理命令<a class="headerlink" href="#id124" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl>
<dt>::</dt><dd><p># 論理命令
vand.vv vd, vs2, vs1, vm   # ベクトル-ベクトル
vand.vx vd, vs2, rs1, vm   # ベクトル-スカラ
vand.vi vd, vs2, imm, vm   # ベクトル-即値</p>
<p>vor.vv vd, vs2, vs1, vm    # ベクトル-ベクトル
vor.vx vd, vs2, rs1, vm    # ベクトル-スカラ
vor.vi vd, vs2, imm, vm    # ベクトル-即値</p>
<p>vxor.vv vd, vs2, vs1, vm    # ベクトル-ベクトル
vxor.vx vd, vs2, rs1, vm    # ベクトル-スカラ
vxor.vi vd, vs2, imm, vm    # ベクトル-即値</p>
</dd>
</dl>
<p>NOTE: 即値が-1の場合、スカラ即値形式の <cite>vxor</cite> 命令は、ビットごとのNOT演算を行います。
これは、アセンブラの疑似命令 <cite>vnot.v</cite> として提供することができます。</p>
</div>
<div class="section" id="id125">
<h3>ベクトル単一幅ビットシフト命令<a class="headerlink" href="#id125" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>左への論理シフト、右への論理(ゼロ拡張)および算術(符号拡張)シフトを含む、完全なベクトルシフト命令が用意されています。
シフトするデータは、 <cite>vs2</cite> で指定されたベクトルレジスタグループにあり、シフト量はベクトルレジスタグループ <cite>vs1</cite> 、スカラ整数レジスタ <cite>rs1</cite> 、または即値となります。
ベクトルまたはスカラのシフト量の値の下位lg2(SEW)ビットが使用され、シフト量の即値はゼロ拡張されます。</p>
<dl>
<dt>::</dt><dd><p># ビットシフト操作
vsll.vv vd, vs2, vs1, vm   # ベクトル-ベクトル
vsll.vx vd, vs2, rs1, vm   # ベクトル-スカラ
vsll.vi vd, vs2, uimm, vm   # ベクトル-即値</p>
<p>vsrl.vv vd, vs2, vs1, vm   # ベクトル-ベクトル
vsrl.vx vd, vs2, rs1, vm   # ベクトル-スカラ
vsrl.vi vd, vs2, uimm, vm   # ベクトル-即値</p>
<p>vsra.vv vd, vs2, vs1, vm   # ベクトル-ベクトル
vsra.vx vd, vs2, rs1, vm   # ベクトル-スカラ
vsra.vi vd, vs2, uimm, vm   # ベクトル-即値</p>
</dd>
</dl>
</div>
<div class="section" id="id126">
<h3>ベクトルサイズ幅縮退整数右シフト命令<a class="headerlink" href="#id126" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>サイズ幅縮退の右シフトは、広いオペランドからより小さいフィールドを取り出すもので、ゼロ拡張(<cite>srl</cite>)と符号拡張(<cite>sra</cite>)の両方の形式があります。
シフト量は、ベクトル、スカラの <cite>x</cite> レジスタ、または5ビットの即値から得られます。
ベクトルまたはスカラのシフト量の下位lg2(2*SEW)ビットが使用されます(例えば、SEW=64ビットからSEW=32ビットへの狭帯域化の場合は下位6ビット)。
即値形式は、シフト量の即値オペランドをゼロ拡張します。</p>
<dl>
<dt>::</dt><dd><p># Narrowing shift right logical, SEW = (2*SEW) &gt;&gt; SEW
# ビット幅縮退論理右シフト命令, SEW = (2*SEW) &gt;&gt; SEW
vnsrl.wv vd, vs2, vs1, vm   # vector-vector
vnsrl.wx vd, vs2, rs1, vm   # vector-scalar
vnsrl.wi vd, vs2, uimm, vm   # vector-immediate</p>
<p># Narrowing shift right arithmetic, SEW = (2*SEW) &gt;&gt; SEW
# ビット幅縮退算術右シフト命令, SEW = (2*SEW) &gt;&gt; SEW
vnsra.wv vd, vs2, vs1, vm   # vector-vector
vnsra.wx vd, vs2, rs1, vm   # vector-scalar
vnsra.wi vd, vs2, uimm, vm   # vector-immediate</p>
</dd>
</dl>
<p>NOTE: 書き込みレジスタがソースの1/4の幅である、<cite>n4</cite> バリアントのサポートを追加すると便利です。</p>
<p>NOTE: 整数値は、x0のスカラオペランドを持つ幅縮退の整数シフト命令を使って、幅を半分にすることができます。
アセンブリ疑似命令 <cite>vncvt.x.x.w vd,vs,vm</cite> = <cite>vnsrl.wx vd,vs,x0,vm</cite> を定義することができます。</p>
</div>
<div class="section" id="id127">
<h3>ベクトル整数比較命令<a class="headerlink" href="#id127" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下の整数比較命令は、比較の結果が真であれば書き込みマスクレジスタの要素に1を、そうでなければ0を書き込みます。
書き込みマスクベクトルは常に単一のベクトルレジスタに保持され、その要素のレイアウトはセクション &lt;&lt;sec-mask-register-layout&gt;&gt; で説明されています。
書き込みマスクレジスタは、ソースベクトルのマスクレジスタ(<cite>v0</cite>)と同じものでも構いません。</p>
<dl>
<dt>::</dt><dd><p># Set if equal
vmseq.vv vd, vs2, vs1, vm  # ベクトル-ベクトル
vmseq.vx vd, vs2, rs1, vm  # ベクトル-スカラ
vmseq.vi vd, vs2, imm, vm  # ベクトル-即値</p>
<p># Set if not equal
vmsne.vv vd, vs2, vs1, vm  # ベクトル-ベクトル
vmsne.vx vd, vs2, rs1, vm  # ベクトル-スカラ
vmsne.vi vd, vs2, imm, vm  # ベクトル-即値</p>
<p># Set if less than, unsigned
vmsltu.vv vd, vs2, vs1, vm  # ベクトル-ベクトル
vmsltu.vx vd, vs2, rs1, vm  # ベクトル-スカラ</p>
<p># Set if less than, signed
vmslt.vv vd, vs2, vs1, vm  # ベクトル-ベクトル
vmslt.vx vd, vs2, rs1, vm  # ベクトル-スカラ</p>
<p># Set if less than or equal, unsigned
vmsleu.vv vd, vs2, vs1, vm   # ベクトル-ベクトル
vmsleu.vx vd, vs2, rs1, vm   # ベクトル-スカラ
vmsleu.vi vd, vs2, imm, vm   # ベクトル-即値</p>
<p># Set if less than or equal, signed
vmsle.vv vd, vs2, vs1, vm  # ベクトル-ベクトル
vmsle.vx vd, vs2, rs1, vm  # ベクトル-スカラ
vmsle.vi vd, vs2, imm, vm  # ベクトル-即値</p>
<p># Set if greater than, unsigned
vmsgtu.vx vd, vs2, rs1, vm   # ベクトル-スカラ
vmsgtu.vi vd, vs2, imm, vm   # ベクトル-即値</p>
<p># Set if greater than, signed
vmsgt.vx vd, vs2, rs1, vm    # ベクトル-スカラ
vmsgt.vi vd, vs2, imm, vm    # ベクトル-即値</p>
<p># 以下の2命令は直接提供されない
# Set if greater than or equal, unsigned
# vmsgeu.vx vd, vs2, rs1, vm    # ベクトル-スカラ
# Set if greater than or equal, signed
# vmsge.vx vd, vs2, rs1, vm    # ベクトル-スカラ</p>
</dd>
</dl>
<p>以下の表は全ての比較操作がどのようにネイティブマシンコードに実装されるのかを示しています。</p>
<dl>
<dt>::</dt><dd><p>比較            アセンブラマッピング          アセンブラ疑似命令</p>
<p>va &lt; vb         vmslt{u}.vv vd, va, vb, vm
va &lt;= vb        vmsle{u}.vv vd, va, vb, vm
va &gt; vb         vmslt{u}.vv vd, vb, va, vm    vmsgt{u}.vv vd, va, vb, vm
va &gt;= vb        vmsle{u}.vv vd, vb, va, vm    vmsge{u}.vv vd, va, vb, vm</p>
<p>va &lt; x          vmslt{u}.vx vd, va, x, vm
va &lt;= x         vmsle{u}.vx vd, va, x, vm
va &gt; x          vmsgt{u}.vx vd, va, x, vm
va &gt;= x         see below</p>
<p>va &lt; i          vmsle{u}.vi vd, va, i-1, vm    vmslt{u}.vi vd, va, i, vm
va &lt;= i         vmsle{u}.vi vd, va, i, vm
va &gt; i          vmsgt{u}.vi vd, va, i, vm
va &gt;= i         vmsgt{u}.vi vd, va, i-1, vm    vmsge{u}.vi vd, va, i, vm</p>
<p>va, vb ベクトルレジスタグループ
x      スカラ整数レジスタ
i      即値</p>
</dd>
</dl>
<p>NOTE: <cite>vmslt{u}.vi</cite> の即時形は、即時値を1減らして <cite>vmsle{u}.vi</cite> のバリエーションを代わりに使用できるので、提供されません。
<cite>vmsle.vi</cite> の範囲は -16 から 15 で、その結果、実効的な <cite>vmslt.vi</cite> の範囲は -15 から 16 となります。
<cite>vmsleu.vi</cite> の範囲は0から15で、実効的な <cite>vmsltu.vi</cite> の範囲は1から16になります (注意: 即値0の <cite>vmsltu.vi</cite> は常に偽なので役に立ちません)。
5ビットのベクトル即値は常に符号拡張されているので、<cite>vmsleu.vi</cite> は <cite>2^SEW^-16</cite> から <cite>2^SEW^-1</cite> の範囲の符号なし即値もサポートしており、
<cite>2^SEW^-15</cite> から <cite>2^SEW^</cite> の範囲の符号なし即値に対する <cite>vmsltu.vi</cite> の比較が可能です。
即値 <cite>2^SEW^</cite> の <cite>vlsltu.vi</cite> は常に真なので、有用ではないことに注意してください。</p>
<p>同様に、<cite>vmsge{u}.vi</cite> は提供されず、即値を1だけデクリメントした <cite>vmsgt{u}.vi</cite> を使用して比較を実装します。
その結果、実効的な <cite>vmsge.vi</cite> の範囲は-15～16、実効的な <cite>vmsgeu.vi</cite> の範囲は1～16となります(なお、即値が0の <cite>vmsgeu.vi</cite> は常に真なので役に立ちません)。</p>
<p>NOTE: レジスタスカラと即値の <cite>vmsgt</cite> 形式は、追加のマスク論理命令を使用せずに、
1つの比較命令でマスク値の正しい極性を提供できるようにするために提供されています。</p>
<p>エンコーディング空間を減らすために、<cite>vmsge{u}.vx</cite> 形式は直接提供されていないので、<cite>va {ge} x</cite> の場合は特別な処理が必要です。</p>
<p>NOTE: <cite>vmsge{u}.vx</cite> は、使用されていない OPIVI の変形である <cite>vmslt{u}</cite> の下で、非直交的な方法でエンコードされる可能性があります。
しかし、OPIVIでスカラの <cite>x</cite> レジスタを使用する命令はこれらだけです。
別の方法として、さらに2つのfunct6エンコーディングを使用することもできますが、
これらは同じ8つのfunct6エンコーディングのグループの他のものとは異なるオペランドフォーマット(マスクレジスタへの書き込み)になります。
現在のPoRでは、これらの命令を省略し、必要に応じて以下のように合成しています。</p>
<p><cite>vmsge{u}.vx</cite> の演算は、 <cite>x</cite> の表現がアンダーフローしないことがわかっている場合、 <cite>x</cite> の値を1だけ減らして <cite>vmsgt{u}.vx</cite> 命令を使用することで合成できます。</p>
<dl>
<dt>::</dt><dd><p><cite>vmsge{u}.vx</cite> 命令を合成するための命令列</p>
<p>va &gt;= x,  x &gt; minimum</p>
<blockquote>
<div><p>addi t0, x, -1; vmsgt{u}.vx vd, va, t0, vm</p>
</div></blockquote>
</dd>
</dl>
<p>通常は上記の順序が最も効率的な実装になりますが、 <cite>x</cite> の範囲が不明な場合にはアセンブラの疑似命令を提供することができます。</p>
<dl>
<dt>::</dt><dd><p>マスク無し va &gt;= x</p>
<blockquote>
<div><p>疑似命令: vmsge{u}.vx vd, va, x
展開: vmslt{u}.vx vd, va, x; vmnand.mm vd, vd, vd</p>
</div></blockquote>
<p>マスク付き va &gt;= x, vd != v0</p>
<blockquote>
<div><p>疑似命令: vmsge{u}.vx vd, va, x, v0.t
展開: vmslt{u}.vx vd, va, x, v0.t; vmxor.mm vd, vd, v0</p>
</div></blockquote>
<p>マスク付き va &gt;= x, vd == v0</p>
<blockquote>
<div><p>疑似命令: vmsge{u}.vx vd, va, x, v0.t, vt
展開: vmslt{u}.vx vt, va, x;  vmandnot.mm vd, vd, vt</p>
</div></blockquote>
<p>マスク付き va &gt;= x, any vd</p>
<blockquote>
<div><p>疑似命令: vmsge{u}.vx vd, va, x, v0.t, vt
展開: vmslt{u}.vx vt, va, x;  vmandnot.mm vt, v0, vt;  vmandnot.mm vd, vd, v0;  vmor.mm vd, vt, vd</p>
<p>疑似命令中のvt引数は一時ベクトルレジスタの意味であり、
vdとは異なり破壊される問題ないレジスタでなければならない</p>
</div></blockquote>
</dd>
</dl>
<p>マスク付きundisturbedポリシによって複数の比較をANDする例を以下に示します。</p>
<dl class="simple">
<dt>::</dt><dd><p># (a &lt; b) &amp;&amp; (b &lt; c) をマスク付きundisturbedによって2命令で実現する
vmslt.vv    v0, va, vb        # 全ての要素に書き込みを行う
vmslt.vv    v0, vb, vc, v0.t  # マスクの設定された場所のみ書き込みを行う</p>
</dd>
</dl>
<p>比較はマスクレジスタを書き込むため、常に末尾agnosticポリシで動作します。</p>
</div>
<div class="section" id="id128">
<h3>ベクトル整数最大/最小命令<a class="headerlink" href="#id128" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>符号付き整数/符号なし整数の最大・最小値計算命令がサポートされている。</p>
<dl>
<dt>::</dt><dd><p># 符号なし最小値
vminu.vv vd, vs2, vs1, vm   # ベクトル-ベクトル
vminu.vx vd, vs2, rs1, vm   # ベクトル-スカラ</p>
<p># 符号付き最小値
vmin.vv vd, vs2, vs1, vm   # ベクトル-ベクトル
vmin.vx vd, vs2, rs1, vm   # ベクトル-スカラ</p>
<p># 符号なし最大値
vmaxu.vv vd, vs2, vs1, vm   # ベクトル-ベクトル
vmaxu.vx vd, vs2, rs1, vm   # ベクトル-スカラ</p>
<p># 符号付き最大値
vmax.vv vd, vs2, vs1, vm   # ベクトル-ベクトル
vmax.vx vd, vs2, rs1, vm   # ベクトル-スカラ</p>
</dd>
</dl>
</div>
<div class="section" id="id129">
<h3>ベクトル単一幅整数乗算命令<a class="headerlink" href="#id129" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>単一幅の乗算命令は、SEWビット*SEWビットの乗算を行い、SEWビット幅の結果を返す。
<cite>*mulh*</cite> 版では、積の上位ワードを出力レジスタに書き込みます。</p>
<dl>
<dt>::</dt><dd><p># 符号付き乗算、積の下位ビットを返す
vmul.vv vd, vs2, vs1, vm   # Vector-vector
vmul.vx vd, vs2, rs1, vm   # vector-scalar</p>
<p># 符号付き乗算、積の上位ビットを返す
vmulh.vv vd, vs2, vs1, vm   # Vector-vector
vmulh.vx vd, vs2, rs1, vm   # vector-scalar</p>
<p># 符号なし乗算、積の上位ビットを返す
vmulhu.vv vd, vs2, vs1, vm   # Vector-vector
vmulhu.vx vd, vs2, rs1, vm   # vector-scalar</p>
<p># vs2を符号付き、vs1を符号なしとした乗算、積の上位ビットを返す
vmulhsu.vv vd, vs2, vs1, vm   # Vector-vector
vmulhsu.vx vd, vs2, rs1, vm   # vector-scalar</p>
</dd>
</dl>
<p>NOTE: 符号なしベクトル * 符号付きスカラ積の上位半分を返す <cite>vmulhus</cite> オペコードはありません。</p>
<p>NOTE: 現在の <cite>vmulh*</cite> オペコードは、単純な小数乗算を行いますが、結果をスケーリングしたり、丸めたり、飽和させたりするオプションはありません。
拡張機能としては、<cite>vmulh</cite>, <cite>vmulhu</cite>, <cite>vmulhsu</cite> のバリエーションが考えられ、積の下半分を破棄する際に <cite>vxrm</cite> 丸めモードを使用します。
これらのケースではオーバーフローの可能性はありません。</p>
</div>
<div class="section" id="id130">
<h3>ベクトル整数除算命令<a class="headerlink" href="#id130" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>除算・剰余命令は、RISC-V標準のスカラ整数乗除算と同等で、極端な入力に対しても同じ結果が得られます。</p>
<dl>
<dt>::</dt><dd><p># 符号なし除算
vdivu.vv vd, vs2, vs1, vm   # ベクトル-ベクトル
vdivu.vx vd, vs2, rs1, vm   # ベクトル-スカラ</p>
<p># 符号付除算
vdiv.vv vd, vs2, vs1, vm   # ベクトル-ベクトル
vdiv.vx vd, vs2, rs1, vm   # ベクトル-スカラ</p>
<p># 符号なし剰余
vremu.vv vd, vs2, vs1, vm   # ベクトル-ベクトル
vremu.vx vd, vs2, rs1, vm   # ベクトル-スカラ</p>
<p># 符号付剰余
vrem.vv vd, vs2, vs1, vm   # ベクトル-ベクトル
vrem.vx vd, vs2, rs1, vm   # ベクトル-スカラ</p>
</dd>
</dl>
<p>NOTE: 整数の除算と余剰を含めるかどうかは、意見が分かれました。
標準的な命令がない場合、ソフトウェアは演算を実行するために何らかのアルゴリズムを選択しなければならず、
マイクロアーキテクチャによってはパフォーマンスが低下する可能性があるというのが賛成の理由です。</p>
<p>NOTE: &quot;ベクトルによるスカラ除算&quot;を実行する命令はありません。</p>
</div>
<div class="section" id="id131">
<h3>ベクトル幅拡張乗算命令<a class="headerlink" href="#id131" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>幅拡張整数乗算命令は、SEWビット*SEWビット乗算から完全な2*SEWビット積を返します。</p>
<dl>
<dt>::</dt><dd><p># 幅拡張符号付き整数乗算
vwmul.vv  vd, vs2, vs1, vm # vector-vector
vwmul.vx  vd, vs2, rs1, vm # vector-scalar</p>
<p># 幅拡張符号なし整数乗算
vwmulu.vv vd, vs2, vs1, vm # vector-vector
vwmulu.vx vd, vs2, rs1, vm # vector-scalar</p>
<p># 幅拡張符号付き・符号なし整数乗算
vwmulsu.vv vd, vs2, vs1, vm # vector-vector
vwmulsu.vx vd, vs2, rs1, vm # vector-scalar</p>
</dd>
</dl>
</div>
<div class="section" id="id132">
<h3>ベクトル単一幅整数乗算加算命令<a class="headerlink" href="#id132" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>整数の乗算加算命令は破壊的で、加算値や最小値を上書きするもの(<cite>vmacc</cite>、<cite>vnmsac</cite>)と、
最初の乗算値を上書きするもの(<cite>vmadd</cite>、<cite>vnmsub</cite>)の2種類が用意されています。</p>
<p>積の下位ビットの半分が第3オペランドに加算または減算されます。</p>
<p>NOTE: <cite>sac</cite> は「アキュムレータからの減算(subtract from accumulator)」と読むことを意図しています。
オペコードは、(残念ながら直感に反する)浮動小数点の <cite>fnmsub</cite> 命令の定義に合わせて <cite>vnmsac</cite> となっています。
オペコードは <cite>vnmsub</cite> と似ています。</p>
<dl>
<dt>::</dt><dd><p># 整数乗算加算命令、加算項上書き
vmacc.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vs2[i]) + vd[i]
vmacc.vx vd, rs1, vs2, vm    # vd[i] = +(x[rs1] * vs2[i]) + vd[i]</p>
<p># 整数乗算減算命令、減算項上書き
vnmsac.vv vd, vs1, vs2, vm    # vd[i] = -(vs1[i] * vs2[i]) + vd[i]
vnmsac.vx vd, rs1, vs2, vm    # vd[i] = -(x[rs1] * vs2[i]) + vd[i]</p>
<p># 整数乗算加算命令、乗算項上書き
vmadd.vv vd, vs1, vs2, vm    # vd[i] = (vs1[i] * vd[i]) + vs2[i]
vmadd.vx vd, rs1, vs2, vm    # vd[i] = (x[rs1] * vd[i]) + vs2[i]</p>
<p># 整数乗算減算命令、乗算項上書き
vnmsub.vv vd, vs1, vs2, vm    # vd[i] = -(vs1[i] * vd[i]) + vs2[i]
vnmsub.vx vd, rs1, vs2, vm    # vd[i] = -(x[rs1] * vd[i]) + vs2[i]</p>
</dd>
</dl>
</div>
<div class="section" id="id133">
<h3>ベクトル幅拡張整数乗算加算命令<a class="headerlink" href="#id133" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>幅拡張整数乗算・加算命令は、SEWビット*SEWビットの乗算から2*SEWビットの値に2*SEWビットの乗算を加算し、
2*SEWビットの結果を生成します。
符号付きおよび符号なしの乗算オペランドのすべての組み合わせがサポートされています。</p>
<dl>
<dt>::</dt><dd><p># 幅拡張符号なし整数乗算加算命令、加算項上書き
vwmaccu.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vs2[i]) + vd[i]
vwmaccu.vx vd, rs1, vs2, vm    # vd[i] = +(x[rs1] * vs2[i]) + vd[i]</p>
<p># 幅拡張符号付き整数乗算加算命令、加算項上書き
vwmacc.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vs2[i]) + vd[i]
vwmacc.vx vd, rs1, vs2, vm    # vd[i] = +(x[rs1] * vs2[i]) + vd[i]</p>
<p># 幅拡張符号なし整数乗算加算命令、加算項上書き
vwmaccsu.vv vd, vs1, vs2, vm  # vd[i] = +(signed(vs1[i]) * unsigned(vs2[i])) + vd[i]
vwmaccsu.vx vd, rs1, vs2, vm  # vd[i] = +(signed(x[rs1]) * unsigned(vs2[i])) + vd[i]</p>
<p># Widening unsigned-signed-integer multiply-add, overwrite addend
# 幅拡張符号なし・符号付き整数乗算加算命令、加算項上書き
vwmaccus.vx vd, rs1, vs2, vm  # vd[i] = +(unsigned(x[rs1]) * signed(vs2[i])) + vd[i]</p>
</dd>
</dl>
</div>
<div class="section" id="id134">
<h3>ベクトル整数マージ命令<a class="headerlink" href="#id134" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ベクトル整数マージ命令は、2つのソースオペランドをマスクに基づいて結合します。
通常の算術命令とは異なり、マージはすべてのボディ要素(すなわち、 <cite>vstart</cite> から <cite>vl</cite> の現在のベクトル長までの要素の集合)に対して動作します。</p>
<p><cite>vmerge</cite> 命令は、マスクされた命令(<cite>vm=0</cite>)としてエンコードされます。
この命令は、次のように2つのソースを組み合わせます。
マスク値がゼロの要素では、第1オペランドが書き込み要素にコピーされ、そうでない場合は第2オペランドが書き込み要素にコピーされます。
第1オペランドは常に <cite>vs2</cite> で指定されるベクトルレジスタ群です。
第2オペランドは、 <cite>vs1</cite> で指定されるベクトルレジスタ群、
<cite>rs1</cite> で指定されるスカラ <cite>x</cite> レジスタ、または5ビットの符号拡張即値です。</p>
<dl class="simple">
<dt>::</dt><dd><p>vmerge.vvm vd, vs2, vs1, v0  # vd[i] = v0.mask[i] ? vs1[i] : vs2[i]
vmerge.vxm vd, vs2, rs1, v0  # vd[i] = v0.mask[i] ? x[rs1] : vs2[i]
vmerge.vim vd, vs2, imm, v0  # vd[i] = v0.mask[i] ? imm    : vs2[i]</p>
</dd>
</dl>
</div>
<div class="section" id="id135">
<h3>ベクトル整数移動命令<a class="headerlink" href="#id135" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ベクトル整数移動命令は、ソース・オペランドをベクトル・レジスタ・グループにコピーします。
<cite>vmv.v.v</cite> はベクトルレジスタ群をコピーしますが、 <cite>vmv.v.x</cite> と <cite>vmv.v.i</cite> はスカラレジスタまたは即値をコピー先のベクトルレジスタ群のすべてのアクティブな要素に __転送__します。
これらの命令は、マスクされていない命令(<cite>vm=1</cite>)としてエンコードされます。
第1オペランド指定子(<cite>vs2</cite>)には、 <cite>v0</cite> が含まれていなければならず、 <cite>vs2</cite> に含まれるその他のベクトルレジスタ番号は _予約されています_ 。</p>
<dl class="simple">
<dt>::</dt><dd><p>vmv.v.v vd, vs1 # vd[i] = vs1[i]
vmv.v.x vd, rs1 # vd[i] = x[rs1]
vmv.v.i vd, imm # vd[i] = imm</p>
</dd>
</dl>
<p>NOTE: マスク値は、シーケンス <cite>vmv.v.i vd, 0; vmerge.vim vd, vd, 1, v0</cite> を使って、SEW幅の要素に広げることができます。</p>
<p>ベクトル整数移動命令は、ベクトルマージ命令とエンコーディングが同じですが、 <cite>vm=1</cite> 、 <cite>vs2=v0</cite> となっています。</p>
<p>ボディ要素を変更しない <cite>vmv.v.vd, vd</cite> という形式は、そのレジスタが次に SEW と等しい EEW で使用されることを示すヒントとして使用されます。</p>
<p>NOTE: EEWに従ってデータを内部的に再編成する実装では、
SEWに従って内部表現をシャッフルすることができます。
データを内部的に再編成しない実装では、この命令を動的に省略し、NOP として扱うことができます。</p>
<p>[[sec-vector-fixed-point]]
.. // == Vector Fixed-Point Arithmetic Instructions</p>
</div>
</div>
<div class="section" id="id136">
<h2>ベクトル固定小数点算術演算命令<a class="headerlink" href="#id136" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>前述の整数演算命令群を拡張し、固定小数点演算がサポートされています。</p>
<p>固定小数点数とは、暗黙の分母を持つ分数の分子として解釈される2の補数の符号付きまたは符号なしの整数です。
固定小数点命令は分子に適用されることを意図しており、分母を管理するのはソフトウェアの責任です。
Nビットの要素には、-2^N-1^...+2^N-1^-1の範囲の2の補数の符号付き整数と、0...+2^N-1^-1の範囲の符号なし整数を格納できます。
固定小数点命令は、スケーリングと丸めをサポートすることで狭いオペランドの精度を維持し、
結果を出力フォーマット範囲に飽和させることでオーバーフローを処理することができます。</p>
<p>NOTE: 上述の幅拡張整数演算は、オーバーフローを回避するためにも使用できます。</p>
<div class="section" id="id137">
<h3>ベクトル単一幅飽和加算と飽和減算<a class="headerlink" href="#id137" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>符号付き整数と符号なし整数の両方に対して、飽和形式の整数の加算と減算が提供されます。
結果が出力先をオーバーフローする場合、結果は最も近い表現可能な値で置き換えられ、 <cite>vxsat</cite> ビットが設定されます。</p>
<dl>
<dt>::</dt><dd><p># 符号なし整数の飽和加算
vsaddu.vv vd, vs2, vs1, vm   # ベクトル-ベクトル
vsaddu.vx vd, vs2, rs1, vm   # ベクトル-スカラ
vsaddu.vi vd, vs2, imm, vm   # ベクトル-即値</p>
<p># 符号付き整数の飽和加算
vsadd.vv vd, vs2, vs1, vm   # ベクトル-ベクトル
vsadd.vx vd, vs2, rs1, vm   # ベクトル-スカラ
vsadd.vi vd, vs2, imm, vm   # ベクトル-即値</p>
<p># 符号付き整数の飽和減算
vssubu.vv vd, vs2, vs1, vm   # ベクトル-ベクトル
vssubu.vx vd, vs2, rs1, vm   # ベクトル-スカラ</p>
<p># 符号付き整数の飽和減算
vssub.vv vd, vs2, vs1, vm   # ベクトル-ベクトル
vssub.vx vd, vs2, rs1, vm   # ベクトル-スカラ</p>
</dd>
</dl>
</div>
<div class="section" id="id138">
<h3>ベクトル単一幅平均加算と平均減算命令<a class="headerlink" href="#id138" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>平均化された加算・減算命令は、結果を1ビット右シフトし、 <cite>vxrm</cite> の設定に従って結果を丸める。
符号なしと符号ありのバージョンがあります。
<cite>vaaddu</cite> と <cite>vaadd</cite> では、結果にオーバーフローがあってはなりません。
<cite>vasub</cite> と <cite>vasubu</cite> では、オーバーフローは無視され、結果は折り返されます。</p>
<p>NOTE: <cite>vasub</cite> では、<cite>rnu</cite> や <cite>rne</cite> の丸め方で最大の数から最小の数を引くときにのみオーバーフローが発生します。</p>
<dl>
<dt>::</dt><dd><p># 平均加算</p>
<p># 符号なし整数の平均加算
vaaddu.vv vd, vs2, vs1, vm   # roundoff_unsigned(vs2[i] + vs1[i], 1)
vaaddu.vx vd, vs2, rs1, vm   # roundoff_unsigned(vs2[i] + x[rs1], 1)</p>
<p># 符号付き整数の整数加算
vaadd.vv vd, vs2, vs1, vm   # roundoff_signed(vs2[i] + vs1[i], 1)
vaadd.vx vd, vs2, rs1, vm   # roundoff_signed(vs2[i] + x[rs1], 1)</p>
<p># 平均減算</p>
<p># 符号なし整数の平均減算
vasubu.vv vd, vs2, vs1, vm   # roundoff_unsigned(vs2[i] - vs1[i], 1)
vasubu.vx vd, vs2, rs1, vm   # roundoff_unsigned(vs2[i] - x[rs1], 1)</p>
<p># 符号付き整数の平均減算
vasub.vv vd, vs2, vs1, vm   # roundoff_signed(vs2[i] - vs1[i], 1)
vasub.vx vd, vs2, rs1, vm   # roundoff_signed(vs2[i] - x[rs1], 1)</p>
</dd>
</dl>
</div>
<div class="section" id="id139">
<h3>丸めと飽和を用いたベクトル単一幅分数乗算<a class="headerlink" href="#id139" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>符号付き分数乗算命令は、2つのSEW入力の2*SEW積を生成し、その結果をSEW-1ビットだけ右にシフトし、これらのビットを <cite>vxrm</cite> に従って丸めた後、SEWビットに収まるように結果を飽和させます。
結果が飽和した場合は、 <cite>vxsat</cite> ビットがセットされます。</p>
<dl class="simple">
<dt>::</dt><dd><p># 符号付き飽和丸め分数乗算
# 丸め演算については、vxrmの説明を参照のこと
vsmul.vv vd, vs2, vs1, vm  # vd[i] = clip(roundoff_signed(vs2[i]*vs1[i], SEW-1))
vsmul.vx vd, vs2, rs1, vm  # vd[i] = clip(roundoff_signed(vs2[i]*x[rs1], SEW-1))</p>
</dd>
</dl>
<p>NOTE: 2つのNビット符号付き数値を乗算する場合、最大の大きさは-2^N-1^ * -2^N-1^で得られ、
結果は+2^2N-2^となり、2Nビットで保持する場合、符号ビットは1つ(ゼロ)となります。
他のすべての製品は、2Nビットで2つの符号ビットを持ちます。
N個の結果ビットでより高い精度を維持するために、製品はNよりも1ビット少ない数だけ右にシフトされ、
最大の大きさの結果は飽和しますが、他のすべての製品では結果の精度が1ビット増加します。</p>
<p>NOTE: 一方の入力が符号なしの場合には、SEWの上位ビットをすべて保持し、飽和させる必要がないため、同等の分数乗算は提供していません。
この操作は、丸めが単なる切り捨て(<cite>rdn</cite>)である場合には、 <cite>vmulhu</cite> および <cite>vmulhsu</cite> 命令によって部分的にカバーされます。</p>
<div class="section" id="id140">
<h4>ベクトル単一幅スケーリングシフト命令<a class="headerlink" href="#id140" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>これらの命令は、入力値を右にシフトし、シフトしたビットを <cite>vxrm</cite> に従って丸めます。
スケーリングの右シフトには、ゼロ拡張型 (<cite>vssrl</cite>) と符号拡張型 (<cite>vssra</cite>) があります。
ベクトルまたはスカラのシフト量の値の下位lg2(SEW)ビットが使用され、シフト量の即値はゼロ拡張されます。</p>
<dl>
<dt>::</dt><dd><p># 論理スケーリング右シフト
vssrl.vv vd, vs2, vs1, vm   # vd[i] = roundoff_unsigned(vs2[i], vs1[i])
vssrl.vx vd, vs2, rs1, vm   # vd[i] = roundoff_unsigned(vs2[i], x[rs1])
vssrl.vi vd, vs2, uimm, vm  # vd[i] = roundoff_unsigned(vs2[i], uimm)</p>
<p># 算術スケーリング右シフト
vssra.vv vd, vs2, vs1, vm   # vd[i] = roundoff_signed(vs2[i],vs1[i])
vssra.vx vd, vs2, rs1, vm   # vd[i] = roundoff_signed(vs2[i], x[rs1])
vssra.vi vd, vs2, uimm, vm  # vd[i] = roundoff_signed(vs2[i], uimm)</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="id141">
<h3>ベクトル固定小数点幅縮小クリップ命令<a class="headerlink" href="#id141" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><cite>vnclip</cite> 命令は、固定小数点の値をより狭い出力先に詰めるために使用されます。
この命令は、最終的な出力形式への丸め、スケーリング、および飽和をサポートします。</p>
<p>2番目の引数(ベクトル要素、スカラ値、即値)は、狭義のシフト命令のようにソースを右シフトする量を与え、スケーリングを行います。
ベクトルまたはスカラのシフト量の値の下位lg2(2*SEW)ビットが使用されます(例：SEW=64ビットからSEW=32ビットへの狭帯域化操作の場合は下位6ビット)。
即値形式は、シフト量の即値オペランドをゼロ拡張します。</p>
<dl>
<dt>::</dt><dd><p># 符号なし幅縮小クリップ命令
#                                SEW                            2*SEW   SEW</p>
<blockquote>
<div><p>vnclipu.wv vd, vs2, vs1, vm  # vd[i] = clip(roundoff_unsigned(vs2[i], vs1[i]))
vnclipu.wx vd, vs2, rs1, vm  # vd[i] = clip(roundoff_unsigned(vs2[i], x[rs1]))
vnclipu.wi vd, vs2, uimm, vm # vd[i] = clip(roundoff_unsigned(vs2[i], uimm))</p>
</div></blockquote>
<dl class="simple">
<dt># 符号付き幅縮小クリップ</dt><dd><p>vnclip.wv vd, vs2, vs1, vm   # vd[i] = clip(roundoff_signed(vs2[i], vs1[i]))
vnclip.wx vd, vs2, rs1, vm   # vd[i] = clip(roundoff_signed(vs2[i], x[rs1]))
vnclip.wi vd, vs2, uimm, vm  # vd[i] = clip(roundoff_signed(vs2[i], uimm))</p>
</dd>
</dl>
</dd>
</dl>
<p><cite>vnclipu</cite>/<cite>vnclip</cite> では、丸め方は <cite>vxrm</cite> CSR で指定します。
丸めは、書き込みレジスタの最下位ビットを中心に、飽和演算の前に行われます。</p>
<p><cite>vnclipu</cite> では、シフトされた丸められたソース値は符号なし整数として扱われ、
その結果が符号なし整数として見た書き込みレジスタをオーバーフローする場合は飽和します。</p>
<p>NOTE: 符号付きの値を符号なしの出力先に飽和させることができる単一の命令はありません。
<cite>vxsat</cite> の値を設定する必要がない場合は、まず <cite>vmax</cite> を使って0に対する最大値を実行して負の数を取り除き、
次に <cite>vnclipu</cite> を使って結果の符号なしの値を出力先にクリップする、2つのベクトル命令列を使用できます。
SEWを変更するには、この2つの命令の間に、 <cite>vsetvli</cite> が必要です。</p>
<p><cite>vnclip</cite> では、丸められたシフト元の値を符号付き整数として扱い、その結果が符号付き整数として見たときに
書き込みレジスタをオーバーフローさせるようであれば飽和を行います。</p>
<p>いずれかの書き込みレジスタの要素が飽和した場合、 <cite>vxsat</cite> レジスタに <cite>vxsat</cite> ビットが設定されます。</p>
<p>[[sec-vector-float]]
.. // == Vector Floating-Point Instructions</p>
</div>
</div>
<div class="section" id="id142">
<h2>ベクトル浮動小数点命令<a class="headerlink" href="#id142" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>標準のベクトル浮動小数点命令では、16ビット、32ビット、64ビット、128ビットの要素をIEEE-754/2008互換の値として扱います。
ベクトル浮動小数点演算子のEEWが、サポートされているIEEE浮動小数点型に対応していない場合、
その命令のエンコーディングは予約されています。</p>
<p>NOTE: サポートされる浮動小数点要素の幅は、プロファイルによって異なります。</p>
<p>ベクトル浮動小数点命令では、サポートされているベクトル浮動小数点の要素幅に対応する
スカラ浮動小数点拡張が有効であることが必要です。</p>
<p>NOTE: 特に16ビット半精度浮動小数点値をサポートするベクトルプロファイルでは、
<cite>f</cite> レジスタでのスカラ半精度浮動小数点サポートも実装する必要があります。</p>
<p>浮動小数点ユニット状態フィールド <cite>mstatus.FS</cite> が <cite>Off</cite> の場合、
ベクトル浮動小数点命令を実行しようとすると、不正な命令例外が発生します。
浮動小数点拡張状態(浮動小数点CSRや <cite>f</cite> レジスタなど)を変更するベクトル浮動小数点命令は、
<cite>mstatus.FS</cite> を <cite>Dirty</cite> に設定しなければなりません。</p>
<p>ベクトル浮動小数点命令は、NaNに関してはスカラ浮動小数点命令と同じ動作をします。</p>
<p>ベクトルスカラ演算のスカラ値は、 &lt;&lt;sec-arithmetic-encoding&gt;&gt; で説明したように、
標準的なスカラ <cite>f</cite> レジスタから供給することができます。</p>
<div class="section" id="id143">
<h3>ベクトル浮動小数点例外フラグ<a class="headerlink" href="#id143" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>アクティブな浮動小数点要素でのベクトル浮動小数点例外は、 <cite>fflags</cite> レジスタの標準FP例外フラグを設定します。
非アクティブな要素はFP例外フラグを設定しません。</p>
</div>
<div class="section" id="id144">
<h3>ベクトル単一幅浮動小数点加減算命令<a class="headerlink" href="#id144" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl>
<dt>::</dt><dd><p># 浮動小数点加算
vfadd.vv vd, vs2, vs1, vm   # ベクトル-ベクトル
vfadd.vf vd, vs2, rs1, vm   # ベクトル-スカラ</p>
<p># 浮動小数点減算
vfsub.vv vd, vs2, vs1, vm   # ベクトル-ベクトル
vfsub.vf vd, vs2, rs1, vm   # ベクトル-スカラ vd[i] = vs2[i] - f[rs1]
vfrsub.vf vd, vs2, rs1, vm  # スカラ-ベクトル vd[i] = f[rs1] - vs2[i]</p>
</dd>
</dl>
</div>
<div class="section" id="id145">
<h3>ベクトル幅拡張浮動小数点加減算命令<a class="headerlink" href="#id145" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl>
<dt>::</dt><dd><p># 浮動小数点幅拡張加減算命令, 2*SEW = SEW +/- SEW
vfwadd.vv vd, vs2, vs1, vm  # ベクトル-ベクトル
vfwadd.vf vd, vs2, rs1, vm  # ベクトル-スカラ
vfwsub.vv vd, vs2, vs1, vm  # ベクトル-ベクトル
vfwsub.vf vd, vs2, rs1, vm  # ベクトル-スカラ</p>
<p># 浮動小数点幅拡張加減算命令, 2*SEW = 2*SEW +/- SEW
vfwadd.wv  vd, vs2, vs1, vm  # ベクトル-ベクトル
vfwadd.wf  vd, vs2, rs1, vm  # ベクトル-スカラ
vfwsub.wv  vd, vs2, vs1, vm  # ベクトル-ベクトル
vfwsub.wf  vd, vs2, rs1, vm  # ベクトル-スカラ</p>
</dd>
</dl>
</div>
<div class="section" id="id146">
<h3>ベクトル単一幅浮動小数点乗算除算命令<a class="headerlink" href="#id146" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl>
<dt>::</dt><dd><p># 浮動小数点乗算
vfmul.vv vd, vs2, vs1, vm   # ベクトル-ベクトル
vfmul.vf vd, vs2, rs1, vm   # ベクトル-スカラ</p>
<p># 浮動小数点除算
vfdiv.vv vd, vs2, vs1, vm   # ベクトル-ベクトル
vfdiv.vf vd, vs2, rs1, vm   # ベクトル-スカラ</p>
<p># 浮動小数点逆除算 ベクトル = スカラ / ベクトル
vfrdiv.vf vd, vs2, rs1, vm  # scalar-vector, vd[i] = f[rs1]/vs2[i]</p>
</dd>
</dl>
</div>
<div class="section" id="id147">
<h3>ベクトル幅拡張浮動小数点乗算命令<a class="headerlink" href="#id147" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="simple">
<dt>::</dt><dd><p># 幅拡張浮動小数点乗算
vfwmul.vv    vd, vs2, vs1, vm # ベクトル-ベクトル
vfwmul.vf    vd, vs2, rs1, vm # ベクトル-スカラ</p>
</dd>
</dl>
</div>
<div class="section" id="id148">
<h3>ベクトル単一幅浮動小数点複合乗算加算命令<a class="headerlink" href="#id148" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>複合乗算加算の4種類すべてが提供されており、加算値または最初の乗算値のいずれかのオペランドを上書きする2つの破壊的な形式があります。</p>
<dl>
<dt>::</dt><dd><p># FP multiply-accumulate, overwrites addend
vfmacc.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vs2[i]) + vd[i]
vfmacc.vf vd, rs1, vs2, vm    # vd[i] = +(f[rs1] * vs2[i]) + vd[i]</p>
<p># FP negate-(multiply-accumulate), overwrites subtrahend
vfnmacc.vv vd, vs1, vs2, vm   # vd[i] = -(vs1[i] * vs2[i]) - vd[i]
vfnmacc.vf vd, rs1, vs2, vm   # vd[i] = -(f[rs1] * vs2[i]) - vd[i]</p>
<p># FP multiply-subtract-accumulator, overwrites subtrahend
vfmsac.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vs2[i]) - vd[i]
vfmsac.vf vd, rs1, vs2, vm    # vd[i] = +(f[rs1] * vs2[i]) - vd[i]</p>
<p># FP negate-(multiply-subtract-accumulator), overwrites minuend
vfnmsac.vv vd, vs1, vs2, vm   # vd[i] = -(vs1[i] * vs2[i]) + vd[i]
vfnmsac.vf vd, rs1, vs2, vm   # vd[i] = -(f[rs1] * vs2[i]) + vd[i]</p>
<p># FP multiply-add, overwrites multiplicand
vfmadd.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vd[i]) + vs2[i]
vfmadd.vf vd, rs1, vs2, vm    # vd[i] = +(f[rs1] * vd[i]) + vs2[i]</p>
<p># FP negate-(multiply-add), overwrites multiplicand
vfnmadd.vv vd, vs1, vs2, vm   # vd[i] = -(vs1[i] * vd[i]) - vs2[i]
vfnmadd.vf vd, rs1, vs2, vm   # vd[i] = -(f[rs1] * vd[i]) - vs2[i]</p>
<p># FP multiply-sub, overwrites multiplicand
vfmsub.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vd[i]) - vs2[i]
vfmsub.vf vd, rs1, vs2, vm    # vd[i] = +(f[rs1] * vd[i]) - vs2[i]</p>
<p># FP negate-(multiply-sub), overwrites multiplicand
vfnmsub.vv vd, vs1, vs2, vm   # vd[i] = -(vs1[i] * vd[i]) + vs2[i]
vfnmsub.vf vd, rs1, vs2, vm   # vd[i] = -(f[rs1] * vd[i]) + vs2[i]</p>
</dd>
</dl>
<p>NOTE: スカラFPのFMAエンコーディングで使用されていない2つの丸めモードを使用して、
いくつかの非破壊的なFMAを提供することは可能でしょう。
しかし、これは3つの入力と別々の出力を持つ唯一のマスク可能な演算となります。</p>
</div>
<div class="section" id="id149">
<h3>ベクトル幅拡張浮動小数点複合乗算加算命令<a class="headerlink" href="#id149" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>幅拡張された浮動小数点複合乗算加算命令は、すべて幅拡張された加算先を結果で上書きします。
乗算器の入力はすべてSEW幅で、加算器と出力は2*SEWビット幅です。</p>
<dl>
<dt>::</dt><dd><p># FP widening multiply-accumulate, overwrites addend
vfwmacc.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vs2[i]) + vd[i]
vfwmacc.vf vd, rs1, vs2, vm    # vd[i] = +(f[rs1] * vs2[i]) + vd[i]</p>
<p># FP widening negate-(multiply-accumulate), overwrites addend
vfwnmacc.vv vd, vs1, vs2, vm   # vd[i] = -(vs1[i] * vs2[i]) - vd[i]
vfwnmacc.vf vd, rs1, vs2, vm   # vd[i] = -(f[rs1] * vs2[i]) - vd[i]</p>
<p># FP widening multiply-subtract-accumulator, overwrites addend
vfwmsac.vv vd, vs1, vs2, vm    # vd[i] = +(vs1[i] * vs2[i]) - vd[i]
vfwmsac.vf vd, rs1, vs2, vm    # vd[i] = +(f[rs1] * vs2[i]) - vd[i]</p>
<p># FP widening negate-(multiply-subtract-accumulator), overwrites addend
vfwnmsac.vv vd, vs1, vs2, vm   # vd[i] = -(vs1[i] * vs2[i]) + vd[i]
vfwnmsac.vf vd, rs1, vs2, vm   # vd[i] = -(f[rs1] * vs2[i]) + vd[i]</p>
</dd>
</dl>
</div>
<div class="section" id="id150">
<h3>ベクトル浮動小数点平方根命令<a class="headerlink" href="#id150" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>これは単精度ベクトル-ベクトル命令です。</p>
<dl class="simple">
<dt>::</dt><dd><p># 浮動小数点平方根命令
vfsqrt.v vd, vs2, vm   # ベクトル-ベクトル 平方根</p>
</dd>
</dl>
</div>
<div class="section" id="id151">
<h3>ベクトル浮動小数点逆平方根推定命令<a class="headerlink" href="#id151" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="simple">
<dt>::</dt><dd><p># 7ビットの浮動小数点逆平方根推定命令
vfrsqrt7.v vd, vs2, vm</p>
</dd>
</dl>
<p>これは、7ビットの精度で1/sqrt(x)の推定値を返す、単項のベクトル-ベクトル命令です。</p>
<p>NOTE: 以前のドラフト版では、アセンブラ名として <cite>vfrsqrte7</cite> を使用していましたが、要素幅の <a href="#id152"><span class="problematic" id="id153">``</span></a>e``__x__' 表記との混同を招くと判断されました。
後方互換性のために、ツールチェインのエイリアスとして以前の名前を残すことができます。</p>
<p>次の表は、すべてのクラスの浮動小数点入力に対するこの命令の動作を示しています。</p>
<p>[cols=&quot;1,1,1&quot;]
[%autowidth]
<a href="#id154"><span class="problematic" id="id155">|</span></a>===
| Input | Output | Exceptions raised</p>
<div class="line-block">
<div class="line">-{inf} {le} _x_ &lt; -0.0     | canonical NaN           | NV</div>
<div class="line">-0.0                       | -{inf}                  | DZ</div>
<div class="line">+0.0                       | +{inf}                  | DZ</div>
<div class="line">+0.0 &lt; _x_ &lt; +{inf}        | _estimate of 1/sqrt(x)_ |</div>
<div class="line">+{inf}                     | +0.0                    |</div>
<div class="line">qNaN                       | canonical NaN           |</div>
<div class="line">sNaN                       | canonical NaN           | NV</div>
</div>
<p><a href="#id156"><span class="problematic" id="id157">|</span></a>===</p>
<p>NOTE: すべての正のノーマルおよびサブノーマル入力は、ノーマル出力を生成します。</p>
<p>NOTE: 出力値は、動的丸め込みモードに依存しません。</p>
<p>例外的なケースでは、指数の下位ビットと合数の上位6ビット(先頭の1ビットの後)が連結され、以下のテーブルのアドレスに使用されます。
このテーブルの出力は、結果として得られる信号の上位7ビット(先頭の1ビットの後)となり、結果として得られる信号の残りの部分はゼロとなります。
正常でない入力は、ルックアップの前に正規化され、指数が適切に調整されます。
出力の指数は、結果が引数の平方根の逆数に近似するように選択されます。</p>
<p>より正確には、結果は以下のように計算されます。
正規化された入力指数を、入力が正常な場合は入力指数と等しく、そうでない場合は0から符号の先頭のゼロの数を引いた値とします。
入力が非正規の場合、正規化された入力指数は、先頭の1ビットを捨てて、入力指数を1から正規化された入力指数を引いて左にシフトすることで与えられます。
出力指数は floor((3*B - 1 - 正規化された入力指数) / 2) に等しくなります。
出力符号は入力符号に等しくなります。</p>
<p>次の表は、正規化された入力指数のLSBと正規化された入力記号の6つのMSBの関数として、出力記号の7つのMSBを示したもので、出力記号の他のビットはゼロです。</p>
<p>include::vfrsqrt7.adoc[]</p>
<p>NOTE: 例えば、SEW=32の場合、vfrsqrt7(0x00718abc ({approx} 1.043e-38)) = 0x5f080000 ({approx} 9.800e18)、
および vfrsqrt7(0x7f765432 ({approx} 3.274e38)) = 0x1f820000 ({approx} 5.506e-20)となります。</p>
<p>NOTE: 7ビットの精度は、0,1,2,3回のニュートンラフソン反復を必要とし、それぞれbfloat16, FP16, FP32, FP64に近い精度に収束するために選ばれました。
将来的には、より高い推定精度の命令を定義することができます。</p>
</div>
<div class="section" id="id158">
<h3>ベクトル浮動小数点逆数推定命令<a class="headerlink" href="#id158" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="simple">
<dt>::</dt><dd><p># 7ビットの浮動小数点逆数推定命令
vfrec7.v vd, vs2, vm</p>
</dd>
</dl>
<p>NOTE: 以前のドラフト版では、アセンブラ名として <cite>vfrece7</cite> を使用していましたが、
要素の幅を表す <a href="#id159"><span class="problematic" id="id160">``</span></a>e``__x__ 記法との混同を招くと判断されました。
以前の名前は後方互換性のためにツールチェインのエイリアスとして保持することができます。</p>
<p>これは単項のベクトル・ベクトル命令で、7ビットの精度で1/xの推定値を返します。</p>
<p>次の表は、すべてのクラスの浮動小数点入力に対するこの命令の動作を示しています(_B_は指数バイアスです)。</p>
<p>[cols=&quot;1,1,1,1&quot;]
[%autowidth]
<a href="#id161"><span class="problematic" id="id162">|</span></a>===
| Input (_x_) | Rounding Mode | Output (_y_ {approx} _1/<a href="#id238"><span class="problematic" id="id239">x_</span></a>) | Exceptions raised</p>
<div class="line-block">
<div class="line">-{inf}                                              | _any_         | -0.0                      |</div>
<div class="line">-2^B+1^ &lt; _x_ {le} -2^B^ (normal)                   | _any_         | -2^-(B+1)^ {ge} _y_ &gt; -2^-B^ (subnormal, sig=01...) |</div>
<div class="line">-2^B^ &lt; _x_ {le} -2^B-1^ (normal)                   | _any_         | -2^-B^ {ge} _y_ &gt; -2^-B+1^ (subnormal, sig=1...) |</div>
<div class="line">-2^B-1^ &lt; _x_ {le} -2^-B+1^ (normal)                | _any_         | -2^-B+1^ {ge} _y_ &gt; -2^B-1^ (normal) |</div>
<div class="line">-2^-B+1^ &lt; _x_ {le} -2^-B^ (subnormal, sig=1...)    | _any_         | -2^B-1^ {ge} _y_ &gt; -2^B^ (normal) |</div>
<div class="line">-2^-B^ &lt; _x_ {le} -2^-(B+1)^ (subnormal, sig=01...) | _any_         | -2^B^ {ge} _y_ &gt; -2^B+1^ (normal) |</div>
<div class="line">-2^-(B+1)^ &lt; _x_ &lt; -0.0 (subnormal, sig=00...)      | RUP, RTZ      | greatest-mag. negative finite value | NX, OF</div>
<div class="line">-2^-(B+1)^ &lt; _x_ &lt; -0.0 (subnormal, sig=00...)      | RDN, RNE, RMM | -{inf}                    | NX, OF</div>
<div class="line">-0.0                                                | _any_         | -{inf}                    | DZ</div>
<div class="line">+0.0                                                | _any_         | +{inf}                    | DZ</div>
<div class="line">+0.0 &lt; _x_ &lt; 2^-(B+1)^ (subnormal, sig=00...)       | RUP, RNE, RMM | +{inf}                    | NX, OF</div>
<div class="line">+0.0 &lt; _x_ &lt; 2^-(B+1)^ (subnormal, sig=00...)       | RDN, RTZ      | greatest finite value     | NX, OF</div>
<div class="line">2^-(B+1)^ {le} _x_ &lt; 2^-B^ (subnormal, sig=01...)   | _any_         | 2^B+1^ &gt; _y_ {ge} 2^B^ (normal) |</div>
<div class="line">2^-B^ {le} _x_ &lt; 2^-B+1^ (subnormal, sig=1...)      | _any_         | 2^B^ &gt; _y_ {ge} 2^B-1^ (normal) |</div>
<div class="line">2^-B+1^ {le} _x_ &lt; 2^B-1^ (normal)                  | _any_         | 2^B-1^ &gt; _y_ {ge} 2^-B+1^ (normal) |</div>
<div class="line">2^B-1^ {le} _x_ &lt; 2^B^ (normal)                     | _any_         | 2^-B+1^ &gt; _y_ {ge} 2^-B^ (subnormal, sig=1...) |</div>
<div class="line">2^B^ {le} _x_ &lt; 2^B+1^ (normal)                     | _any_         | 2^-B^ &gt; _y_ {ge} 2^-(B+1)^ (subnormal, sig=01...) |</div>
<div class="line">+{inf}                                              | _any_         | +0.0                      |</div>
<div class="line">qNaN                                                | _any_         | canonical NaN             |</div>
<div class="line">sNaN                                                | _any_         | canonical NaN             | NV</div>
</div>
<p><a href="#id163"><span class="problematic" id="id164">|</span></a>===</p>
<p>NOTE: 大きさが少なくとも2^-(B+1)^のサブノーマル入力は通常の出力を生成し、他のサブノーマル入力は無限の出力を生成します。
少なくとも2^B-1^の大きさを持つ通常の入力は、サブノーマルの出力を生成し、他の通常の入力は通常の出力を生成します。</p>
<p>NOTE: 出力値は、オーバーフロー例外が発生したときの動的丸めモードに依存します。</p>
<p>例外が発生しないケースでは、上位7ビットの仮数部(先頭の1ビットの後)が次の表のアドレスに使用されます。
このテーブルの出力は、結果として得られる信号の上位7ビット(先頭の1ビットの後)となり、結果として得られる信号の残りの部分はゼロとなります。
正常でない入力は、ルックアップの前に正規化され、指数が適切に調整されます。
出力の指数は、結果が引数の逆数に近似するように選択され、サブノーマル出力はそれに応じて非正規化されます。</p>
<p>より正確には、結果は以下のように計算されます。
正規化された入力指数を、入力が正常な場合は入力指数と等しく、そうでない場合は0から符号の先頭のゼロの数を引いたものとします。
正規化された出力指数は、(2*B - 1 - 正規化された入力指数)に等しくなります。
正規化された出力指数が[-1, 2*B]の範囲外である場合、その結果は上の表の例外的なケースの1つに対応します。</p>
<p>入力が非正規の場合、正規化された入力多項式は、入力多項式を1から正規化された入力指数を引いて左にシフトし、先頭の1ビットを捨てて与えられます。
それ以外の場合は、正規化された入力信号は入力信号と同じです。
次の表は、正規化された入力信号の7つのMSBの関数として、正規化された出力信号の7つのMSBを示したもので、正規化された出力信号の他のビットはゼロです。</p>
<p>include::vfrec7.adoc[]</p>
<p>正規化された出力指数が0または-1の場合、結果はサブノーマル数となります。
出力指数は0で、出力の仮数部は正規化された出力仮数部の左にある1ビットを連結し、
その量を正規化された出力指数から1を引いて右にシフトしたものになります。
それ以外の場合は、出力指数は正規化された出力指数に等しく、出力合言葉は正規化された出力仮数部に等しくなります。
出力符号は入力符号に等しくなります。</p>
<p>NOTE: 例えば、SEW=32の場合、vfrec7(0x00718abc ({approx} 1.043e-38)) = 0x7e900000 ({approx} 9.570e37)、
およびvfrec7(0x7f765432 ({approx} 3.274e38)) = 0x00214000 ({approx} 3.053e-39)となります。</p>
<p>NOTE: 7ビットの精度は、bfloat16, FP16, FP32, FP64に近い精度に収束するために、0,1,2,3回のNewton-Raphson反復を必要とすることから選ばれました。
将来的には、より高い推定精度の命令を定義することができます。</p>
</div>
<div class="section" id="min-max">
<h3>ベクトル浮動小数点MIN/MAX命令<a class="headerlink" href="#min-max" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ベクトル浮動小数点 <cite>vfmin</cite> および <cite>vfmax</cite> 命令は、RISC-V F/D/Q 拡張のバージョン 2.2 における対応するスカラ浮動小数点命令と同じ動作をします。</p>
<dl>
<dt>::</dt><dd><p># 浮動小数点最小値
vfmin.vv vd, vs2, vs1, vm   # ベクトル-ベクトル
vfmin.vf vd, vs2, rs1, vm   # ベクトル-スカラ</p>
<p># 浮動小数点最大値
vfmax.vv vd, vs2, vs1, vm   # ベクトル-ベクトル
vfmax.vf vd, vs2, rs1, vm   # ベクトル-スカラ</p>
</dd>
</dl>
</div>
<div class="section" id="id165">
<h3>ベクトル浮動小数点符号挿入命令<a class="headerlink" href="#id165" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>スカラの符号挿入命令のベクトル版です。
結果は符号ビットを除くすべてのビットを、ベクトルの <cite>vs2</cite>  オペランドから取得します。</p>
<dl>
<dt>::</dt><dd><p>vfsgnj.vv vd, vs2, vs1, vm   # ベクトル-ベクトル
vfsgnj.vf vd, vs2, rs1, vm   # ベクトル-スカラ</p>
<p>vfsgnjn.vv vd, vs2, vs1, vm  # ベクトル-ベクトル
vfsgnjn.vf vd, vs2, rs1, vm  # ベクトル-スカラ</p>
<p>vfsgnjx.vv vd, vs2, vs1, vm  # ベクトル-ベクトル
vfsgnjx.vf vd, vs2, rs1, vm  # ベクトル-スカラ</p>
</dd>
</dl>
<p>NOTE: 浮動小数点値のベクトルは、両方のソースオペランドを同じベクトルオペランドに設定したサインインジェクション命令を使用して否定演算をすることができます。
アセンブリ疑似命令 <cite>vfneg.vd,vs</cite> = <cite>vfsgnjn.vv vd,vs,vs</cite> を定義することができます。</p>
<p>NOTE: 浮動小数点要素のベクトルの絶対値は、両方のソースオペランドが同じベクトルオペランドに設定された符号挿入命令を使用して計算することができます。
アセンブリ疑似命令 <cite>vfabs.vd,vs</cite> = <cite>vfsgnjx.vv vd,vs,vs</cite> を定義できます。</p>
</div>
<div class="section" id="id166">
<h3>ベクトル浮動小数点比較命令<a class="headerlink" href="#id166" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>これらのベクトルFP比較命令は、2つのソースオペランドを比較し、比較結果をマスクレジスタに書き込みます。
書き込みマスクベクトルは常に単一のベクトルレジスタに保持され、その要素のレイアウトは &lt;&lt;sec-mask-register-layout&gt;&gt; 節で説明されています。
書き込みマスクレジスタはソースベクトルマスクレジスタ(<cite>v0</cite>)と同じであってもかまいません。
比較はマスクレジスタを書き込むため、常にTail-agnosticポリシで動作します。</p>
<p>比較命令は、スカラ浮動小数点比較命令の文法に従います。
<cite>vmfeq</cite> と <cite>vmfne</cite> は NaN 入力の信号に対してのみ無効な操作という例外を発生させます。
<cite>vmflt</cite>、 <cite>vmfle</cite>、 <cite>vmfgt</cite>、 <cite>vmfge</cite> は、シグナリング NaN 入力とサイレント NaN 入力の両方で無効な操作に関する例外を発生させます。
<cite>vmfne</cite> は、どちらかのオペランドが NaN のときに出力要素に 1 を書き込みますが、
他の比較ではどちらかのオペランドが NaN のときに 0 を書き込みます。</p>
<dl>
<dt>::</dt><dd><p># 等価比較
vmfeq.vv vd, vs2, vs1, vm  # ベクトル-ベクトル
vmfeq.vf vd, vs2, rs1, vm  # ベクトル-スカラ</p>
<p># 非等価比較
vmfne.vv vd, vs2, vs1, vm  # ベクトル-ベクトル
vmfne.vf vd, vs2, rs1, vm  # ベクトル-スカラ</p>
<p># 小なり比較
vmflt.vv vd, vs2, vs1, vm  # ベクトル-ベクトル
vmflt.vf vd, vs2, rs1, vm  # ベクトル-スカラ</p>
<p># 以下比較
vmfle.vv vd, vs2, vs1, vm  # ベクトル-ベクトル
vmfle.vf vd, vs2, rs1, vm  # ベクトル-スカラ</p>
<p># 大なり比較
vmfgt.vf vd, vs2, rs1, vm  # ベクトル-スカラ</p>
<p># 以上比較
vmfge.vf vd, vs2, rs1, vm  # ベクトル-スカラ</p>
</dd>
</dl>
<dl>
<dt>::</dt><dd><p>比較            アセンブリ言語マッピング   アセンブリ言語疑似命令</p>
<p>va &lt; vb         vmflt.vv vd, va, vb, vm
va &lt;= vb        vmfle.vv vd, va, vb, vm
va &gt; vb         vmflt.vv vd, vb, va, vm    vmfgt.vv vd, va, vb, vm
va &gt;= vb        vmfle.vv vd, vb, va, vm    vmfge.vv vd, va, vb, vm</p>
<p>va &lt; f          vmflt.vf vd, va, f, vm
va &lt;= f         vmfle.vf vd, va, f, vm
va &gt; f          vmfgt.vf vd, va, f, vm
va &gt;= f         vmfge.vf vd, va, f, vm</p>
<p>va, vb ベクトルレジスタグループ
f      スカラ浮動小数点レジスタ</p>
</dd>
</dl>
<p>NOTE: すべての形式を提供することとは、NaNに対する順序付けられていない比較を正しく処理するために必要です。</p>
<p>NOTE: C99浮動小数点のquiet比較は、以下のように、どちらかの入力がNaNの場合に信号の比較をマスクすることで実装できます。
比較対象が非 NaN 定数の場合は、中間の2つの命令を省略できます。</p>
<dl class="simple">
<dt>::</dt><dd><p># isgreater() の実装例
vmfeq.vv v0, va, va        # AがNaNでない場合にのみセットされる
vmfeq.vv v1, vb, vb        # BがNaNでない場合にのみセットされる
vmand.mm v0, v0, v1        # AとBに順序関係があるときのみセットされる
vmfgt.vv v0, va, vb, v0.t  #  従って、順序関係がある値の場合にのみフラグが設定される</p>
</dd>
</dl>
<p>NOTE: 上記のシーケンスでは、2つ目の <cite>vmfeq</cite> 命令をマスクして <cite>vmand</cite> 命令を削除したくなりますが、
より効率的なシーケンスでは、<cite>va</cite> の要素に quiet NaN が含まれ、<cite>vb</cite> の対応する要素に signaling NaN が含まれている場合に、
不正な例外を発生させることができません。</p>
</div>
<div class="section" id="id167">
<h3>ベクトル浮動小数点分類命令<a class="headerlink" href="#id167" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>スカラ分類命令と同様に動作する単項のベクトル-ベクトル命令です。</p>
<dl class="simple">
<dt>::</dt><dd><p>vfclass.v vd, vs2, vm   # ベクトル-ベクトル</p>
</dd>
</dl>
<p>この命令で生成された10ビットのマスクは、結果要素の最下位ビットに配置されます。
結果の上位(SEW-10)ビットには0が入ります。
この命令はSEW=16b以上でのみ定義されているため、結果は常に書き込み要素に収まります。</p>
</div>
<div class="section" id="id168">
<h3>ベクトル浮動小数点マージ命令<a class="headerlink" href="#id168" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ベクトルスカラ浮動小数点マージ命令が提供されています。
この命令は、マスク値に関係なく、<cite>vstart</cite> から <cite>vl</cite>  の現在のベクトル長までのすべてのボディ要素で動作します。</p>
<p><cite>vfmerge.vfm</cite> 命令は、マスクされた命令 (<cite>vm=0</cite>) としてエンコードされます。
マスク値がゼロの要素では、最初のベクトルオペランドが書き込み要素にコピーされ、そうでない場合は、スカラ浮動小数点レジスタ値が書き込み要素にコピーされます。</p>
<dl class="simple">
<dt>::</dt><dd><p>vfmerge.vfm vd, vs2, rs1, v0  # vd[i] = v0.mask[i] ? f[rs1] : vs2[i]</p>
</dd>
</dl>
</div>
<div class="section" id="id169">
<h3>ベクトル浮動小数点移動命令<a class="headerlink" href="#id169" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ベクトル浮動小数点移動命令は、浮動小数点のスカラオペランドをベクトルレジスタグループに __転送__ します。
この命令は、スカラ <cite>f</cite> レジスタ値をベクトルレジスタグループのすべてのアクティブな要素にコピーします。
この命令はマスクされた命令(<cite>vm=1</cite>)としてエンコードされます。
この命令は、<cite>vs2</cite> フィールドが <cite>v0</cite> に設定されていなければならず、<cite>vs2</cite> の他の値はすべて予約されています。</p>
<dl class="simple">
<dt>::</dt><dd><p>vfmv.v.f vd, rs1  # vd[i] = f[rs1]</p>
</dd>
</dl>
<p>NOTE: <cite>vfmv.v.f</cite> 命令は、<cite>vfmerge.vfm</cite> 命令とエンコーディングを共有しますが、<cite>vm=1</cite> および <cite>vs2=v0</cite> となります。</p>
</div>
<div class="section" id="id170">
<h3>単一幅浮動所数点/整数型変換命令<a class="headerlink" href="#id170" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>浮動小数点値、符号なし整数、符号あり整数との間の変換操作が用意されており、変換元と変換先の両方がSEW幅である。</p>
<dl>
<dt>::</dt><dd><p>vfcvt.xu.f.v vd, vs2, vm       # 浮動小数点から符号なし整数への変換.
vfcvt.x.f.v  vd, vs2, vm       # 浮動小数点から符号付き整数への変換.</p>
<p>vfcvt.rtz.xu.f.v vd, vs2, vm   # 浮動小数点からtruncateを使用した符号なし整数への変換.
vfcvt.rtz.x.f.v  vd, vs2, vm   # 浮動小数点からtruncateを使用した符号付き整数への変換.</p>
<p>vfcvt.f.xu.v vd, vs2, vm       # 符号なし整数から浮動小数点への変換.
vfcvt.f.x.v  vd, vs2, vm       # 符号付き整数から浮動小数点への変換.</p>
</dd>
</dl>
<p>変換命令は、スカラ変換命令と同じ例外的な条件に関するルールに従います。
これらの変換は、ゼロに向かって丸める <cite>rtz</cite>  の変種を除いて、<cite>frm</cite> の動的丸めモードを使用します。</p>
<p>NOTE: <cite>rtz</cite> バリエーションは、C や Java などの言語で一般的な、
浮動小数点から整数への切り捨て変換を高速化するために提供されています。</p>
</div>
<div class="section" id="id171">
<h3>幅拡張浮動小数点/整数型変換命令<a class="headerlink" href="#id171" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>より小さな整数型や浮動小数点型のデータタイプを2倍の幅の型に変換する変換命令群が用意されています。</p>
<dl>
<dt>::</dt><dd><p>vfwcvt.xu.f.v vd, vs2, vm       # 浮動小数点を倍幅の符号なし整数に変換.
vfwcvt.x.f.v  vd, vs2, vm       # 浮動小数点を倍幅の符号付き整数に変換.</p>
<p>vfwcvt.rtz.xu.f.v vd, vs2, vm   # 浮動小数点をtruncateを使用した倍幅の符号なし整数に変換.
vfwcvt.rtz.x.f.v  vd, vs2, vm   # 浮動小数点をtruncateを使用した倍幅の符号付き整数に変換.</p>
<p>vfwcvt.f.xu.v vd, vs2, vm       # 符号なし整数を倍幅の浮動小数点に変換.
vfwcvt.f.x.v  vd, vs2, vm       # 符号付き整数を倍幅の浮動小数点に変換.</p>
<p>vfwcvt.f.f.v vd, vs2, vm        # 単一幅浮動小数点を倍幅の浮動小数点に変換.</p>
</dd>
</dl>
<p>これらの命令は、他の幅拡張命令(&lt;&lt;sec-widening&gt;&gt;参照)と同様に、ベクトルレジスタのオーバーラップに対する制約があります。</p>
<p>NOTE: 倍幅のIEEE浮動小数点値は、常に単一幅の整数を正確に表すことができます。</p>
<p>NOTE: 倍幅のIEEE浮動小数点値は、常に単一幅のIEEE浮動小数点値を正確に表すことができます。</p>
<p>NOTE: 浮動小数点の幅拡張変換のフルセットは、単一の命令としてはサポートされていませんが、任意の幅拡張変換は、
同等の結果と追加の例外フラグを発生させずに、いくつかの倍のステップとして実装することができます。</p>
</div>
<div class="section" id="id172">
<h3>浮動小数点/整数 幅縮小型変換命令<a class="headerlink" href="#id172" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl>
<dt>::</dt><dd><p>vfncvt.xu.f.w vd, vs2, vm       # 倍幅の浮動小数点を符号付き整数に変換.
vfncvt.x.f.w  vd, vs2, vm       # 倍幅の浮動小数点を符号なし整数に変換.</p>
<p>vfncvt.rtz.xu.f.w vd, vs2, vm   # 倍幅の浮動小数点をtruncateを使用した符号なし整数に変換.
vfncvt.rtz.x.f.w  vd, vs2, vm   # 倍幅の浮動小数点をtruncateを使用した符号付き整数に変換.</p>
<p>vfncvt.f.xu.w vd, vs2, vm       # 倍幅の符号なし整数を浮動小数点に変換.
vfncvt.f.x.w  vd, vs2, vm       # 倍幅の符号付き整数を浮動小数点に変換.</p>
<p>vfncvt.f.f.w vd, vs2, vm        # 倍幅浮動小数点を単一幅の浮動小数点に変換.
vfncvt.rod.f.f.w vd, vs2, vm    # 倍幅浮動小数点をodd方向の丸めに使用して単一幅の浮動小数点に変換.</p>
</dd>
</dl>
<p>これらの命令は、他の幅縮小命令(&lt;&lt;sec-narrowing&gt;&gt;参照)と同様に、ベクトルレジスタのオーバーラップに制約があります。</p>
<p>NOTE: 浮動小数点型幅拡張変換のフルセットは、単一の命令としてはサポートされていません。
変換は半減ステップのシーケンスで実装できます。
最後の半減ステップ以外が round-towards-odd (<cite>vfncvt.rod.f.f.w</cite>) を使用した場合、結果は同等に丸められ、同じ例外フラグが立てられます。
最後のステップだけは、希望する丸め方向を使用する必要があります。</p>
</div>
</div>
<div class="section" id="id173">
<h2>ベクトルリダクション操作<a class="headerlink" href="#id173" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトルリダクションは、ベクトルレジスタ群の要素と、ベクトルレジスタの要素0に保持されているスカラを受け取り、
何らかの二項演算子を用いてリダクションを行い、ベクトルレジスタの要素0にスカラの結果を出力するものです。
スカラの入出力オペランドは、ベクトルレジスタ群ではなく、単一のベクトルレジスタの要素0に保持されるため、LMULの設定に関わらず、
どのベクトルレジスタもベクトルリダクションのスカラのソースまたは書き込みレジスタとなります。</p>
<p>書き込みのベクトルレジスタは、マスクレジスタを含むソースオペランドとオーバーラップすることができます。</p>
<p>NOTE: リダクションは、スカラプロセッサとのデカップリングの損失を回避し、
スカラユニットでサポートされていない将来の型で将来のポリモーフィックな使用をサポートするために、
スカラオペランドと結果をベクトルレジスタの要素0に読み書きします。</p>
<p>ソースベクトルレジスタグループの非アクティブな要素はリダクションから除外されますが、
スカラオペランドはマスク値にかかわらず常に含まれます。</p>
<p>書き込みベクトルレジスタ内の他の要素(0 &lt; index &lt; VLEN/SEW)は末尾とみなされ、
現在のtail agnostic/undisturbedポリシで管理されます。</p>
<p><a href="#id174"><span class="problematic" id="id175">`</span></a>vl`=0の場合は、操作は行われず、書き込みレジスタは更新されません。</p>
<p>ベクトルリダクション命令の例外は、常に <cite>vstart</cite> が0で報告されます。
ベクトルリダクション操作は、<cite>vstart</cite> が 0 でない場合、不正な命令の例外を発生させます。</p>
<p>縮小演算のアセンブラ構文は、<cite>vredop.vs</cite> です。<cite>.vs</cite> は、第1オペランドがベクトルレジスタグループで、
第 2 オペランドがベクトルレジスタの要素 0 に格納されたスカラであることを表します。</p>
<p>[[sec-vector-integer-reduce]]
.. // === Vector Single-Width Integer Reduction Instructions</p>
<div class="section" id="id176">
<h3>ベクトル単一幅整数リダクション命令<a class="headerlink" href="#id176" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>単一幅のリダクション命令のオペランドと結果は、すべて同じSEW幅になります。
算術加算ではオーバーフローは丸められます。</p>
<dl>
<dt>::</dt><dd><blockquote>
<div><p># 単純なリダクション命令. [*]は全てのアクティブな要素を意味する:</p>
</div></blockquote>
<p>vredsum.vs  vd, vs2, vs1, vm   # vd[0] =  sum( vs1[0] , vs2[*] )
vredmaxu.vs vd, vs2, vs1, vm   # vd[0] = maxu( vs1[0] , vs2[*] )
vredmax.vs  vd, vs2, vs1, vm   # vd[0] =  max( vs1[0] , vs2[*] )
vredminu.vs vd, vs2, vs1, vm   # vd[0] = minu( vs1[0] , vs2[*] )
vredmin.vs  vd, vs2, vs1, vm   # vd[0] =  min( vs1[0] , vs2[*] )
vredand.vs  vd, vs2, vs1, vm   # vd[0] =  and( vs1[0] , vs2[*] )
vredor.vs   vd, vs2, vs1, vm   # vd[0] =   or( vs1[0] , vs2[*] )
vredxor.vs  vd, vs2, vs1, vm   # vd[0] =  xor( vs1[0] , vs2[*] )</p>
</dd>
</dl>
<p>[[sec-vector-integer-reduce-widen]]
.. // === Vector Widening Integer Reduction Instructions</p>
</div>
<div class="section" id="id177">
<h3>ベクトル幅拡張整数リダクション命令<a class="headerlink" href="#id177" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>符号なしの <cite>vwredsumu.vs</cite> 命令は、SEW幅のベクトル要素をゼロ拡張してから合計し、
次に2*SEW幅のスカラー要素を加え、その結果を2*SEW幅のスカラー要素に格納します。</p>
<p><cite>vwredsum.vs</cite> 命令は、SEW幅のベクトル要素を符号拡張してから加算します。</p>
<dl>
<dt>::</dt><dd><blockquote>
<div><p># 2倍幅での符号なしリダクション加算を倍幅でアキュムレートする</p>
</div></blockquote>
<p>vwredsumu.vs vd, vs2, vs1, vm   # 2*SEW = 2*SEW + sum(zero-extend(SEW))</p>
<blockquote>
<div><p># 符号付きリダクション加算を倍幅でアキュムレートする</p>
</div></blockquote>
<p>vwredsum.vs  vd, vs2, vs1, vm   # 2*SEW = 2*SEW + sum(sign-extend(SEW))</p>
</dd>
</dl>
<p>[[sec-vector-float-reduce]]
.. // === Vector Single-Width Floating-Point Reduction Instructions</p>
</div>
<div class="section" id="id178">
<h3>ベクトル単一幅浮動小数点リダクション命令<a class="headerlink" href="#id178" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="simple">
<dt>::</dt><dd><p># 単純なリダクション
vfredosum.vs vd, vs2, vs1, vm # 順序付き加算
vfredusum.vs vd, vs2, vs1, vm # 順序無し加算
vfredmax.vs  vd, vs2, vs1, vm # 最大値
vfredmin.vs  vd, vs2, vs1, vm # 最小値</p>
</dd>
</dl>
<p>NOTE: 過去のアセンブラニーモニックである <cite>vfredsum</cite> は <cite>vfredsum</cite> へのエイリアスとして残されています。</p>
<div class="section" id="id179">
<h4>ベクトル順序付き単一幅浮動小数点リダクション加算命令<a class="headerlink" href="#id179" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><cite>vfredosum</cite> 命令は、<cite>vs1[0]</cite> のスカラーから順に、
浮動小数点値を要素順に合計しなければなりません--つまり、以下のように計算を行います。</p>
<dl class="simple">
<dt>::</dt><dd><p>vd[0] = <cite>(((vs1[0] + vs2[0]) + vs2[1]) + ...) + vs2[vl-1]</cite></p>
</dd>
</dl>
<p>ここで各加算は、例外フラグの発生や特別な値の生成・伝搬という点で、スカラ浮動小数点演算命令と同じ動作をします。</p>
<p>NOTE: 順序付きリダクションはコンパイラの自動ベクトル化に対応していますが、順序のないFP加算はより高速な実装を可能にします。</p>
<p>演算がマスクされている場合(<cite>vm=0</cite>)、マスクされていない要素は結果や例外フラグに影響を与えません。</p>
<p>NOTE: アクティブな要素がない場合、加算は行われず、<cite>vs1[0]</cite> のスカラは、NaN値の正規化や例外フラグの設定を行うことなく、単に書き込みレジスタにコピーされます。
この動作は、スカラの加算ループを自動ベクトル化する際のNaN、例外、丸めの処理と同一です。</p>
</div>
<div class="section" id="id180">
<h4>ベクトル順序無し単一幅浮動小数点リダクション加算命令<a class="headerlink" href="#id180" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>順序無しリダクション命令である <cite>vfredusum</cite> は、リダクションを実行する際の実装の自由度を高めます。</p>
<p>実装では、ソースのベクトルレジスタ群(<cite>vs2</cite>)とソースのスカラー値(<cite>vs1[0]</cite>)の要素を入力とし
バイナリ演算子ノードで構成されるリダクションツリーと同等の結果を生成する必要があります。
ツリー内の各演算子は、2つの入力を受け入れ、1つの結果を生成します。
各演算子は、まず、RISC-Vのスカラ浮動小数点加算として、指数の範囲と精度が無限大の正確な和を計算し、
次に、この正確な和を、SEWで示される要素浮動小数点フォーマットと少なくとも同じ範囲と精度を持つ浮動小数点フォーマットに変換し、
現在アクティブな浮動小数点ダイナミック丸めモードを用いて丸めます。
各演算子の結果には、異なる浮動小数点の範囲と精度を選択することができます。
一方の入力が、マスクされた要素やアクティブなベクトル長を超えた要素からのみ得られるノードは、
その入力を適切なEEWの加法単位元として扱うか、あるいは単に他方の入力をその出力にコピーすることができます。
ツリーのルートノードからの丸められた結果は、SEW で示される標準的な浮動小数点フォーマットに変換されます(動的丸めモードを使用して再度丸められます)。
実装では、最終結果に加法単位元を加えることができます。</p>
<p>加法単位元は、切り捨て(-{inf}方向)の場合は+0.0、その他の丸め方の場合は-0.0です。</p>
<p>リダクションツリーの構造は、<cite>vtype</cite> と <cite>vl</cite> に与えられた値に対して決定的でなければなりません。</p>
<p>NOTE: この定義の結果として、要素がアクティブでない場合、実装はNaNペイロードをリダクションツリーに伝搬させる必要はありません。
特に、アクティブな要素がなく、スカラー入力がNaNの場合、実装はNaNを正規化し、NaNがシグナリングの場合は、無効な例外フラグを設定することが許可されています。
また、<cite>vfredosum</cite> のように、元のNaNを通過させ、例外フラグを設定しないことも可能です。</p>
<p>NOTE: <cite>vfredosum</cite> 命令は、 <cite>vfredusum</cite> としても有効です。</p>
</div>
<div class="section" id="id181">
<h4>ベクトル単一幅浮動小数点最大・最小リダクション<a class="headerlink" href="#id181" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>NOTE: 浮動小数点最大・最小リダクション命令は、演算の順序に関係なく常に同じ結果と同じ例外フラグを設定しなければなりません。</p>
<p>NOTE: アクティブな要素が一つもない場合、<cite>vs1[0]</cite> のスカラ値が単純に書き込みレジスタにコピーされます。
その際、例外フラグは設定されず、NaNの処理も行われません。</p>
<p>[[sec-vector-float-reduce-widen]]
.. // === Vector Widening Floating-Point Reduction Instructions</p>
</div>
</div>
<div class="section" id="id182">
<h3>ベクトル幅拡張浮動小数点リダクション命令<a class="headerlink" href="#id182" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>リダクション加算命令における幅拡張の形式は、倍幅のデータの読み書きを行います。。</p>
<dl class="simple">
<dt>::</dt><dd><p># 単純なリダクション
vfwredosum.vs vd, vs2, vs1, vm # 順序付きリダクション加算
vfwredusum.vs vd, vs2, vs1, vm # 順序なしリダクション加算命令</p>
</dd>
</dl>
<p>NOTE: 古いアセンブリニーモニックである <cite>vfwredsum</cite> は <cite>vfwredusum</cite> のエイリアスとして残されています。</p>
<p>SEW幅の要素のリダクション操作は単一幅で行われ、<cite>vs2</cite> の要素は2*SEWに拡張されて2*SEWビットのアキュムレータに加算されます。</p>
<p>NOTE: <cite>vfwredosum.vs</cite> 命令は非アクティブな要素とNaNのペイロードについては、<cite>vfredosum.vs</cite> と同様に扱います;
<cite>vfwredusum.vs</cite>  は <cite>vfredusum.vs</cite> と同様に動作します。</p>
<p>[[sec-vector-mask]]
.. // == Vector Mask Instructions</p>
</div>
</div>
<div class="section" id="id183">
<h2>ベクトルマスク命令<a class="headerlink" href="#id183" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトルレジスタに格納されているマスクを操作するための命令がいくつか提供されています。</p>
<p>[[sec-mask-register-logical]]
.. // === Vector Mask-Register Logical Instructions</p>
<div class="section" id="id184">
<h3>ベクトルマスクレジスタ論理命令<a class="headerlink" href="#id184" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ベクトルマスクレジスタ論理命令は、マスクレジスタに対して演算を実行します。
マスクレジスタの各要素は1ビットであり、従ってこれらの命令は <cite>vtype</cite> フィールド内の <cite>vlmul</cite>  の設定に関係なく単一のベクトルレジスタを操作します。
これらの命令は <cite>vlmul</cite>  の設定を変更しません。
書き込みベクトルレジスタはソースベクトルレジスタと同一である可能性があります。</p>
<p>他のベクトル命令と同様に、<cite>vstart</cite> インデックスよりも小さな要素は変更されず、命令実行後には <cite>vstart</cite>  の値は0にリセットされます。
ベクトルマスク論理命令は常にマスクは適用されず、従って非アクティブ要素はありませんん。<cite>vm=0</cite> に相当するエンコーディングは予約されています。
<cite>vl</cite> 以降のマスク要素、つまり末尾エレメントは常にtail-agnosticポリシに基づいて更新されます。</p>
<dl class="simple">
<dt>::</dt><dd><p>vmand.mm vd, vs2, vs1     # vd.mask[i] =   vs2.mask[i] &amp;&amp;  vs1.mask[i]
vmnand.mm vd, vs2, vs1    # vd.mask[i] = !(vs2.mask[i] &amp;&amp;  vs1.mask[i])
vmandnot.mm vd, vs2, vs1  # vd.mask[i] =   vs2.mask[i] &amp;&amp; !vs1.mask[i]
vmxor.mm  vd, vs2, vs1    # vd.mask[i] =   vs2.mask[i] ^^  vs1.mask[i]
vmor.mm  vd, vs2, vs1     # vd.mask[i] =   vs2.mask[i] ||  vs1.mask[i]
vmnor.mm  vd, vs2, vs1    # vd.mask[i] = !(vs2.mask[i] ||  vs1.mask[i])
vmornot.mm  vd, vs2, vs1  # vd.mask[i] =   vs2.mask[i] || !vs1.mask[i]
vmxnor.mm vd, vs2, vs1    # vd.mask[i] = !(vs2.mask[i] ^^  vs1.mask[i])</p>
</dd>
</dl>
<p>一般的に使用されるマスク論理操作のために、いくつかのアセンブラ疑似命令が定義されています。</p>
<dl class="simple">
<dt>::</dt><dd><p>vmmv.m vd, vs  =&gt; vmand.mm vd, vs, vs  # Copy mask register
vmclr.m vd     =&gt; vmxor.mm vd, vd, vd   # Clear mask register
vmset.m vd     =&gt; vmxnor.mm vd, vd, vd  # Set mask register
vmnot.m vd, vs =&gt; vmnand.mm vd, vs, vs  # Invert bits</p>
</dd>
</dl>
<p>NOTE: vmmv.m は以前は vmcpy.m と呼ばれていましたが、新しいレイアウトでは、
ビットが解釈無しにコピーされるため &quot;mv&quot;と読んだ方が整合性があります。
vmcpy.m アセンブラ疑似命令は互換性のために残されています。</p>
<p>8つのマスク論理命令は2つの入力マスクに対する任意の16個のバイナリ論理演算を実行することができます。</p>
<p>[cols=&quot;1,1,1,1,12&quot;]
<a href="#id232"><span class="problematic" id="id233">|===
4+|</span></a> inputs |</p>
<div class="line-block">
<div class="line">0 | 0 | 1 | 1 | src1</div>
<div class="line">0 | 1 | 0 | 1 | src2</div>
</div>
<p><a href="#id185"><span class="problematic" id="id186">|</span></a>===</p>
<p>[cols=&quot;1,1,1,1,6,6&quot;]
<a href="#id234"><span class="problematic" id="id235">|===
4+|</span></a> output  | instruction | pseudoinstruction</p>
<div class="line-block">
<div class="line">0 | 0 | 0 | 0 | vmxor.mm vd, vd, vd         | vmclr.m vd</div>
<div class="line">1 | 0 | 0 | 0 | vmnor.mm vd, src1, src2     |</div>
<div class="line">0 | 1 | 0 | 0 | vmandnot.mm vd, src2, src1  |</div>
<div class="line">1 | 1 | 0 | 0 | vmnand.mm vd, src1, src1    | vmnot.m vd, src1</div>
<div class="line">0 | 0 | 1 | 0 | vmandnot.mm vd, src1, src2  |</div>
<div class="line">1 | 0 | 1 | 0 | vmnand.mm vd, src2, src2    | vmnot.m vd, src2</div>
<div class="line">0 | 1 | 1 | 0 | vmxor.mm vd, src1, src2     |</div>
<div class="line">1 | 1 | 1 | 0 | vmnand.mm vd, src1, src2    |</div>
<div class="line">0 | 0 | 0 | 1 | vmand.mm vd, src1, src2     |</div>
<div class="line">1 | 0 | 0 | 1 | vmxnor.mm vd, src1, src2    |</div>
<div class="line">0 | 1 | 0 | 1 | vmand.mm vd, src2, src2     | vmmv.m vd, src2</div>
<div class="line">1 | 1 | 0 | 1 | vmornot.mm vd, src2, src1   |</div>
<div class="line">0 | 0 | 1 | 1 | vmand.mm vd, src1, src1     | vmmv.m vd, src1</div>
<div class="line">1 | 0 | 1 | 1 | vmornot.mm vd, src1, src2   |</div>
<div class="line">1 | 1 | 1 | 1 | vmxnor.mm vd, vd, vd        | vmset.m vd</div>
</div>
<p><a href="#id187"><span class="problematic" id="id188">|</span></a>===</p>
<p>NOTE: ベクトルマスク論理命令は、使用前に値を <cite>v0</cite>  に移すことで、プレディケートレジスタの数を効果的に拡張するために、
次のマスクされたベクトル演算と簡単に融合できるように設計されています。</p>
</div>
<div class="section" id="pop-vpopc">
<h3>ベクトルマスクPopカウント <cite>vpopc</cite><a class="headerlink" href="#pop-vpopc" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="simple">
<dt>::</dt><dd><p>vpopc.m rd, vs2, vm</p>
</dd>
</dl>
<p>ソースオペランドは、 &lt;&lt;sec-mask-register-layout&gt;&gt; 節で説明されているように、マスクレジスタの値を保持する単一のベクトルレジスタです。</p>
<p><cite>vpopc.m</cite> 命令は、ベクトルソースマスクレジスタのアクティブ要素のうち、値が1であるマスク要素の数を数え、その結果をスカラの <cite>x</cite>  レジスタに書き込みます。</p>
<p>この操作はマスク下で行うことができ、その場合はマスクされた要素のみがカウントされます。</p>
<dl class="simple">
<dt>::</dt><dd><p>vpopc.m rd, vs2, v0.t # x[rd] = sum__i ( vs2.mask[i] &amp;&amp; v0.mask[i] )</p>
</dd>
</dl>
<p><cite>vpopc.m</cite> 上の例外は、常に <cite>vstart</cite> が 0 で通知されます。
<cite>vpopc</cite> 命令は、<cite>vstart</cite> が0でない場合、不正命令例外を発生させます。</p>
</div>
<div class="section" id="vfirst-find-first-set">
<h3><cite>vfirst</cite> find-first-set マスクビット命令<a class="headerlink" href="#vfirst-find-first-set" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="simple">
<dt>::</dt><dd><p>vfirst.m rd, vs2, vm</p>
</dd>
</dl>
<p><cite>vfirst</cite> 命令は、ソースマスクベクトルの中から、値1を持つ最も低い番号のアクティブな要素を見つけ、その要素のインデックスをGPRに書き込みます。
値が1のアクティブな要素がない場合は、-1が書き込まれます。</p>
<p>ベクトルの長さはどのような実装でも2^(XLEN-1)^ を超えることはありませんので、ソフトウェアは負の値(最上位ビットの設定)があれば、
要素が見つからないと仮定することができます。</p>
<p><cite>vfirst</cite> の例外は常に 0 の <cite>vstart</cite> で報告されます。
<cite>vstart</cite> が 0 でない場合、<cite>vfirst</cite> 命令は不正命令例外を発生させます。</p>
</div>
<div class="section" id="vmsbf-m-set-before-first">
<h3><cite>vmsbf.m</cite> set-before-firstマスクビット<a class="headerlink" href="#vmsbf-m-set-before-first" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl>
<dt>::</dt><dd><blockquote>
<div><p>vmsbf.m vd, vs2, vm</p>
</div></blockquote>
<p># 例</p>
<blockquote>
<div><p>7 6 5 4 3 2 1 0   要素番号</p>
<dl class="simple">
<dt>1 0 0 1 0 1 0 0   v3 の値</dt><dd><p>vmsbf.m v2, v3</p>
</dd>
</dl>
<p>0 0 0 0 0 0 1 1   v2 の値</p>
<dl class="simple">
<dt>1 0 0 1 0 1 0 1   v3 の値</dt><dd><p>vmsbf.m v2, v3</p>
</dd>
</dl>
<p>0 0 0 0 0 0 0 0   v2</p>
<dl class="simple">
<dt>0 0 0 0 0 0 0 0   v3 値</dt><dd><p>vmsbf.m v2, v3</p>
</dd>
</dl>
<p>1 1 1 1 1 1 1 1   v2</p>
<p>1 1 0 0 0 0 1 1   v0 の値
1 0 0 1 0 1 0 0   v3 の値</p>
<blockquote>
<div><p>vmsbf.m v2, v3, v0.t</p>
</div></blockquote>
<p>0 1 x x x x 1 1   v2 の値</p>
</div></blockquote>
</dd>
</dl>
<p><cite>vmsbf.m</cite> 命令は、マスク・レジスタを入力とし、結果をマスク・レジスタに書き込みます。
この命令は、1である最初のソース要素の前にあるすべてのアクティブなマスク要素に1を書き込み、
その要素とそれに続くすべてのアクティブな要素に0を書き込みます。
ソースベクトルにセットビットがない場合、書き込みレジスタのすべてのアクティブ要素に1が書き込まれます。</p>
<p>書き込みマスクレジスタの末尾要素はtail-agnosticポリシに基づいて更新されます。</p>
<p><cite>vmsbf.m</cite> の例外は、常に <cite>vstart</cite> =0の状態で報告されます。
<cite>vmsbf</cite> 命令は、<cite>vstart</cite> が 0 でない場合、不正命令例外を発生します。</p>
<p>書き込みレジスタはソースレジスタをオーバラップすることは出来ません。
マスク付き命令の場合、<cite>v0</cite> マスクレジスタとオーバラップすることは出来ません。</p>
</div>
<div class="section" id="vmsif-m-set-including-first">
<h3><cite>vmsif.m</cite> set-including-first マスクビット命令<a class="headerlink" href="#vmsif-m-set-including-first" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ベクトルset-including-first命令はset-before-first命令と似ていますが、
セットビットを含めるところが異なります。</p>
<dl>
<dt>::</dt><dd><blockquote>
<div><p>vmsif.m vd, vs2, vm</p>
</div></blockquote>
<p># 例</p>
<blockquote>
<div><p>7 6 5 4 3 2 1 0   要素番号</p>
<dl class="simple">
<dt>1 0 0 1 0 1 0 0   v3 の値</dt><dd><p>vmsif.m v2, v3</p>
</dd>
</dl>
<p>0 0 0 0 0 1 1 1   v2 の値</p>
<dl class="simple">
<dt>1 0 0 1 0 1 0 1   v3 の値</dt><dd><p>vmsif.m v2, v3</p>
</dd>
</dl>
<p>0 0 0 0 0 0 0 1   v2</p>
<p>1 1 0 0 0 0 1 1   v0 の値
1 0 0 1 0 1 0 0   v3 の値</p>
<blockquote>
<div><p>vmsif.m v2, v3, v0.t</p>
</div></blockquote>
<p>1 1 x x x x 1 1   v2 の値</p>
</div></blockquote>
</dd>
</dl>
<p>書き込みマスクレジスタの末尾要素はtail-agnosticポリシに基づいて更新されます。</p>
<p><cite>vmsif.m</cite> の例外は、常に <cite>vstart</cite> =0の状態で報告されます。
<cite>vmsif</cite> 命令は、<cite>vstart</cite> が 0 でない場合、不正命令例外を発生します。</p>
<p>書き込みレジスタはソースレジスタをオーバラップすることは出来ません。
マスク付き命令の場合、<cite>v0</cite> マスクレジスタとオーバラップすることは出来ません。</p>
</div>
<div class="section" id="vmsof-m-set-only-first">
<h3><cite>vmsof.m</cite> set-only-first マスクビット命令<a class="headerlink" href="#vmsof-m-set-only-first" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>set-only-firstベクトル命令はset-before-first命令と似ていますが、
ビットがセットされている最初の要素のみを設定するところが異なります。</p>
<dl>
<dt>::</dt><dd><blockquote>
<div><p>vmsof.m vd, vs2, vm</p>
</div></blockquote>
<p># 例</p>
<blockquote>
<div><p>7 6 5 4 3 2 1 0   要素番号</p>
<dl class="simple">
<dt>1 0 0 1 0 1 0 0   v3 の値</dt><dd><p>vmsof.m v2, v3</p>
</dd>
</dl>
<p>0 0 0 0 0 1 0 0   v2 の値</p>
<dl class="simple">
<dt>1 0 0 1 0 1 0 1   v3 の値</dt><dd><p>vmsof.m v2, v3</p>
</dd>
</dl>
<p>0 0 0 0 0 0 0 1   v2</p>
<p>1 1 0 0 0 0 1 1   v0 の値
1 1 0 1 0 1 0 0   v3 の値</p>
<blockquote>
<div><p>vmsof.m v2, v3, v0.t</p>
</div></blockquote>
<p>0 1 x x x x 0 0   v2 の値</p>
</div></blockquote>
</dd>
</dl>
<p>書き込みマスクレジスタの末尾要素はtail-agnosticポリシに基づいて更新されます。</p>
<p><cite>vmsof.m</cite> の例外は、常に <cite>vstart</cite> =0の状態で報告されます。
<cite>vmsof</cite> 命令は、<cite>vstart</cite> が 0 でない場合、不正命令例外を発生します。</p>
<p>書き込みレジスタはソースレジスタをオーバラップすることは出来ません。
マスク付き命令の場合、<cite>v0</cite> マスクレジスタとオーバラップすることは出来ません。</p>
</div>
<div class="section" id="id189">
<h3>ベクトルマスク命令の使用例<a class="headerlink" href="#id189" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下はベクトル化されたデータに依存するループ終了コードです。</p>
<dl class="simple">
<dt>::</dt><dd><p>include::example/strcpy.s[lines=4..-1]</p>
</dd>
</dl>
<dl class="simple">
<dt>::</dt><dd><p>include::example/strncpy.s[lines=4..-1]</p>
</dd>
</dl>
</div>
<div class="section" id="iota">
<h3>ベクトルIota命令<a class="headerlink" href="#iota" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><cite>viota.m</cite> 命令は、ソースベクトルマスクレジスタを読み込み、書き込みベクトルレジスタグループの各要素に
マスク・レジスタの要素のうち、インデックスがその要素よりも小さい要素のすべてのビットの合計、
すなわち、マスク値のパラレルプレフィックス和を書き込みます。</p>
<p>この命令はマスクを使用することができます。この場合アクティブな要素のみが
加算に使用されます。</p>
<dl>
<dt>::</dt><dd><p>viota.m vd, vs2, vm</p>
<p># 例</p>
<blockquote>
<div><p>7 6 5 4 3 2 1 0   要素数</p>
<dl class="simple">
<dt>1 0 0 1 0 0 0 1   v2 の値</dt><dd><p>viota.m v4, v2 # Unmasked</p>
</dd>
</dl>
<p>2 2 2 1 1 1 1 0   v4 の結果</p>
<p>1 1 1 0 1 0 1 1   v0 の値
1 0 0 1 0 0 0 1   v2 の値
2 3 4 5 6 7 8 9   v4 の値</p>
<blockquote>
<div><p>viota.m v4, v2, v0.t # Masked, vtype.vma=0</p>
</div></blockquote>
<p>1 1 1 5 1 7 1 0   v4 の値</p>
</div></blockquote>
</dd>
</dl>
<p>SEWが結果の値よりも大きい場合は、結果値をゼロ拡張して出力要素を埋めます。
結果値が出力先のSEWをオーバーフローする場合は、最下位のSEWビットが保持されます。</p>
<p><cite>viota.m</cite>  の例外は、常に <cite>vstart</cite> =0として報告され、例外ハンドラの後に再開するときは、常に最初から実行が再開されます。
<cite>vstart</cite> が 0 でない場合は、不正命令例外が発生します。</p>
<p>書き込みレジスタグループはソース・レジスタと重なることはできず、マスクされている場合はマスク・レジスタ (<cite>v0</cite>) と重なることはできません。</p>
<p>NOTE: これらの制約は2つの理由で存在します。
1つ目の理由は、時間的に長いベクトル・レジスタを持ち、ベクトル・レジスタのリネームを行わない実装において、WARハザードの回避を容易にするためです。
第二に、例外が単純化された後に実行を再開することを可能にするためです。</p>
<p><cite>viota.m</cite> 命令は、メモリ・スキャッタ命令(インデックス・ストア)と組み合わせて、
ベクトル圧縮機能を実行することができます。</p>
<dl>
<dt>::</dt><dd><blockquote>
<div><blockquote>
<div><p># 入力メモリ配列から、非ゼロの要素を圧縮して出力メモリ配列に格納する</p>
</div></blockquote>
<p>#
# size_t compact_non_zero(size_t n, const int* in, int* out)
# {
#   size__t i;
#   size__t count = 0;
#   int <a href="#id190"><span class="problematic" id="id191">*</span></a>p = out;
#
#   for (i=0; i&lt;n; i++)
#   {
#       const int v = <a href="#id192"><span class="problematic" id="id193">*</span></a>in++;
#       if (v != 0)
#           <a href="#id194"><span class="problematic" id="id195">*</span></a>p++ = v;
#   }
#
#   return (size__t) (p - out);
# }
#
# a0 = n
# a1 = &amp;in
# a2 = &amp;out</p>
</div></blockquote>
<dl>
<dt>compact_non_zero:</dt><dd><p>li a6, 0                      # 非ゼロ要素のカウンタをクリアする</p>
</dd>
<dt>loop:</dt><dd><p>vsetvli a5, a0, e32, m8, ta, ma   # 32-bit整数
vle32.v v8, (a1)               # 入力ベクトルをロードする</p>
<blockquote>
<div><p>sub a0, a0, a5               # ロードした要素数を減算する
slli a5, a5, 2               # 4倍する</p>
</div></blockquote>
<dl class="simple">
<dt>vmsne.vi v0, v8, 0             # 非ゼロの場所を特定する</dt><dd><p>add a1, a1, a5               # 入力ポインタを進める</p>
</dd>
</dl>
<p>vpopc.m a5, v0                 # v0中の非ゼロ値を数える
viota.m v16, v0                # アクティブ要素の出力オフセットを取得する</p>
<blockquote>
<div><p>add a6, a6, a5               # 要素数を加算する</p>
</div></blockquote>
<dl>
<dt>vsll.vi v16, v16, 2, v0.t      # オフセットを4バイト分乗算する</dt><dd><p>slli a5, a5, 2               # 非ゼロの要素の数を4バイト分乗算する</p>
</dd>
<dt>vsuxei32.v v8, (a2), v16, v0.t # スケールしたviotaの結果をマスクに基づいてメモリに書き込む</dt><dd><p>add a2, a2, a5               # 出力ポインタを進める
bnez a0, loop                # これ以上あるか？</p>
<p>mv a0, a6                    # カウント数を返す
ret</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p><cite>vid.v</cite> 命令は、各要素のインデックスを、0から <cite>vl</cite> -1までの書き込みベクトルレジスタグループに書き込みます。</p>
<dl class="simple">
<dt>::</dt><dd><p>vid.v vd, vm  # 要素のインデックスを書き込みレジスタに書き込む</p>
</dd>
</dl>
<p>この命令はマスクを使用することができます。</p>
<p>この命令の <cite>vs2</cite>  フィールドは <cite>v0</cite> を設定しなければなりません、
そうでない場合のエンコーディングは _予約されています_。</p>
<p>結果がSEWよりも小さいビット幅である場合、ゼロ拡張して書き込み要素に書き込まれます。
結果がSEWよりも大きい場合、下位のSEWビットが保持されます。</p>
<p>NOTE: マイクロアーキテクチャ上では、<cite>vid.v</cite> 命令は <cite>viota.m</cite> 命令と
同じデータパスを使用して、暗黙的なマスクソースを使用することで実装することができます。</p>
<p>[[sec-vector-permute]]
.. // == Vector Permutation Instructions</p>
</div>
</div>
<div class="section" id="id196">
<h2>ベクトル組み合わせ命令<a class="headerlink" href="#id196" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトルレジスタ内の要素を移動させるために、さまざまな並べ替え命令が用意されています。</p>
<div class="section" id="id197">
<h3>整数スカラ移動命令<a class="headerlink" href="#id197" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>整数スカラ読み込み・書き込み命令は、スカラ <cite>x</cite> レジスタとベクトルレジスタの要素0との間で1つの値を転送します。
この命令はLMULやベクトルレジスタグループを無視します。</p>
<dl class="simple">
<dt>::</dt><dd><p>vmv.x.s rd, vs2  # x[rd] = vs2[0] (vs1=0)
vmv.s.x vd, rs1  # vd[0] = x[rs1] (vs2=0)</p>
</dd>
</dl>
<p><cite>vmv.x.s</cite> は SEW 幅の単一要素をソースベクトルレジスタのインデックス0から書き込み整数レジスタにコピーする命令です。
SEW &gt; XLENの場合、最下位のXLENビットが転送され、上位のSEW-XLENビットは無視されます。
SEW &lt; XLENの場合、値はXLENビットに符号拡張されます。</p>
<p><cite>vmv.s.x</cite> 命令は、スカラ整数レジスタを書き込みベクトルレジスタの要素 0 にコピーします。
SEW &lt; XLENの場合、最下位のビットがコピーされ、XLEN-SEWの上位ビットは無視されます。
SEW &gt; XLENの場合、値はSEWビットに符号拡張されます。 書き込みベクトルレジスタ内の他の要素 ( 0 &lt; index &lt; VLEN/SEW ) は
現在の末尾agnostic/undisturbedポリシを使用して、末尾要素として扱われます。
<cite>vstart</cite> {ge}の場合  <cite>vl</cite> の場合、操作は行われず、書き込みレジスタは更新されません。</p>
<p>NOTE: 結論として、 <cite>vl`=0の時は `vstart</cite> に関わらず、書き込みベクトルレジスタのどの要素も更新されません。</p>
<p><cite>vmv.x.s</cite> と <cite>vmv.s.x</cite> のマスク付きバージョン (<cite>vm=0</cite>) に対応するエンコーディングは予約されています。</p>
<div class="section" id="id198">
<h4>浮動小数点スカラ移動命令<a class="headerlink" href="#id198" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>浮動小数点スカラの読み込み・書き込み命令は、スカラ <cite>f</cite> レジスタとベクトルレジスタの要素0との間で1つの値を転送します。
この命令は、LMULとベクトルレジスタグループを無視します。</p>
<dl class="simple">
<dt>::</dt><dd><p>vfmv.f.s rd, vs2  # f[rd] = vs2[0] (rs1=0)
vfmv.s.f vd, rs1  # vd[0] = f[rs1] (vs2=0)</p>
</dd>
</dl>
<p><cite>vfmv.f.s</cite> は、SEW幅の要素を1つだけ、コピー元のベクトルレジスタの要素0からコピー先のスカラ浮動小数点レジスタにコピーします。</p>
<p><cite>vfmv.s.f</cite> 命令は、スカラ浮動小数点レジスタを、書き込みベクトルレジスタの要素0にコピーします。
書き込みベクトルレジスタの他の要素(0 &lt; index &lt; VLEN/SW)は、現在のTail-agnostic/Undisturbedポリシを用いて、末尾要素として扱われます。
もし、<cite>vstart</cite> {ge} <cite>vl</cite> の場合、操作は行われず、書き込みレジスタは更新されません。</p>
<p>NOTE: 結論として、 <cite>vl`=0の時は `vstart</cite> に関わらず、書き込みベクトルレジスタのどの要素も更新されません。</p>
<p><cite>vfmv.f.s</cite> と <cite>vfmv.s.f</cite>  のマスクバージョン(<cite>vm=0</cite>)に対応するエンコーディングは予約されています。</p>
</div>
</div>
<div class="section" id="id199">
<h3>ベクトルスライド命令<a class="headerlink" href="#id199" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>スライド命令は、ベクトルレジスタグループの要素を上下に移動させます。</p>
<p>NOTE: スライド操作は、任意のレジスタギャザー命令を使用するよりもはるかに効率的に実装できます。
実装では、特定のオフセット値を <cite>vslideup</cite> および <cite>vslidedown</cite> に最適化することができます。
特に、2の累乗オフセットは、他のオフセットよりも大幅に高速に動作する可能性があります。</p>
<p>すべての <cite>vslideup</cite>, <cite>vslidedown</cite>, <cite>v[f]slide1up</cite>, <cite>v[f]slide1down</cite> 命令において、<cite>vstart</cite> {ge} <cite>vl</cite> の場合、
この命令は操作を行わず、書き込みベクトルレジスタを変更せずに残します。</p>
<p>NOTE: 結論として、 <cite>vl`=0の時は `vstart</cite>  に関わらず、書き込みベクトルレジスタのどの要素も更新されません。</p>
<p>末尾要素については、Tail agnostic/undisturbedポリシに基づいて適用されます。</p>
<p>スライド命令はマスクされていて、マスク要素 _i_ が、_書き込み_ 要素 _i_ を書き込むかどうかを制御している場合があります。
非アクティブな要素については、Mask undisturbed/agnosticポリシに従います。</p>
<div class="section" id="id200">
<h4>ベクトルスライドアップ命令<a class="headerlink" href="#id200" title="このヘッドラインへのパーマリンク">¶</a></h4>
<dl class="simple">
<dt>::</dt><dd><p>vslideup.vx vd, vs2, rs1, vm        # vd[i+rs1] = vs2[i]
vslideup.vi vd, vs2, uimm, vm       # vd[i+uimm] = vs2[i]</p>
</dd>
</dl>
<p><cite>vslideup</cite> では、<cite>vl</cite> の値で、書き込みレジスタの最大要素数を指定します。
書き込みレジスタの開始インデックス (_OFFSET_) は、<cite>rs1</cite> で指定された <cite>x</cite> レジスタの符号なし整数、
または XLEN ビットにゼロ拡張された 5 ビットの即値のいずれかを使用して指定できます。
XLEN &gt; SEWの場合、_OFFSET_ はSEWビットに切り捨てられません。
マスキングされておらず、かつ、 _OFFSET_ &lt; <cite>vl</cite> であれば、 _OFFSET_ から <cite>vl</cite> -1 までの出力要素が書き込まれます。</p>
<dl>
<dt>::</dt><dd><blockquote>
<div><p>vslideup の書き込みレジスタ要素の動作</p>
<p>OFFSET is amount to slideup, either from x register or a 5-bit immediate</p>
<blockquote>
<div><p>0 &lt;  i &lt; max(vstart, OFFSET)  Unchanged</p>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>max(vstart, OFFSET) &lt;= i &lt; vl                   vd[i] = vs2[i-OFFSET] if v0.mask[i] enabled</dt><dd><p>vl &lt;= i &lt; VLMAX                Follow tail policy</p>
</dd>
</dl>
</dd>
</dl>
<p><cite>vslideup</cite> の書き込みベクトルレジスタグループはソースベクトルレジスタグループと重ならないようにしてください。</p>
<p>NOTE: オーバーラップしないという制約は、実行中の入力ベクトル上のWARハザードを回避し、非ゼロの <cite>vstart</cite>  での再起動を可能にします。</p>
</div>
<div class="section" id="id201">
<h4>ベクトルスライドダウン命令<a class="headerlink" href="#id201" title="このヘッドラインへのパーマリンク">¶</a></h4>
<dl class="simple">
<dt>::</dt><dd><p>vslidedown.vx vd, vs2, rs1, vm       # vd[i] = vs2[i+rs1]
vslidedown.vi vd, vs2, uimm, vm      # vd[i] = vs2[i+uimm]</p>
</dd>
</dl>
<p><cite>vslidedown</cite>  では、<cite>vl</cite> の値は、書き込まれる宛先要素の最大数を指定します。
<cite>vl</cite> を過ぎた残りの要素は、現在の末尾ポリシ(&lt;&lt;sec-agnostic&gt;&gt; 節)に従って処理されます。</p>
<p>ソースの開始インデックス (_OFFSET_) は、<cite>rs1</cite> で指定された <cite>x</cite> レジスタの符号なし整数を使用して指定するか、
または XLEN ビットまでゼロ拡張された 5 ビットの即値を使用します。
XLEN &gt; SEWの場合、_OFFSET_はSEWビットに切り捨てられません。</p>
<dl>
<dt>::</dt><dd><dl>
<dt>vslidedown behavior for source elements for element i in slide</dt><dd><blockquote>
<div><p>0 &lt;= i+OFFSET &lt; VLMAX   src[i] = vs2[i+OFFSET]</p>
</div></blockquote>
<p>VLMAX &lt;= i+OFFSET           src[i] = 0</p>
</dd>
<dt>vslidedown behavior for destination element i in slide</dt><dd><blockquote>
<div><p>0 &lt;  i &lt; vstart         Unchanged</p>
</div></blockquote>
<dl class="simple">
<dt>vstart &lt;= i &lt; vl             vd[i] = src[i] if v0.mask[i] enabled</dt><dd><p>vl &lt;= i &lt; VLMAX          Follow tail policy</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</div>
<div class="section" id="slide1up">
<h4>ベクトル Slide1up<a class="headerlink" href="#slide1up" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>スライドのバリエーションとして、要素を1つ移動するだけでなく、
空いた要素の位置にスカラーの整数値を挿入できるものが用意されています。</p>
<dl class="simple">
<dt>::</dt><dd><p>vslide1up.vx  vd, vs2, rs1, vm        # vd[0]=x[rs1], vd[i+1] = vs2[i]
vfslide1up.vf vd, vs2, rs1, vm        # vd[0]=f[rs1], vd[i+1] = vs2[i]</p>
</dd>
</dl>
<p><cite>vslide1up</cite> 命令は、要素0がアクティブであれば、<cite>x</cite> レジスタの引数を書き込みベクトルレジスタグループの要素0に配置し、
そうでなければ、書き込みベクトル要素の更新は、現在のMask Agnostic/Undisturbed ポリシに従います。
XLEN &lt; SEWの場合、値はSEWビットに符号拡張されます。
XLEN &gt; SEWの場合、最下位のビットがコピーされ、SEW-XLENの上位ビットは無視されます。</p>
<p>残りのアクティブな <cite>vl</cite> -1 要素は、ソースベクトルレジスタ群のインデックス _i_ から書き込みベクトルレジスタ群のインデックス _i_+1 にコピーオーバーされます。</p>
<p><cite>vl</cite> レジスタはソースの値で更新される書き込みベクトルレジスタ要素の最大数を指定し、
<cite>vl</cite> を超えた残りの要素は現在の末尾ポリシ(&lt;&lt;sec-agnostic&gt;&gt;節)に従って処理されます。</p>
<dl>
<dt>::</dt><dd><blockquote>
<div><p>vslide1up behavior</p>
<blockquote>
<div><blockquote>
<div><p>i &lt; vstart  unchanged</p>
</div></blockquote>
<p>0 = i = vstart  vd[i] = x[rs1] if v0.mask[i] enabled</p>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>max(vstart, 1) &lt;= i &lt; vl      vd[i] = vs2[i-1] if v0.mask[i] enabled</dt><dd><p>vl &lt;= i &lt; VLMAX   Follow tail policy</p>
</dd>
</dl>
</dd>
</dl>
<p><cite>vslide1up</cite> 命令は、書き込みベクトルレジスタグループがソースのベクトルレジスタグループと重ならないことが必要です。
それ以外の場合は、命令のエンコーディングは予約されています。</p>
<p><cite>vfslide1up</cite> 命令は類似して定義されていますが、そのスカラ引数を <cite>f</cite> レジスタから供給します。</p>
</div>
<div class="section" id="slide1down">
<h4>ベクトル Slide1down 命令<a class="headerlink" href="#slide1down" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><cite>vslide1down</cite> 命令は、最初の <cite>vl</cite>  -1個のアクティブな要素の値を、
ソースベクトルレジスタグループのインデックス _i_ +1 から書き込みベクトルレジスタ群のインデックス_i_にコピーします。</p>
<p><cite>vl</cite> レジスタはソースの値で書き込まれる書き込みベクトルレジスタ要素の最大数を指定し、
<cite>vl</cite> を超えた残りの要素は現在の末尾ポリシ(&lt;&lt;sec-agnostic&gt;&gt;節)に従って処理されます。</p>
<dl class="simple">
<dt>::</dt><dd><p>vslide1down.vx  vd, vs2, rs1, vm      # vd[i] = vs2[i+1], vd[vl-1]=x[rs1]
vfslide1down.vf vd, vs2, rs1, vm      # vd[i] = vs2[i+1], vd[vl-1]=f[rs1]</p>
</dd>
</dl>
<p><cite>vslide1down</cite> 命令は、要素 <cite>vl-1</cite> がアクティブであれば、<cite>x</cite> レジスタの引数を書き込みベクトルレジスタの位置 <cite>vl</cite>  -1に置き、
そうでなければ、書き込み要素は変更されません。
XLEN &lt; SEWの場合、値はSEWビットに符号拡張されます。
XLEN &gt; SEWの場合、最下位のビットがコピーされ、SEW-XLENの上位ビットは無視されます。</p>
<dl>
<dt>::</dt><dd><p>vslide1down behavior</p>
<blockquote>
<div><blockquote>
<div><p>i &lt; vstart  unchanged</p>
</div></blockquote>
<p>vstart &lt;= i &lt; vl-1    vd[i] = vs2[i+1] if v0.mask[i] enabled
vstart &lt;= i = vl-1    vd[vl-1] = x[rs1] if v0.mask[i] enabled</p>
<blockquote>
<div><p>vl &lt;= i &lt; VLMAX   Follow tail policy</p>
</div></blockquote>
</div></blockquote>
</dd>
</dl>
<p><cite>vfslide1down</cite> 命令は同様に定義されていますが、スカラー引数は <cite>f</cite> レジスタから供給されます。</p>
<p>NOTE: <cite>vslide1down</cite> 命令は、メモリを使用せず、他のベクトル・レジスタに影響を与えずに、ベクトルレジスタに値をロードするために使用できます。
これは、デバッガが複数回の <cite>vslide1down</cite> の呼び出しを繰り返すことで、ゆっくりではありますが、ベクトルレジスタの内容を変更するためのパスを提供します。</p>
</div>
</div>
<div class="section" id="id202">
<h3>ベクトルレジスタギャザー命令<a class="headerlink" href="#id202" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ベクトル・レジスタ・ギャザー命令は、第2のソースベクトルレジスタグループによって与えられる位置から第1のソースベクトルレジスタグループの要素を読み出します。
第2ベクトルのインデックス値は、符号なし整数として扱われます。
ソースベクトルは、<cite>vl</cite> にかかわらず、任意のインデックス &lt; VLMAX で読み取ることができます。
書き込みレジスタに書き込む最大要素数は <cite>vl</cite> で与えられ、<cite>vl</cite> を過ぎた残りの要素は現在の末尾要素のポリシ (&lt;&lt;sec-agnostic&gt;&gt;節) に従って処理されます。
この操作はマスクすることができ、非アクティブな要素に対しては、マスク undisturbed/agnostic ポリシに従います。</p>
<dl class="simple">
<dt>::</dt><dd><p>vrgather.vv vd, vs2, vs1, vm # vd[i] = (vs1[i] &gt;= VLMAX) ? 0 : vs2[vs1[i]];
vrgatherei16.vv vd, vs2, vs1, vm # vd[i] = (vs1[i] &gt;= VLMAX) ? 0 : vs2[vs1[i]];</p>
</dd>
</dl>
<p><cite>vrgather.vv</cite> 形式では、データとインデックスの両方に SEW/LMUL を使用しています。
また、<cite>vrgatherei16.vv</cite> 形式では、<cite>vs2</cite> のデータには SEW/LMUL を使用しますが、
<cite>vs1</cite> のインデックスには EEW=16 と EMUL = (16/SEW)*LMUL を使用します。</p>
<p>NOTE: SEW=8の場合、<cite>vrgather.vv</cite> は0～255のベクトル要素しか参照できません。
また，<cite>vrgatherei16</cite> 形式では，64K 個の要素のインデックスを作成することができ，
SEW &gt; 16 の場合にインデックスを保持するために必要なレジスタの容量を減らすために使用することもできます。</p>
<p>要素のインデックスが範囲外の場合 ( <cite>vs1[i]</cite> {ge} VLMAX )、要素の値は 0 を返します。</p>
<p>レジスタギャザーのベクトルスカラ形式とベクトル即値形式も用意されています。
これらは、与えられたインデックスでソース・ベクトルから1つの要素を読み、この値を書き込みベクトルレジスタの最初のアクティブの要素に書き込みます。
スカラレジスタのインデックス値と、XLENビットまでゼロ拡張された即値は、符号なし整数として扱われます。
XLEN &gt; SEWの場合，インデックス値はSEWビットまで切り捨てられません。</p>
<p>NOTE: これらの形式では、任意のベクトル要素をベクトル全体に「分散」することができます。</p>
<dl class="simple">
<dt>::</dt><dd><p>vrgather.vx vd, vs2, rs1, vm # vd[i] = (x[rs1] &gt;= VLMAX) ? 0 : vs2[x[rs1]]
vrgather.vi vd, vs2, uimm, vm # vd[i] = (uimm &gt;= VLMAX) ? 0 : vs2[uimm]</p>
</dd>
</dl>
<p>任意の <cite>vrgather</cite> 命令では、書き込みベクトルレジスタグループはソースベクトルレジスタグループとオーバーラップすることはできません。</p>
</div>
<div class="section" id="id203">
<h3>ベクトル圧縮命令<a class="headerlink" href="#id203" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ベクトル圧縮命令は、ソースベクトルレジスタ群からベクトルマスクレジスタによって選択された要素を、
書き込みベクトルレジスタ群の先頭の連続した要素にパックすることができます。</p>
<dl class="simple">
<dt>::</dt><dd><p>vcompress.vm vd, vs2, vs1  # vs1で有効なvs2の要素をvdに圧縮する</p>
</dd>
</dl>
<p><cite>vs1</cite> で指定されたベクトルマスクレジスタは、ベクトルレジスタグループ <cite>vs2</cite> の最初の <cite>vl</cite> 要素のうち、
どの要素を抽出して、ベクトルレジスタ <cite>vd</cite> の先頭の連続した要素にパックすべきかを示します。
<cite>vd</cite> の残りの要素は、現在の末尾要素ポリシ (&lt;&lt;sec-agnostic&gt;&gt;節) に従って、末尾要素として扱われます。</p>
<dl>
<dt>::</dt><dd><p>vcompress命令の使用例</p>
<blockquote>
<div><p>1 1 0 1 0 0 1 0 1   v0
8 7 6 5 4 3 2 1 0   v1
1 2 3 4 5 6 7 8 9   v2</p>
<blockquote>
<div><p>vcompress.vm v2, v1, v0</p>
</div></blockquote>
<p>1 2 3 4 8 7 5 2 0   v2</p>
</div></blockquote>
</dd>
</dl>
<p><cite>vcompress</cite> は、マスクされていない命令(<cite>vm=1</cite>)としてエンコードされます。
同等のマスクされた命令(<cite>vm=0</cite>)は予約されています。</p>
<p>書き込みベクトルレジスタグループはソースベクトルレジスタグループやソースマスクレジスタと重なることはできません。</p>
<p>非ゼロの <cite>vstart</cite> で <cite>vcompress</cite> 命令を実行すると、不正命令例外が発生します。</p>
<p>NOTE: 可能ではありますが、<cite>vcompress</cite> は非ゼロの <cite>vstart</cite> で再起動するのがより困難な命令の一つであるため、
実装ではこれを行わずに要素 0 から再起動することを想定しています。</p>
<div class="section" id="vdecompress">
<h4><cite>vdecompress</cite> の合成<a class="headerlink" href="#vdecompress" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>逆の操作を行う <cite>vdecompress</cite> 命令は定義されていませんが、この操作はiota命令とマスク付き <cite>vrgather</cite> 命令を用いて合成できます。</p>
<dl>
<dt>::</dt><dd><dl>
<dt><cite>vdecompress</cite> の所望の動作</dt><dd><p>7 6 5 4 3 2 1 0     # vid</p>
<blockquote>
<div><p>e d c b a     # パッキングされたベクトルの5要素</p>
</div></blockquote>
<p>1 0 0 1 1 1 0 1     # 8要素のベクトルマスク
p q r s t u v w     # vdecompress実行前の書き込みレジスタ</p>
<p>e q r d c b v a     # vdecompress実行後</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple">
<dt>::</dt><dd><p># v0はマスクを保持している
# v1はパックデータを保持している
# v11は展開されたベクトルと結果を保持している
viota.m v10, v0                 # v0のマスクを使用してiotaを実行する
vrgather.vv v11, v1, v10, v0.t  # 書き込みレジスタを展開する</p>
</dd>
</dl>
<dl>
<dt>::</dt><dd><dl class="simple">
<dt>p q r s t u v w    # v11書き込みレジスタ</dt><dd><p>e d c b a    # v1ソースレジスタ</p>
</dd>
</dl>
<p>1 0 0 1 1 1 0 1    # v0マスクレジスタ</p>
<p>4 4 4 3 2 1 1 0    # viota.m実行後のv10レジスタ
e q r d c b v a    # マスク付きviota.mを用いたvrgatherの書き込みレジスタ</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="id204">
<h3>ベクトルレジスタ全体移動命令<a class="headerlink" href="#id204" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><cite>vmv&lt;nr&gt;r.v</cite> 命令は、ベクトルレジスタ全体(VLENビット全て)をコピーし、
ベクトルレジスタグループ全体をコピーすることができます。
EEW=SEW、EMUL=`nr` 、実効長 <cite>evl</cite> =EMUL * VLEN/SEWのように動作します。</p>
<p>NOTE: これらの命令は、コンパイラが <cite>vl</cite>  や <cite>vtype</cite>  を知ったり変更したりすることなく、
ベクトルレジスタをシャッフルすることを支援するためのものです。</p>
<p>NOTE: <cite>vstart</cite> {ge} <cite>vl</cite> の場合に全ての要素に書き込まれないという通常の特性は適用されません。
代わりに、<cite>vstart</cite> {ge} <cite>evl</cite> の場合には要素は書き込まれません。</p>
<p>NOTE: <cite>vd</cite> が <cite>vs2</cite> と等しい場合、その命令はアーキテクチャ的には NOP ですが、内部的にデータを再配置する実装に対しては、
そのレジスタグループが次に SEW に等しい EEW でアクセスされることを示すヒントとして扱われます。</p>
<p>この命令はOPIVI命令としてエンコードされます。 コピーするベクトルレジスタの数は、
メモリ命令の <cite>nf</cite> フィールドと同じエンコーディングで <cite>simm</cite> フィールドの下位3ビットにエンコードされます。
<cite>nr</cite> フィールドの値は、1、2、4、8のいずれかでなければならず、その他の値は予約されています。</p>
<p>NOTE: 将来の拡張機能では、移動するレジスタの数を他の数にすることができます。0, 1, 3, 7 以外の <cite>simm</cite> の値は現在予約されています。</p>
<p>NOTE: この命令は、<cite>vsmul</cite> 命令と同じfunct6エンコーディングを使用していますが、オペランドは即値で、マスクされていないバージョン(<cite>vm=1</cite>) のみです。
このエンコーディングが選ばれたのは、関連する <cite>vmerge</cite> エンコーディングに近いことと、<cite>vsmul</cite> 命令が即値フォームから恩恵を受ける可能性が低いことによります。</p>
<dl>
<dt>::</dt><dd><p>vmv&lt;nr&gt;r.v vd, vs2  # 一般的なフォーム</p>
<p>vmv1r.v v1, v2   #  v2をv1にコピーする
vmv2r.v v10, v12 #  v12をv10にコピーし、v13をv11にコピーする
vmv4r.v v4, v8   #  v8をv4に、v9をv5に、v10をv6に、v11をv7にコピーする
vmv8r.v v0, v8   #  v8をv0に、v9をv1に、... v15をv7にコピーする</p>
</dd>
</dl>
<p>ソースと書き込みのベクトルレジスタ番号は、ベクトルレジスタグループのサイズに合わせて適切にアラインメントする必要があり、
他のベクトルレジスタ番号とのエンコーディングは予約されています。</p>
<p>NOTE: 将来の拡張により、ベクトルレジスターのアラインメント制限が緩和される可能性があります。</p>
</div>
</div>
<div class="section" id="id205">
<h2>例外処理<a class="headerlink" href="#id205" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトル命令中の例外(同期例外または非同期割込みのいずれかが原因)では、
既存の <cite>*epc</cite>  CSR には例外の発生したベクトル命令へのポインタが書き込まれ、
<cite>vstart</cite>  CSR には例外の原因となった要素のインデックスが書き込まれます。</p>
<p>NOTE: 割り込みの待ち時間を短縮し、フォワードプログレス保証を簡素化するために、部分的に実行されたベクトル命令の再開を可能にするための <cite>vstart</cite>  CSRを追加することを選択しました。
これは、IBM 3090のベクトル機能のスキームに似ています。
<cite>vstart</cite>  CSRなしで前進性を確保するためには、実装は、ベクトル命令全体が例外を発生させることなく常にアトミックに完了することを保証しなければなりません。
これは、ストライド演算やスキャッタ/ギャザ演算、デマンドページングされた仮想メモリがある場合には、特に困難です。</p>
<div class="section" id="id206">
<h3>正確なベクトル例外<a class="headerlink" href="#id206" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>NOTE: スーパバイザモードでデマンドページングを行う環境では、正確なベクトル例外が必要になることが多いと思われます。</p>
<p>正確なベクトル例外には以下の要件が必要です:</p>
<p>. 例外の発生したベクトル命令よりも古い命令が結果をコミットしていること
. 例外の発生したベクトル命令よりも新しい命令がアーキテクチャ状態を変更していないこと
. 例外の発生したベクトル命令内で、 <cite>vstart</cite>  CSR のインデックスより前の結果要素に影響を与える演算が結果をコミットしていること
. 例外の発生したベクトル命令内で、 <cite>vstart</cite>  CSR 以降の要素に影響を与える演算がアーキテクチャ状態を変更していないこと。ただし、影響を受けるベクトル命令を再起動して完了させても、正しい最終状態が得られる場合を除く。</p>
<p>最後の要件を緩和して、例外が報告された時点で <cite>vstart</cite>  以降の要素が更新されていても、
与えられた <cite>vstart</cite>  から命令を再実行することでそれらの要素が正しく上書きされることを許可します。</p>
<p>非デバイスメモリ領域では、ベクトルストア命令が、同期例外の原因となった要素を超えて、メモリ内の要素を更新している可能性があります。
デバイスメモリ領域では、ベクトルストア命令中に同期例外を引き起こした要素と同じかそれ以上のインデックスで更新されていてはなりません。</p>
<p>上述の場合を除き、ベクトル命令は入力を上書きすることができますので、ほとんどの場合、
ベクトル命令の再起動は <cite>vstart</cite>  の位置からでなければなりません。
しかし、ベクトル命令の実行結果が常に同一であり、どの場所からでも再起動できるようにするために、
この上書きを禁止するケースがいくつかあります。</p>
<p>実装では、<cite>vstart</cite> で報告された要素やセグメントについて、最終的に前進が保証されるようにしなければなりません。</p>
</div>
<div class="section" id="id207">
<h3>不正確ベクトル例外<a class="headerlink" href="#id207" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>不正確なベクトル例外とは、正確ではない例外のことです。
特に、 <cite>*epc</cite> よりも新しい命令は結果をコミットしているかもしれませんし、 <cite>*epc</cite> よりも古い命令は実行を完了していないかもしれません。
不正確な例外は主に、エラーを報告して実行を終了することが適切な反応である場合に使用することを意図しています。</p>
<p>NOTE: プロファイルでは、割り込みは正確な例外で、他の例外は不正確例外であると指定することができます。
多くの組み込み機器では、致命的なエラーが発生したときには、再開可能な例外を必要としないため、
ベクトル命令のための不正確な例外のみを生成することを想定しています。</p>
<p>不正確な例外は、同期ベクトル例外によって引き起こされた例外のために、<cite>vstart</cite> で障害要素を報告しなければなりません。</p>
</div>
<div class="section" id="id208">
<h3>正確・不正確選択可能な例外<a class="headerlink" href="#id208" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>プロファイルによっては、特権モードのビットを用意して、正確なベクトル例外と不正確ベクトル例外を選択することができます。
不正確なモードでは、高性能に動作しますが、エラーの原因を特定することが困難になる可能性があります。
一方、正確なモードでは、動作速度が遅くなりますが、不正確なモードと同じエラーが発生しない可能性があるものの、
エラーのデバッグが行いやすくなります。</p>
</div>
<div class="section" id="id209">
<h3>スワップ可能な例外<a class="headerlink" href="#id209" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>別の例外モードでは、ベクトルユニットのスワップ可能な状態をサポートし、
例外時に特別な命令でベクトルユニットのマイクロアーキテクチャの状態を保存・復元することで、
不正確な例外の周辺でも実行を正しく継続できるようにします。</p>
<p>このメカニズムは、現在の標準拡張では定義されていません。</p>
<p>NOTE: 将来の拡張機能では、不明確な例外でのコンテキストスイッチングをサポートするために、
ベクトルユニットの実装から不透明なマイクロアーキテクチャの状態を保存・復元する標準的な方法を定義する可能性があります。</p>
<p>[[sec-vector-extensions]]</p>
</div>
</div>
<div class="section" id="standard-vector-extensions">
<h2>Standard Vector Extensions<a class="headerlink" href="#standard-vector-extensions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>This section describes the standard vector extensions to be proposed
for public review.  A set of smaller extensions intended for embedded
use are named with a &quot;Zve&quot; prefix, while a larger vector extension
designed for application processors is named as a single-letter V
extension.</p>
<p>The initial vector extensions are designed to act as a base for
additional vector extensions in various domains, including
cryptography and machine learning.</p>
<div class="section" id="zve-vector-extensions-for-embedded-processors">
<h3>Zve*: Vector extensions for Embedded Processors<a class="headerlink" href="#zve-vector-extensions-for-embedded-processors" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The following five standard extensions are defined to provide varying
degrees of vector support and are intended for use with embedded
processors.  Any of these extensions can be added to base ISAs with
XLEN=32 or XLEN=64.  The table lists the minimum VLEN and supported
EEWs for each extension as well as what floating-point types are
supported.</p>
<p>.Embedded vector extensions
[cols=&quot;1,1,2,1,1&quot;]
[%autowidth]
<a href="#id210"><span class="problematic" id="id211">|</span></a>===
| Extension | Minimum VLEN | Supported EEW |  FP32 | FP64</p>
<div class="line-block">
<div class="line">Zve32x    | 32    | 8, 16, 32     |   N   |  N</div>
<div class="line">Zve32f    | 32    | 8, 16, 32     |   Y   |  N</div>
<div class="line">Zve64x    | 64    | 8, 16, 32, 64 |   N   |  N</div>
<div class="line">Zve64f    | 64    | 8, 16, 32, 64 |   Y   |  N</div>
<div class="line">Zve64d    | 64    | 8, 16, 32, 64 |   Y   |  Y</div>
</div>
<p><a href="#id212"><span class="problematic" id="id213">|</span></a>===</p>
<p>All Zve* extensions have precise traps.</p>
<p>NOTE: There is currently no standard support for handling imprecise
traps, so standard extensions have to provide precise traps.</p>
<p>All Zve* extensions provide support for EEW of 8, 16, and 32, and
Zve64* extensions also support EEW of 64.</p>
<p>All Zve* extensions support the vector configuration instructions
(Section &lt;&lt;sec-vector-config&gt;&gt;).</p>
<p>All Zve* extensions support all vector load and store instructions
(Section &lt;&lt;sec-vector-memory&gt;&gt;), except Zve64* extensions do not
support EEW=64 for index values when XLEN=32.</p>
<p>All Zve* extensions support all vector integer instructions (Section
&lt;&lt;sec-vector-integer&gt;&gt;), except that the <cite>vmulh</cite> integer multiply
variants that return the high word of the product (<cite>vmulh.vv</cite>,
<cite>vmulh.vx</cite>, <cite>vmulhu.vv</cite>, <cite>vmulhu.vx</cite>, <cite>vmulhsu.vv</cite>, <cite>vmulhsu.vx</cite>) are
not included for EEW=64 in Zve64*.</p>
<p>NOTE: Producing the high-word of a product can take substantial
additional gates for large EEW.</p>
<p>All Zve* extensions support all vector fixed-point arithmetic
instructions (&lt;&lt;sec-vector-fixed-point&gt;&gt;), except that <cite>vsmul.vv</cite> and
<cite>vsmul.vx</cite> are not supported for EEW=64 in Zve64*.</p>
<p>NOTE: As with <cite>vmulh</cite>, <cite>vsmul</cite> requires a large amount of additional
logic, and 64-bit fixed-point multiplies are relatively rare.</p>
<p>All Zve* extensions support all vector integer single-width and
widening reduction operations (Sections &lt;&lt;sec-vector-integer-reduce&gt;&gt;,
&lt;&lt;sec-vector-integer-reduce-widen&gt;&gt;).</p>
<p>All Zve* extensions support all vector mask instructions (Section
&lt;&lt;sec-vector-mask&gt;&gt;).</p>
<p>All Zve* extensions support all vector permutation instructions
(Section &lt;&lt;sec-vector-permute&gt;&gt;), except that Zve32x and Zve64x do not
implement the floating-point scalar move instructions.</p>
<p>The Zve32f and Zve64f extensions require the scalar processor to
implement the F extension, and implement all vector floating-point
instructions (Section &lt;&lt;sec-vector-float&gt;&gt;) for floating-point
operands with EEW=32 (i.e., no widening floating-point operations),
and conversion instructions are provided to and from all supported
integer EEWs.  Vector single-width floating-point reduction operations
(&lt;&lt;sec-vector-float-reduce&gt;&gt;) for EEW=32 are supported.</p>
<p>The Zve32d and Zve64d extensions require the scalar processor to
implement the D extension, and implement all vector floating-point
instructions (Section &lt;&lt;sec-vector-float&gt;&gt;) for floating-point
operands with EEW=32 or EEW=64 (including widening instructions and
conversions between FP32 and FP64). Vector single-width floating-point
reductions (&lt;&lt;sec-vector-float-reduce&gt;&gt;) for EEW=32 and EEW=64 are
supported as well as widening reductions from FP32 to FP64.</p>
</div>
<div class="section" id="v-vector-extension-for-application-processor">
<h3>V: Vector Extension for Application Processor<a class="headerlink" href="#v-vector-extension-for-application-processor" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The single-letter V extension is intended for use in application
processor profiles.</p>
<p>The V vector extension has precise traps.</p>
<p>The V vector extension requires that VLEN {ge} 128.</p>
<p>NOTE: The value of 128 was chosen as a compromise for application
processors. Providing a larger VLEN allows stripmining code to be
elided in some cases for short vectors, but also increases the size of
the minimum implementation.  Note that larger LMUL can be used to
avoid stripmining for longer known-size application vectors at the
cost of having fewer available vector register groups. For example, an
LMUL of 8 allows vectors of up to sixteen 64-bit elements to be
processed without stripmining using four vector register groups.</p>
<p>The V extension supports EEW of 8, 16, and 32, and 64.</p>
<p>The V extension supports the vector configuration instructions
(Section &lt;&lt;sec-vector-config&gt;&gt;).</p>
<p>The V extension supports all vector load and store instructions
(Section &lt;&lt;sec-vector-memory&gt;&gt;), except the V extension does not
support EEW=64 for index values when XLEN=32.</p>
<p>The V extension supports all vector integer instructions (Section
&lt;&lt;sec-vector-integer&gt;&gt;).</p>
<p>The V extension supports all vector fixed-point arithmetic
instructions (&lt;&lt;sec-vector-fixed-point&gt;&gt;).</p>
<p>The V extension supports all vector integer single-width and
widening reduction operations (Sections &lt;&lt;sec-vector-integer-reduce&gt;&gt;,
&lt;&lt;sec-vector-integer-reduce-widen&gt;&gt;).</p>
<p>The V extension supports all vector mask instructions (Section
&lt;&lt;sec-vector-mask&gt;&gt;).</p>
<p>The V extension supports all vector permutation instructions (Section
&lt;&lt;sec-vector-permute&gt;&gt;).</p>
<p>The V extension requires the scalar processor to implement the F and D
extensions, and implements all vector floating-point instructions
(Section &lt;&lt;sec-vector-float&gt;&gt;) for floating-point operands with EEW=32
or EEW=64 (including widening instructions and conversions between
FP32 and FP64). Vector single-width floating-point reductions
(&lt;&lt;sec-vector-float-reduce&gt;&gt;) for EEW=32 and EEW=64 are supported as
well as widening reductions from FP32 to FP64.</p>
</div>
</div>
<div class="section" id="vector-instruction-listing">
<h2>Vector Instruction Listing<a class="headerlink" href="#vector-instruction-listing" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>include::inst-table.adoc[]</p>
<p>include::vector-examples.adoc[]</p>
<p>include::calling-convention.adoc[]</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; 著作権 2019, msyksphinz

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>