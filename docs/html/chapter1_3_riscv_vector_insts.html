

<!DOCTYPE html>
<html class="writer-html5" lang="ja" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>v0.9からの変更点 &mdash; riscv-v-spec-japanese  ドキュメント</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script src="_static/translations.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" />
    <link rel="next" title="4. ベクトル要素のベクトルレジスタへの割り付け" href="chapter4_mapping_vector_elements.html" />
    <link rel="prev" title="RISC-V “V” Extension" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> riscv-v-spec-japanese
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">v0.9からの変更点</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#slen-vlen">SLEN=VLENレイアウトが必須</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lmul-1elen-vlen">LMUL &gt; 1におけるELEN &gt; VLENのサポート</a></li>
<li class="toctree-l2"><a class="reference internal" href="#vector-fp">Vector FP例外の動作についての定義</a></li>
<li class="toctree-l2"><a class="reference internal" href="#misa-vmstatus-vs"><code class="docutils literal notranslate"><span class="pre">misa.v</span></code>および<code class="docutils literal notranslate"><span class="pre">mstatus.vs</span></code>の相互作用について</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id1">逆数及び逆数の平方根を推論する命令の追加</a></li>
<li class="toctree-l2"><a class="reference internal" href="#wholeeew">wholeレジスタ移動およびロードストア命令におけるEEWエンコーディングのサポート。マイクロアーキテクチャにおける内部データ再構成をサポートするため。</a></li>
<li class="toctree-l2"><a class="reference internal" href="#vrgatherei16"><code class="docutils literal notranslate"><span class="pre">vrgatherei16</span></code>命令のサポート</a></li>
<li class="toctree-l2"><a class="reference internal" href="#vtypevlmul"><code class="docutils literal notranslate"><span class="pre">vtype</span></code>ビットレイアウトを変更し<code class="docutils literal notranslate"><span class="pre">vlmul</span></code>を連続したビットフィールドに設定</a></li>
<li class="toctree-l2"><a class="reference internal" href="#edivv1-0dot">EDIVを付録に移動し、v1.0に含まれないことを明確にするためにdot命令をエンコーディングから削除</a></li>
<li class="toctree-l2"><a class="reference internal" href="#quad-widerning-mulaccv1-0">Quad-widerning mulacc命令を付録に移動し、v1.0に含まれないことを明確にするために命令エンコーディングから削除</a></li>
<li class="toctree-l2"><a class="reference internal" href="#vnegvfneg"><code class="docutils literal notranslate"><span class="pre">vneg</span></code>と<code class="docutils literal notranslate"><span class="pre">vfneg</span></code>の疑似命令を追加</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#id2">1. イントロダクション</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id3">2. 実装により決定される定数パラメータ</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id4">3. ベクトル拡張のプログラミングモデル</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id5">3.1 ベクトルレジスタ</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mstatus">3.2 <code class="docutils literal notranslate"><span class="pre">mstatus</span></code>内でのベクトルコンテキストの状態</a></li>
<li class="toctree-l2"><a class="reference internal" href="#vtype">3.3 ベクトル型レジスタ, <code class="docutils literal notranslate"><span class="pre">vtype</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#vsew">3.3.1. ベクトル選択エレメント幅<code class="docutils literal notranslate"><span class="pre">vsew</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#vlmul-2-0">3.3.2 ベクトルレジスタグルーピング(<code class="docutils literal notranslate"><span class="pre">vlmul[2:0]</span></code>)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vector-tail-agnosticvector-mask-agnostic-vtavma">3.3.3 Vector Tail AgnosticとVector Mask Agnostic: <code class="docutils literal notranslate"><span class="pre">vta</span></code>と<code class="docutils literal notranslate"><span class="pre">vma</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#vill">3.3.4. ベクトルタイプ不正 <code class="docutils literal notranslate"><span class="pre">vill</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#vl">3.3. ベクトル長レジスタ<code class="docutils literal notranslate"><span class="pre">vl</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#vlenb">3.4 ベクトルバイト長レジスタ<code class="docutils literal notranslate"><span class="pre">vlenb</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#csrvstart">3.5. ベクトルスタートインデックスCSR<code class="docutils literal notranslate"><span class="pre">vstart</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#vxrm">3.6. ベクトル固定小数点丸めモードレジスタ<code class="docutils literal notranslate"><span class="pre">vxrm</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#vxsat">3.7. ベクトル固定小数点飽和フラグ<code class="docutils literal notranslate"><span class="pre">vxsat</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#fcsr">3.7. <code class="docutils literal notranslate"><span class="pre">fcsr</span></code>のベクトル固定小数点フィールド</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">3.8. ベクトル拡張のリセット状態について</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="chapter4_mapping_vector_elements.html">4. ベクトル要素のベクトルレジスタへの割り付け</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter5_vector_instruction_format.html">5. ベクトル命令フォーマット</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter6_config_insts.html">6. コンフィグレーション設定命令</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter7_vector_load_store.html">7. ベクトルロードストア命令</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter8_vector_amo.html">8. ベクトルAMO操作(<code class="docutils literal notranslate"><span class="pre">Zvamo</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter8_vector_amo.html#id1">9. ベクトルメモリのアライメント制約</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter8_vector_amo.html#id2">10. ベクトルメモリのコンシステンシモデル</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter11_vector_arithmetic_formats.html">11. ベクトル算術演算命令フォーマット</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter12_vector_arithmetic_insts.html">12. ベクトル整数算術演算命令</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter13_fixedpoint.html">13. ベクトル固定小数点演算命令</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter14_floatingpoint.html">14. ベクトル浮動小数点命令</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter15_reduction.html">15. ベクトルリダクション操作</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter16_vector_mask.html">16. ベクトルマスク命令</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter17_vector_permutation.html">17. ベクトル並べ替え命令</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter18_exception.html">18. 例外処理</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter19_zvediv.html">19. 要素分割拡張命令 (‘Zvediv’)</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter20_listing.html">20. ベクトル命令一覧</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendixA_examples.html">付録A: ベクトルアセンブリコード例</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">riscv-v-spec-japanese</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>v0.9からの変更点</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/chapter1_3_riscv_vector_insts.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <p>Version 0.9</p>
<p>Contributors include: Alon Amid, Krste Asanovic, Allen Baum, Alex
Bradbury, Tony Brewer, Chris Celio, Aliaksei Chapyzhenka, Silviu
Chiricescu, Ken Dockser, Bob Dreyer, Roger Espasa, Sean Halle, John
Hauser, David Horner, Bruce Hoult, Bill Huffman, Nicholas Knight,
Constantine Korikov, Ben Korpan, Hanna Kruppe, Yunsup Lee, Guy Lemieux,
Grigorios Magklis, Filip Moc, Rich Newell, Albert Ou, David Patterson,
Colin Schmidt, Alex Solomatnikov, Steve Wallach, Andrew Waterman, Jim
Wilson.</p>
<p>現在のバージョンで分かっている問題点:</p>
<ul class="simple">
<li><p>エンコーディングフォーマットをより改善する必要がある。</p></li>
<li><p>ベクトルメモリに関するコンシステンシモデルを明らかにする必要がある。</p></li>
<li><p>特権アーキテクチャとの相互関係について説明する必要がある。</p></li>
</ul>
<div class="section" id="v0-9">
<h1>v0.9からの変更点<a class="headerlink" href="#v0-9" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="section" id="slen-vlen">
<h2>SLEN=VLENレイアウトが必須<a class="headerlink" href="#slen-vlen" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>グループはSLEN=VLENのレイアウトが必須となるように仕様を変更した。レジスタ内のバイトレイアウトは、メモリのレイアウトと一致する。SLEN&lt;VLENレイアウトで、幅広いデータパスのマシンでマイクロアーキテクチャのテクニックによる多くの最適化が可能になり、SLEN=VLENによりソフトウェアとのインタフェースがより単純になる。</p>
</div>
<div class="section" id="lmul-1elen-vlen">
<h2>LMUL &gt; 1におけるELEN &gt; VLENのサポート<a class="headerlink" href="#lmul-1elen-vlen" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>仕様では、単一のベクトルレジスタよりも幅の広い要素についての仕様が含まれていなかったが、ベクトルレジスタグループを使用することによりサポートされる。しかしELENの最小値はLMUL=1の時を満たす必要がある。</p>
</div>
<div class="section" id="vector-fp">
<h2>Vector FP例外の動作についての定義<a class="headerlink" href="#vector-fp" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
<div class="section" id="misa-vmstatus-vs">
<h2><code class="docutils literal notranslate"><span class="pre">misa.v</span></code>および<code class="docutils literal notranslate"><span class="pre">mstatus.vs</span></code>の相互作用について<a class="headerlink" href="#misa-vmstatus-vs" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
<div class="section" id="id1">
<h2>逆数及び逆数の平方根を推論する命令の追加<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
<div class="section" id="wholeeew">
<h2>wholeレジスタ移動およびロードストア命令におけるEEWエンコーディングのサポート。マイクロアーキテクチャにおける内部データ再構成をサポートするため。<a class="headerlink" href="#wholeeew" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
<div class="section" id="vrgatherei16">
<h2><code class="docutils literal notranslate"><span class="pre">vrgatherei16</span></code>命令のサポート<a class="headerlink" href="#vrgatherei16" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
<div class="section" id="vtypevlmul">
<h2><code class="docutils literal notranslate"><span class="pre">vtype</span></code>ビットレイアウトを変更し<code class="docutils literal notranslate"><span class="pre">vlmul</span></code>を連続したビットフィールドに設定<a class="headerlink" href="#vtypevlmul" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
<div class="section" id="edivv1-0dot">
<h2>EDIVを付録に移動し、v1.0に含まれないことを明確にするためにdot命令をエンコーディングから削除<a class="headerlink" href="#edivv1-0dot" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
<div class="section" id="quad-widerning-mulaccv1-0">
<h2>Quad-widerning mulacc命令を付録に移動し、v1.0に含まれないことを明確にするために命令エンコーディングから削除<a class="headerlink" href="#quad-widerning-mulaccv1-0" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
<div class="section" id="vnegvfneg">
<h2><code class="docutils literal notranslate"><span class="pre">vneg</span></code>と<code class="docutils literal notranslate"><span class="pre">vfneg</span></code>の疑似命令を追加<a class="headerlink" href="#vnegvfneg" title="このヘッドラインへのパーマリンク">¶</a></h2>
</div>
</div>
<div class="section" id="id2">
<h1>1. イントロダクション<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>このドキュメントはRISC-Vのベースベクトル拡張 version 1.0
について説明するものである。</p>
<blockquote>
<div><p>本ドキュメントは、実装及び評価に用いられるベクトル仕様の安定版プロポーザルのドラフト仕様である。ドラフトのラベルが外れると、Version
1.0 はRISC-V Internationalの承認プロセスの一部であるPublic
Reviewに送られる意図がある。Version
1.0はツールチェインの開発、機能シミュレータ、初期の実装に関して十分に安定していると見なされ、承認中に重大な問題が発見された場合を除き、機能に大きな変更が入ることはない。一度承認されると、仕様はVersion
2.0が与えられる。</p>
</div></blockquote>
<p>ドラフト版の仕様は特定のベクトル機能がベクトル命令としてどのように実装することができるのかについて把握する意味を持っているが、与えられたプラットフォームプロファイルに対して、どのようなベクトル命令の集合が十分であるかについて決定されている訳ではない。</p>
<p>「ベースベクトル拡張」という言葉は、“V”拡張に必要な標準的なベクトルISAコンポーネントを説明するためのインフォーマルな用語として使用され、標準的なサーバやアプリケーションプロセッサのプラットフォームプロファイルとして使用されることを意図している。必須の命令とサポートされる要素の幅のセットは、以下で説明するようにベースISA(RV32I,
RV64I)によって異なる。</p>
<p>組み込みプロファイルを含む他のプロファイルは、これらの拡張機能のサブセットのみを選択することがある。特定のプロファイルに準拠するための実装でサポートされている必須の命令の正確なセットは、各プロファイル仕様が承認された場合にのみ決定される。サブセットプロファイルの定義に便利なように、ベクトル命令サブセットには、“Zv”プレフィックスで始まるISA文字列が付加される。</p>
<blockquote>
<div><p>ベース”V&quot;拡張に含まれないが将来含まれることになる命令を含めてすべてのベクトル命令のサブセットおよび拡張の名前は未決定である。</p>
</div></blockquote>
<p>このベースベクトル命令は、暗号処理や機械学習などの様々なドメイン向けに拡張された追加ベクトル命令として動作するように設計されている。</p>
</div>
<div class="section" id="id3">
<h1>2. 実装により決定される定数パラメータ<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>各hartはベクトル拡張をサポートすることにより以下の2つのパラメータを持つことになる。</p>
<ol class="arabic simple">
<li><p>1ベクトル要素の最大ビットサイズ<em>ELEN</em>≥8。2の累乗の必要がある。</p></li>
<li><p>ベクトルレジスタのビットサイズ<em>VLEN ≥ ELEN</em>, 2の累乗の必要がある。</p></li>
</ol>
<blockquote>
<div><p>プラットフォームのプロファイルにはこれらのパラメータに関して更なる制約が入る可能性がある。例えば、ELEN
≥ max(XLEN,FLEN)や、最小VLEN値、SLEN=VLENなど。</p>
</div></blockquote>
<p>ISAは上記の制約情報をバイナリコードで記述することができ、hartは個のバイナリコードを参照することで異なるパラメータで異なる動作できるようになる。</p>
<blockquote>
<div><p>コードにより実装パラメータの違いを表現できるようになる。</p>
</div></blockquote>
<blockquote>
<div><p>ベクトル状態がアクティブなスレッドコンテキストは、VLEN,
ELENパラメータのいずれかが異なるハードウェアスレッド間では、実行中に合流することはできない。</p>
</div></blockquote>
</div>
<div class="section" id="id4">
<h1>3. ベクトル拡張のプログラミングモデル<a class="headerlink" href="#id4" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>ベクトル拡張ではベースとなるスカラRISC-V
ISAに対して32個のベクトルレジスタと、7つの非特権CSRレジスタ(<code class="docutils literal notranslate"><span class="pre">vstart</span></code>,
<code class="docutils literal notranslate"><span class="pre">vxsat</span></code>, <code class="docutils literal notranslate"><span class="pre">vxrm</span></code>, <code class="docutils literal notranslate"><span class="pre">vcsr</span></code>,<code class="docutils literal notranslate"><span class="pre">vtype</span></code>, <code class="docutils literal notranslate"><span class="pre">vl</span></code>,
<code class="docutils literal notranslate"><span class="pre">vlenb</span></code>)が定義されている。</p>
<div class="docutils container">
<p>表1. 新ベクトルCSR</p>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 13%" />
<col style="width: 9%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Address</p></th>
<th class="head"><p>Privilege</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x008</p></td>
<td><p>URW</p></td>
<td><p>vstart</p></td>
<td><p>ベクトルスタート位置を示すレジスタ</p></td>
</tr>
<tr class="row-odd"><td><p>0x009</p></td>
<td><p>URW</p></td>
<td><p>vxsat</p></td>
<td><p>浮動小数点飽和フラグレジスタ</p></td>
</tr>
<tr class="row-even"><td><p>0x00A</p></td>
<td><p>URW</p></td>
<td><p>vxrm</p></td>
<td><p>浮動小数点丸めモードレジスタ</p></td>
</tr>
<tr class="row-odd"><td><p>0x00F</p></td>
<td><p>URW</p></td>
<td><p>vcsr</p></td>
<td><p>ベクトル制御およびステータスレジスタ</p></td>
</tr>
<tr class="row-even"><td><p>0xC20</p></td>
<td><p>URO</p></td>
<td><p>vl</p></td>
<td><p>ベクトル長レジスタ</p></td>
</tr>
<tr class="row-odd"><td><p>0xC21</p></td>
<td><p>URO</p></td>
<td><p>vtype</p></td>
<td><p>ベクトルデータ型レジスタ</p></td>
</tr>
<tr class="row-even"><td><p>0xC22</p></td>
<td><p>URO</p></td>
<td><p>vlenb</p></td>
<td><p>VLEN/8 (ベクトルレジスタのバイト単位での長さ)</p></td>
</tr>
</tbody>
</table>
<div class="section" id="id5">
<h2>3.1 ベクトルレジスタ<a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトル拡張ではベースのスカラRISC-V
ISAに対して32個のアーキテクチャベクトルレジスタ<code class="docutils literal notranslate"><span class="pre">v0</span></code>-<code class="docutils literal notranslate"><span class="pre">v31</span></code>が加わっている。</p>
<p>それぞれのベクトルレジスタはVLENビットだけのビットを保持する。</p>
<blockquote>
<div><p>Zfinx(“F in
X”)は新しいISAのオプションとして考えられているもので、浮動小数点命令が整数レジスタファイルをレジスタ引数として取ることができるようになるものである。0.8ベクトル拡張ではこのオプションとの互換性を持っている。</p>
</div></blockquote>
</div>
<div class="section" id="mstatus">
<h2>3.2 <code class="docutils literal notranslate"><span class="pre">mstatus</span></code>内でのベクトルコンテキストの状態<a class="headerlink" href="#mstatus" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">mstatus[24:23]</span></code>に<code class="docutils literal notranslate"><span class="pre">VS</span></code>フィールドとしてベクトルのコンテキスト状態を表すためのビットが追加された。これは<code class="docutils literal notranslate"><span class="pre">sstatus[24:23]</span></code>に対してもシャドウされる。このビットは、浮動小数点のコンテキストを表現するための<code class="docutils literal notranslate"><span class="pre">FS</span></code>フィールドと同様の目的で定義されている。</p>
<p><code class="docutils literal notranslate"><span class="pre">VS</span></code>ビットフィールドがOffの状態で任意のベクトル命令を実行しようとするか<code class="docutils literal notranslate"><span class="pre">vl</span></code>,
<code class="docutils literal notranslate"><span class="pre">vtype</span></code>, <code class="docutils literal notranslate"><span class="pre">vlenb</span></code>, <code class="docutils literal notranslate"><span class="pre">vstart</span></code>
CSRにアクセスしようとすると不定命令例外が発生する。</p>
<p><code class="docutils literal notranslate"><span class="pre">VS</span></code>フィールドがInitialもしくはCleanの状態でベクトルの状態を変更する任意の命令を実行するか、<code class="docutils literal notranslate"><span class="pre">vl</span></code>,
<code class="docutils literal notranslate"><span class="pre">vtype</span></code>,
<code class="docutils literal notranslate"><span class="pre">vstart</span></code>レジスタへのアクセスを行うと<code class="docutils literal notranslate"><span class="pre">VS</span></code>フィールドはDirtyに変更される。</p>
<blockquote>
<div><p>実装では、ベクトルの状態に変更が発生しなくても<code class="docutils literal notranslate"><span class="pre">VS</span></code>フィールドの状態は常にDirtyに設定しておくこともできる。<code class="docutils literal notranslate"><span class="pre">VS</span></code>フィールドを細かく実装するかどうかはオプションである。</p>
</div></blockquote>
<p>実装では<code class="docutils literal notranslate"><span class="pre">misa.v</span></code>フィールドを書き込み可能にすることができる。これは浮動小数点命令における仕様と同一である。<code class="docutils literal notranslate"><span class="pre">mstatus.vs</span></code>フィールドは、<code class="docutils literal notranslate"><span class="pre">misa.v</span></code>が設定されていないとしても存在している。</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">misa.v</span></code>がクリアされていたとしても<code class="docutils literal notranslate"><span class="pre">mstatus.vs</span></code>を存在させることによって、ベクトルのエミュレーションが可能になり<code class="docutils literal notranslate"><span class="pre">misa.v</span></code>が書き込み可能なシステムにおける<code class="docutils literal notranslate"><span class="pre">mstatus.vs</span></code>の取り扱いが簡単になる。</p>
</div></blockquote>
</div>
<div class="section" id="vtype">
<h2>3.3 ベクトル型レジスタ, <code class="docutils literal notranslate"><span class="pre">vtype</span></code><a class="headerlink" href="#vtype" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">vtype</span></code>レジスタはXLENビット長のRead-onlyなCSRであり、ベクトルレジスタファイルに含まれるデフォルトのデータ型を示している。<code class="docutils literal notranslate"><span class="pre">vtype</span></code>は<code class="docutils literal notranslate"><span class="pre">vsetvl{i}</span></code>命令の実行でしかアップデートすることができない。ベクトル型は各ベクトルレジスタ内の要素の構成についても決定し、どのように複数のベクトルレジスタをグループ化するかについても決定する。</p>
<blockquote>
<div><p>初期のドラフト版では、<code class="docutils literal notranslate"><span class="pre">vtype</span></code>レジスタは通常のCSR書き込み命令でも書き込みを行うことが可能であった。<code class="docutils literal notranslate"><span class="pre">vsetvl{i}</span></code>命令でのみアップデートが可能である仕様に変更したのは、<code class="docutils literal notranslate"><span class="pre">vtype</span></code>レジスタの管理をより簡単化するためである。</p>
</div></blockquote>
<p>ベースベクトル拡張では、<code class="docutils literal notranslate"><span class="pre">vtype</span></code>レジスタは5つのフィールドを持っている。<code class="docutils literal notranslate"><span class="pre">vill</span></code>,
<code class="docutils literal notranslate"><span class="pre">vma</span></code>, <code class="docutils literal notranslate"><span class="pre">vta</span></code>,<code class="docutils literal notranslate"><span class="pre">vsew[2:0]</span></code>, <code class="docutils literal notranslate"><span class="pre">vlmul[2:0]</span></code>である。</p>
<div class="docutils container">
<p>表2. <code class="docutils literal notranslate"><span class="pre">vtype</span></code>レジスタレイアウト</p>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 12%" />
<col style="width: 15%" />
<col style="width: 73%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Bits</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>XLEN-1</p></td>
<td><p>vill</p></td>
<td><p>不正な値が設定されると1が設定される</p></td>
</tr>
<tr class="row-odd"><td><p>XLEN-2:7</p></td>
<td></td>
<td><p>予約(write 0)</p></td>
</tr>
<tr class="row-even"><td><p>7</p></td>
<td><p>vma</p></td>
<td><p>Vector mask agnostic</p></td>
</tr>
<tr class="row-odd"><td><p>6</p></td>
<td><p>vta</p></td>
<td><p>Vector tail agnostic</p></td>
</tr>
<tr class="row-even"><td><p>5:3</p></td>
<td><p>vsew[2:0]</p></td>
<td><p>SEW(Selected-Element-Width)の設定に使用される</p></td>
</tr>
<tr class="row-odd"><td><p>2:0</p></td>
<td><p>vlmul[1:0]</p></td>
<td><p>ベクトルレジスタグループ(LMUL)の設定に使用される</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>ELEN=32をサポートする最小のベース実装では、<code class="docutils literal notranslate"><span class="pre">vtype</span></code>では7ビットが必要である：<code class="docutils literal notranslate"><span class="pre">ma</span></code>,
<code class="docutils literal notranslate"><span class="pre">ta</span></code>の2ビット、<code class="docutils literal notranslate"><span class="pre">vsew[1:0]</span></code>の2ビットと<code class="docutils literal notranslate"><span class="pre">vlmul[2:0]</span></code>の3ビットである。<code class="docutils literal notranslate"><span class="pre">vill</span></code>の不正な値の設定は、<code class="docutils literal notranslate"><span class="pre">vsew[1:0]</span></code>を使用した64ビットのコンビネーションによりエンコードでき、これにより<code class="docutils literal notranslate"><span class="pre">vill</span></code>のためのストレージを省略できる。</p>
<p>ベクトルベース拡張に対するさらなる標準・カスタム拡張に関しては、上記のフィールドを拡張してより多くのデータタイプをサポートできるようにする。</p>
</div></blockquote>
<blockquote>
<div><p>拡張64ビット命令エンコーディングにより、これらのフィールドを命令エンコーディングで静的に指定できるようになると予想される。</p>
</div></blockquote>
<div class="section" id="vsew">
<h3>3.3.1. ベクトル選択エレメント幅<code class="docutils literal notranslate"><span class="pre">vsew</span></code><a class="headerlink" href="#vsew" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">vsew</span></code>の値は動的<strong>選択エレメント幅: selected element
width(SEW)</strong>を設定する。デフォルトでは、ベクトルレジスタはVLEN /
SEW標準幅エレメントに分割されているように見ることができる。</p>
<blockquote>
<div><p>ベースベクトル拡張では、SEWはmax(XLEN,FLEN)までのサイズをサポートすることが必要である。他のプロフィールではELENを異なる値に設定することが可能である。</p>
</div></blockquote>
<div class="docutils container">
<p>表3. <code class="docutils literal notranslate"><span class="pre">vsew[2:0]</span></code>(standard element width)エンコーディング</p>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 28%" />
<col style="width: 28%" />
<col style="width: 28%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>vsew[2]</p></th>
<th class="head"><p>vsew[1]</p></th>
<th class="head"><p>vsew[0]</p></th>
<th class="head"><p>SEW</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>16</p></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>32</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>64</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>128</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>256</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>512</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>1024</p></td>
</tr>
</tbody>
</table>
<div class="docutils container">
<p>表4. VLEN=128ビットの場合の例</p>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>SEW</p></th>
<th class="head"><p>ベクトルサイズあたりの要素数</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>64</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>32</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p>16</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-odd"><td><p>8</p></td>
<td><p>16</p></td>
</tr>
</tbody>
</table>
<p>サポートされるエレメント幅はLMULによって異なるが、プロファイルはLMUL=1のときにサポートされる最小のSEWをサポートしなければならない。</p>
<blockquote>
<div><p>いくつかの実装では、複数のベクトルレジスタを組み合わせたときにのみサポート可能な、より大きなSEWのみをサポートすることがある。ベースベクトル拡張ではLMUL=1のときのSEW=max(XLEN,FLEN)が要求されている。</p>
</div></blockquote>
<blockquote>
<div><p>より大きなEEWに依存するソフトウェアは、コードが実行される実装の数を増やすために、最大のLMUL値を使用しようとすべきであり、従ってベクトルレジスタのグループは最小になる。<code class="docutils literal notranslate"><span class="pre">vtype</span></code>レジスタ中の<code class="docutils literal notranslate"><span class="pre">vill</span></code>ビットをチェックしてコンフィグレーションがサポートされているかどうかを確認するべきであり、そのコンフィグレーションが存在しない場合は別のコードパスを提供するべきである。あるいは、プロファイルは各LMUL設定で最小SEWを必須とすることができる。</p>
</div></blockquote>
</div>
<div class="section" id="vlmul-2-0">
<h3>3.3.2 ベクトルレジスタグルーピング(<code class="docutils literal notranslate"><span class="pre">vlmul[2:0]</span></code>)<a class="headerlink" href="#vlmul-2-0" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>複数のベクトルレジスタを1つにグループ化することができ、単一のベクトル命令で複数のベクトルレジスタを取り扱うことができる。<strong>ベクトルレジスタグループ</strong>という名前はベクトル命令によって取り扱われる1つ以上のベクトルレジスタのことを指す。ベクトルレジスタグループは、標準幅の要素から構成される、2倍以上のより長いベクトル長を操作することができるようになる。ベクトルレジスタグループは、よりベクトル長の長いアプリケーションにおいて効率的に命令を実行できるようになる。</p>
<p>グループ内のベクトルレジスタの数は<strong>LMUL</strong>により管理される。この値が1よりも大きいバイは、その数だけのベクトルレジスタが結合され1つのベクトルレジスタグループを構成する。LMULは整数値として1,
2, 4, 8が設定できる。</p>
<p>またLMULは分数も指定することができ、ベクトルレジスタ内の使用するビット数を削減することができる。LMULは分数として1/2,
1/4,
1/8が設定できる。分数のLMULは、より大きなベクトルが複数のベクトルレジスタを占有する必要のない、混合幅の値を操作するときにアーキテクチャのレジスタ数を増加させるために使用される。代わりに、より広い値が単一のベクトルレジスタを占有し、より狭い値がベクトルレジスタの一部を占める可能性がある。</p>
<p>実装は、分数LMULの設定として、LMUL=1のときのELENに対して<code class="docutils literal notranslate"><span class="pre">LMUL&gt;=SEW/ELEN</span></code>をサポートしなくてはならない。サポートされないSEWおよびLMULコンフィグレーションを設定した場合には、<code class="docutils literal notranslate"><span class="pre">vtype</span></code>レジスタの<code class="docutils literal notranslate"><span class="pre">vill</span></code>が設定される。</p>
<blockquote>
<div><p>LMUL ≥ SEW/ELEN
を必要とすることで、混在幅要素で動作するソフトウェアでは、単一のベクトルレジスタを使用して最も広い
(ELEN) 要素のみを保持し、分数のLMUL
を使用して狭い要素を保持することができる。LMUL &lt; SEW/ELEN
の場合、VLEN=ELEN
が有効な実装の選択であるため、分数ベクタレジスタに少なくとも 1
つの要素を格納するのに十分なビットがあるという保証はない。</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">LMUL</span> <span class="pre">&lt;</span> <span class="pre">SEW/ELEN</span></code>の実装および<code class="docutils literal notranslate"><span class="pre">vill</span></code>ビットが設定されない場合の動作については予約されている。</p>
<blockquote>
<div><p>このようなすべての実装で<code class="docutils literal notranslate"><span class="pre">vill</span></code>ビットを設定すると、将来的には個のエンコーディングを拡張機能として使用できなくなるため、<code class="docutils literal notranslate"><span class="pre">LMUL&lt;SEW/ELEN</span></code>の動作を定義するようにするため、ここでは<code class="docutils literal notranslate"><span class="pre">vill</span></code>が予約されない場合の考慮をしている。</p>
</div></blockquote>
<blockquote>
<div><p>アセンブラは<code class="docutils literal notranslate"><span class="pre">vsetvli</span></code>命令がLMUL &lt;
SEW/ELENの設定を行おうとする場合に警告(エラーではない)を出力することが推奨されている。</p>
</div></blockquote>
<p>LMULは<code class="docutils literal notranslate"><span class="pre">vtype</span></code>フィールドの符号付き<code class="docutils literal notranslate"><span class="pre">vlmul</span></code>である(LMUL=</p>
<div class="math notranslate nohighlight">
\[2^{\text{vlmul[2:0]}}\]</div>
<p>)</p>
<p>VLMAX=LMUL*VLEN/SEWは、下記の表に示す通り、現在のSEWおよびLMULの設定が与えられた場合に、単一のベクトル命令で操作可能な要素の最大数を示している。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 10%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 15%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>v
lmul[2]</p></th>
<th class="head"><p>v
lmul[1]</p></th>
<th class="head"><p>v
lmul[0]</p></th>
<th class="head"><p>LMUL</p></th>
<th class="head"><p>#groups</p></th>
<th class="head"><p>VLMAX</p></th>
<th class="head"><p>Grouped
re
gisters</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>予約</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>1/8</p></td>
<td><p>32</p></td>
<td><p>VLE
N/SEW/8</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">v</span></code> n
(グ
ループ
内にレ
ジスタ
は1つ)</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>1/4</p></td>
<td><p>32</p></td>
<td><p>VLE
N/SEW/4</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">v</span></code> n
(グ
ループ
内にレ
ジスタ
は1つ)</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>1/2</p></td>
<td><p>32</p></td>
<td><p>VLE
N/SEW/2</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">v</span></code> n
(グ
ループ
内にレ
ジスタ
は1つ)</p></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>32</p></td>
<td><p>V
LEN/SEW</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">v</span></code> n
(グ
ループ
内にレ
ジスタ
は1つ)</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>2</p></td>
<td><p>16</p></td>
<td><p>2*V
LEN/SEW</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">v</span></code>
n,
<code class="docutils literal notranslate"><span class="pre">v</span></code>
n+1</p></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>4</p></td>
<td><p>8</p></td>
<td><p>4*V
LEN/SEW</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">v</span></code>
n, …,
<code class="docutils literal notranslate"><span class="pre">v</span></code>
n+3</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>8</p></td>
<td><p>4</p></td>
<td><p>8*V
LEN/SEW</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">v</span></code>
n, …,
<code class="docutils literal notranslate"><span class="pre">v</span></code>
n+7</p></td>
</tr>
</tbody>
</table>
<p>LMUL=2の場合、ベクトルレジスタ<code class="docutils literal notranslate"><span class="pre">v</span></code>nはベクトルレジスタ<code class="docutils literal notranslate"><span class="pre">v</span></code>n+1も含み、2倍のビット長を操作することになる。ベクトルオペランドにより指定されるオペランドで、奇数番号のベクトルレジスタを指定した場合は不定命令例外が発生する。</p>
<p>LMUL=4である場合、ベクトル命令は4つのベクトルレジスタを同時に操作する。また、ベクトル命令により指定されるベクトルオペランドが4の倍数でなかった場合は不定命令例外が発生する。</p>
<p>LMUL=8である場合は、8つのベクトルレジスタを同時に操作し、ベクトルオペランドとして使用されるベクトルレジスタが8の倍数でない場合は不定命令例外が発生する。</p>
<p>レジスタマスク命令は、LMULの設定に関係なく常に単一ベクトルレジスタに対して機能する。</p>
</div>
<div class="section" id="vector-tail-agnosticvector-mask-agnostic-vtavma">
<h3>3.3.3 Vector Tail AgnosticとVector Mask Agnostic: <code class="docutils literal notranslate"><span class="pre">vta</span></code>と<code class="docutils literal notranslate"><span class="pre">vma</span></code><a class="headerlink" href="#vector-tail-agnosticvector-mask-agnostic-vtavma" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>これらの2ビットは書き込みレジスタのTail要素と書き込みレジスタのマスクオフ要素されたインアクティブな要素について、ベクトル命令実行中の動作を変更することができる。Tailおよびインアクティブな要素には、ベクトル演算の結果が反映されない要素が含まれており、#(Prestart,
Actvie Inactive, BodyおよびTail要素の定義)で定義されている。</p>
<p>全てのシステムは以下の4つの動作をサポートしなければならない。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 26%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><code class="docutils literal notranslate"><span class="pre">vta</span></code></p></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">vma</span></code></p></th>
<th class="head"><p>テール要素</p></th>
<th class="head"><p>インアクティブ要素</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>undisturbed</p></td>
<td><p>undisturbed</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>undisturbed</p></td>
<td><p>agnostic</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>agnostic</p></td>
<td><p>undisturbed</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>agnostic</p></td>
<td><p>agnostic</p></td>
</tr>
</tbody>
</table>
<p>Undisturbedに設定されている場合、該当する書き込み要素は、これまでに保持していた値をそのまま保持する。</p>
<p>Agnosticに設定されている場合、該当するベクトルの書き込み要素は、これまでに保持していた値をそのまま保持するか、すべてのビットを1で上書きする。単一のベクトル命令では、核書き込み要素はUndisturbedもしくは1の上書きのどちらも動作することができる。Undisturbedもしくは1の上書きは同じ入力に対して決定的である必要はない。</p>
<blockquote>
<div><p>ベクトルレジスタのリネーミングが行われるマシンや、一時的なベクトルレジスタが深いマシンに対応するために、Agnosticポリシーが追加された。Undisturbedポリシーでは、すべての要素を古い物理的な書き込みベクトルレジスタから読み取って、新しい物理書き込みレジスタにコピーする必要がある。これにより、これらのインアクティブ値またはテール要素が後続の計算に必要ない場合に効率が落ちる。</p>
</div></blockquote>
<blockquote>
<div><p>この仕様の目的は、ソフトウェアにとって、それぞれのセットの値が重要でない場合にAgnosticポリシーを選択することにより、マイクロアーキテクチャの負担を軽減することを目的にしている。</p>
<p>ソフトウェア開発者が書き込まれた値に依存することを防ぐために上書き値にはすべて0ではなくすべて1の値が選択された。</p>
</div></blockquote>
<blockquote>
<div><p>単純なインオーダ―の実装では、設定を無視して、Undisturbedポリシーを使用してすべてのベクトル命令を実行できる。互換性とスレッド移行をサポートするために、<code class="docutils literal notranslate"><span class="pre">vta</span></code>および<code class="docutils literal notranslate"><span class="pre">vma</span></code>状態ビットをvtypeで提供する必要がある。</p>
<p>アウトオブオーダ実行の実装では、実装の複雑さを軽減するために、テール要素をAgnostic+マスク要素をUndisturbedを使用してテール要素をAgnostic+マスク要素をAgnosticの実装を選択することで実装の複雑性を削減することができる。</p>
</div></blockquote>
<blockquote>
<div><p>Agnosticポリシーの定義は、小さなインオーダコアのハート(おそらくAgnosticの領域をUndisturbedにする)と、レジスタリネーミング(おそらくAgnosticを1で上書きする)の大きなアウトオブオーダーコアのハート間でのアプリケーションスレッドの移行に対応するために緩められていいる。
途中で再起動する必要がある場合のため、単一のベクトル命令内でAgnosticポリシーを任意に混在させることができる。
これにより、ポリシーの混合が可能になり、ベクトルレジスタのさまざまな粒度のポリシーを変更する可能性のある実装も可能となる。たとえば、アクティブに操作されている粒度内で影響を受けずに、リネーミングによりテールの粒度のすべて1に変更するなど。</p>
</div></blockquote>
<p>アセンブリ命令では、2つのフラグが<code class="docutils literal notranslate"><span class="pre">vsetvli</span></code>命令に追加されている。</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="nf">ta</span>   <span class="c1"># Tail agnostic</span>
<span class="nf">tu</span>   <span class="c1"># Tail undisturbed</span>
<span class="nf">ma</span>   <span class="c1"># Mask agnostic</span>
<span class="nf">mu</span>   <span class="c1"># Mask undisturbed</span>

<span class="nf">vsetvli</span> <span class="no">t0</span><span class="p">,</span> <span class="no">a0</span><span class="p">,</span> <span class="no">e32</span><span class="p">,</span><span class="no">m4</span><span class="p">,</span><span class="no">ta</span><span class="p">,</span><span class="no">ma</span>   <span class="c1"># Tail agnostic, mask agnostic</span>
<span class="nf">vsetvli</span> <span class="no">t0</span><span class="p">,</span> <span class="no">a0</span><span class="p">,</span> <span class="no">e32</span><span class="p">,</span><span class="no">m4</span><span class="p">,</span><span class="no">tu</span><span class="p">,</span><span class="no">ma</span>   <span class="c1"># Tail undisturbed, mask agnostic</span>
<span class="nf">vsetvli</span> <span class="no">t0</span><span class="p">,</span> <span class="no">a0</span><span class="p">,</span> <span class="no">e32</span><span class="p">,</span><span class="no">m4</span><span class="p">,</span><span class="no">ta</span><span class="p">,</span><span class="no">mu</span>   <span class="c1"># Tail agnostic, mask undisturbed</span>
<span class="nf">vsetvli</span> <span class="no">t0</span><span class="p">,</span> <span class="no">a0</span><span class="p">,</span> <span class="no">e32</span><span class="p">,</span><span class="no">m4</span><span class="p">,</span><span class="no">tu</span><span class="p">,</span><span class="no">mu</span>   <span class="c1"># Tail undisturbed, mask undisturbed</span>
</pre></div>
</div>
<blockquote>
<div><p>短期的に下位互換性を維持し、0.9への移行でソフトウェアチューニングを軽減するために、これらのフラグが<code class="docutils literal notranslate"><span class="pre">vsetvli</span></code>で指定されていない場合、デフォルトでmask-undisturbed
/ tail-undisturbedにする必要がある。
ただし、これらのフラグなしで<code class="docutils literal notranslate"><span class="pre">vsetvli</span></code>を使用することは非推奨にして、フラグ設定の指定が必須になるようにする必要がある。どちらかといえば、デフォルトはテールにとらわれない/マスクにとらわれないはずなので、ソフトウェアは実行対象ではない要素をいつ気にするかを指定する必要があるが、これらのフラグを導入する前の命令の歴史的な意味を考えると、常に最も安全だが、将来のアセンブリコードでこれらのフラグの設定が必須となる。</p>
</div></blockquote>
</div>
<div class="section" id="vill">
<h3>3.3.4. ベクトルタイプ不正 <code class="docutils literal notranslate"><span class="pre">vill</span></code><a class="headerlink" href="#vill" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">vill</span></code>では直前に実行された<code class="docutils literal notranslate"><span class="pre">vsetvl{i}</span></code>命令によりサポートされない値が<code class="docutils literal notranslate"><span class="pre">vtype</span></code>に書き込まれたことをエンコードするために使用される。</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">vill</span></code>ビットはCSRのXLEN-1ビットにより設定される。これにより、不正な値が設定されたかどうかを符号判定の分岐命令により判定できる。</p>
</div></blockquote>
<p>もし、<code class="docutils literal notranslate"><span class="pre">vill</span></code>ビットが設定されている場合、どのようなベクトル命令(ベクトルコンフィグレーション命令以外)を実行しても不定命令例外が発生する。</p>
<p><code class="docutils literal notranslate"><span class="pre">vill</span></code>が設定されていると、<code class="docutils literal notranslate"><span class="pre">vtype</span></code>の他の<code class="docutils literal notranslate"><span class="pre">XLEN-1</span></code>ビットは0に設定される。</p>
</div>
</div>
<div class="section" id="vl">
<h2>3.3. ベクトル長レジスタ<code class="docutils literal notranslate"><span class="pre">vl</span></code><a class="headerlink" href="#vl" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>XLENビット長の読み込み専用CSRである<code class="docutils literal notranslate"><span class="pre">vl</span></code>は<code class="docutils literal notranslate"><span class="pre">vsetvli</span></code>および<code class="docutils literal notranslate"><span class="pre">vsetvl</span></code>命令でのみアップデートすることができるレジスタで、<strong>fault-only-first</strong>ベクトルロード命令バリアントである。</p>
<p><code class="docutils literal notranslate"><span class="pre">vl</span></code>レジスタは、ベクトル命令によりアップデートされる要素の数を符号なし整数として保持している。任意の書き込み先ベクトルレジスタグループにおいて、インデックスが<code class="docutils literal notranslate"><span class="pre">vl</span></code>以上の場合は、ベクトル命令が実行されても何も変化しない。<code class="docutils literal notranslate"><span class="pre">vstart</span></code>≥<code class="docutils literal notranslate"><span class="pre">vl</span></code>の場合、書き込み先ベクトルレジスタグループにおいてどのような要素もアップデートされない。</p>
<blockquote>
<div><p>結論として、<code class="docutils literal notranslate"><span class="pre">vl</span></code>=0の場合は<code class="docutils literal notranslate"><span class="pre">vstart</span></code>の値にかかわらず書き込み先ベクトルレジスタグループには何も書きこまれない。</p>
</div></blockquote>
<blockquote>
<div><p>スカラ整数レジスタもしくはスカラ浮動小数点レジスタの場合は<code class="docutils literal notranslate"><span class="pre">vstart</span></code>≦<code class="docutils literal notranslate"><span class="pre">vl</span></code>でも実行される。</p>
<p><code class="docutils literal notranslate"><span class="pre">vl</span></code>に実装されるビットの長さは、その実装が最小のデータタイプにおいて実行することができる最大の要素数に依存する。最小のベクトル実装であるRV32IVでは、少なくとも<code class="docutils literal notranslate"><span class="pre">vl</span></code>では0-32までの値を保持する(VLEN=32,
LMUL=8, SEW=8でVLMAXが32となる)を保持するために6ビットが必要となる。</p>
</div></blockquote>
</div>
<div class="section" id="vlenb">
<h2>3.4 ベクトルバイト長レジスタ<code class="docutils literal notranslate"><span class="pre">vlenb</span></code><a class="headerlink" href="#vlenb" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">XLEN</span></code>ビット長の読み込み専用CSRレジスタ<code class="docutils literal notranslate"><span class="pre">vlenb</span></code>はVLEN/8の値、つまりバイト単位でのベクトル長を保持する。</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">vlenb</span></code>の値は任意の実装において、設計時に決められる定数である。</p>
</div></blockquote>
<blockquote>
<div><p>このCSRを使わない場合、いくつかの命令を実行してVLENのバイト単位での値を計算する必要がある。退避の必要な現在の<code class="docutils literal notranslate"><span class="pre">vl</span></code>および<code class="docutils literal notranslate"><span class="pre">vtype</span></code>の値を取得して計算を行う必要がある。</p>
</div></blockquote>
</div>
<div class="section" id="csrvstart">
<h2>3.5. ベクトルスタートインデックスCSR<code class="docutils literal notranslate"><span class="pre">vstart</span></code><a class="headerlink" href="#csrvstart" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">vsatrt</span></code>は読み込み専用のCSRで、ベクトル命令により実行される最初の要素のインデックスを示している。</p>
<p>通常、<code class="docutils literal notranslate"><span class="pre">vstart</span></code>はベクトル命令の例外時にハードウェアにより書き込まれる。<code class="docutils literal notranslate"><span class="pre">vsatrt</span></code>の値はどの要素により例外がが発生したか(同期例外及び非同期例外で同様である)を示しており、復帰可能な例外である場合は、どの場所から復帰するかを示している。</p>
<p>すべてのベクトル命令は<code class="docutils literal notranslate"><span class="pre">vstart</span></code>CSRで示されるエレメントの場所から実行され、例外が発生した要素よりも前の要素の結果が邪魔されることがないように設計されている。命令の実行が完了すると、<code class="docutils literal notranslate"><span class="pre">vstart</span></code>CSRは0にリセットされる。</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">vsetvl{i}</span></code>命令を含むすべてのベクトル命令は<code class="docutils literal notranslate"><span class="pre">vstart</span></code>CSRをゼロに設定する。</p>
</div></blockquote>
<p>不定命令例外を発生させたベクトル命令では、<code class="docutils literal notranslate"><span class="pre">vstart</span></code>の値は変更されない。</p>
<p><code class="docutils literal notranslate"><span class="pre">vstart</span></code>レジスタの値が<code class="docutils literal notranslate"><span class="pre">vl</span></code>以上場合は、どの要素にも実行されず、書き込みベクトルレジスタの<code class="docutils literal notranslate"><span class="pre">vl</span></code>がゼロに設定されることはない。</p>
<p><code class="docutils literal notranslate"><span class="pre">vstart</span></code>CSRは最大の要素インデックス(VLMAXよりも1つ小さな値)もしくはlg2(VLEN)まで書き込むことができるようなビットサイズが定義される。<code class="docutils literal notranslate"><span class="pre">vstart</span></code>CSRの上位のビットはハード的にゼロが設定される(ゼロ読み出し、書き込みは無視される)。</p>
<blockquote>
<div><p>ベクトル長の最大値はLMULの最大設定値(8)およびSEWの最小値(8)により計算され、VLMAX_max=8*VLEN/8=VLENとなる。例えば、VLEN=256であれば、<code class="docutils literal notranslate"><span class="pre">vstart</span></code>は8ビットであり、0から255までを表現することができる。</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">vstart</span></code>CSRは非特権コードにより書き込みを行うことができるが、いくつかの実装では<code class="docutils literal notranslate"><span class="pre">vstart</span></code>にゼロ以外の値を書き込むと大幅に速度が低下する可能性がある。したがって、<code class="docutils literal notranslate"><span class="pre">vstart</span></code>はアプリケーションプログラマが使用すべきではない。いくつかのベクトル命令では<code class="docutils literal notranslate"><span class="pre">vstart</span></code>が非ゼロの場合には実行することができず、以下に定義された不定命令例外が発生する。</p>
<blockquote>
<div><p>特権用以外のコードでも<code class="docutils literal notranslate"><span class="pre">vstart</span></code>が見えることによって、ユーザレベルのスレッドライブラリをサポートすることができる。</p>
</div></blockquote>
<p>実装では、<code class="docutils literal notranslate"><span class="pre">vstart</span></code>の値に何らかの値が設定されている状態では例外を発生することを許しており、そのような実装では同じ<code class="docutils literal notranslate"><span class="pre">vtype</span></code>設定においてベクトル命令は結果を生成しない。</p>
<blockquote>
<div><p>たとえば、いくつかの実装ではベクトル算術演算を実行中には決して例外を発生せず、命令の実行が完了するまで例外の発生を待つことができる。このような実装ではベクトル算術演算命令において<code class="docutils literal notranslate"><span class="pre">vstart</span></code>が非ゼロである場合は例外が発生することを許している。</p>
</div></blockquote>
</div>
<div class="section" id="vxrm">
<h2>3.6. ベクトル固定小数点丸めモードレジスタ<code class="docutils literal notranslate"><span class="pre">vxrm</span></code><a class="headerlink" href="#vxrm" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトル固定小数点丸めモードレジスタは2ビットのRead-Write丸めモードビットフィールドを持っている。ベクトル固定小数点丸めは<code class="docutils literal notranslate"><span class="pre">fcsr</span></code>レジスタの上位ビットのビットフィールドを反映しているが、異なるCSRビットアドレスが割り当てられている。浮動小数点を持たないシステムの場合は、ベクトル拡張を追加する場合には<code class="docutils literal notranslate"><span class="pre">fcsr</span></code>レジスタを追加する必要がある。</p>
<p>固定小数点の丸めアルゴリズムは以下のように指定される。丸め前の値が<code class="docutils literal notranslate"><span class="pre">v</span></code>であり、<code class="docutils literal notranslate"><span class="pre">d</span></code>ビット長であるとする。この場合丸め後の値は<code class="docutils literal notranslate"><span class="pre">(v</span> <span class="pre">&gt;&gt;</span> <span class="pre">d)</span> <span class="pre">+</span> <span class="pre">r</span></code>であり、<code class="docutils literal notranslate"><span class="pre">r</span></code>は以下に示す丸めモードの表によって決定される。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 14%" />
<col style="width: 9%" />
<col style="width: 31%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Bits [1]</p></th>
<th class="head"><p>Bits[0]</p></th>
<th class="head"><p>略称</p></th>
<th class="head"><p>丸めモード</p></th>
<th class="head"><p>丸めイン
クリメント<code class="docutils literal notranslate"><span class="pre">r</span></code></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>rnu</p></td>
<td><p>r
ound-to-nearest-up
(add +0.5 LSB)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">v[d-1]</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>rne</p></td>
<td><p>rou
nd-to-nearest-even</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">v[d-1</span>
<span class="pre">]</span> <span class="pre">&amp;</span> <span class="pre">(v[d-2:0]!=0</span></code></p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>rdn</p></td>
<td><p>round-down
(truncate)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">0</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>rod</p></td>
<td><p>round-to-odd (OR
bits into LSB, aka
“jam”)</p></td>
<td><dl class="simple">
<dt><a href="#id6"><span class="problematic" id="id7">``</span></a>!v[d]</dt><dd><p>&amp; v[d-1:0] != 0``</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>以下の丸め関数は、命令の説明時に丸めの操作を説明表現するために使用する。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">roundoff</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="n">r</span>
</pre></div>
</div>
<p>Bits[XLEN-1:2]はゼロである。</p>
<blockquote>
<div><p>丸めモードは<code class="docutils literal notranslate"><span class="pre">csrwi</span></code>命令により1命令で設定できる。</p>
</div></blockquote>
</div>
<div class="section" id="vxsat">
<h2>3.7. ベクトル固定小数点飽和フラグ<code class="docutils literal notranslate"><span class="pre">vxsat</span></code><a class="headerlink" href="#vxsat" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">vxsat</span></code>CSRは1ビットの読み書き可能なビットを保持しており、固定小数点命令の計算結果が書き込み先レジスタのフォーマットに合わせるために飽和した場合に設定される。</p>
<p><code class="docutils literal notranslate"><span class="pre">vxsat</span></code>ビットは<code class="docutils literal notranslate"><span class="pre">fcsr</span></code>レジスタの上位ビットにミラーリングされる。</p>
</div>
<div class="section" id="fcsr">
<h2>3.7. <code class="docutils literal notranslate"><span class="pre">fcsr</span></code>のベクトル固定小数点フィールド<a class="headerlink" href="#fcsr" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">vxrm</span></code>および<code class="docutils literal notranslate"><span class="pre">vxsat</span></code>は分離されたCSRであり浮動小数点CSR<code class="docutils literal notranslate"><span class="pre">fcsr</span></code>からアクセスすることができる。<code class="docutils literal notranslate"><span class="pre">fcsr</span></code>レジスタは浮動小数点をサポートしていない実装でも、ベクトル拡張をサポートしている場合には追加する必要がある。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 12%" />
<col style="width: 18%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Bits</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>10:9</p></td>
<td><p>vxrm</p></td>
<td><p>固定小数点丸めモード</p></td>
</tr>
<tr class="row-odd"><td><p>8</p></td>
<td><p>vxsat</p></td>
<td><p>固定小数点精度飽和フラグ</p></td>
</tr>
<tr class="row-even"><td><p>7:5</p></td>
<td><p>frm</p></td>
<td><p>浮動小数点丸めモード</p></td>
</tr>
<tr class="row-odd"><td><p>4:0</p></td>
<td><p>fflags</p></td>
<td><p>浮動小数点例外フラグ</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><p>これらのフィールドは<code class="docutils literal notranslate"><span class="pre">fcsr</span></code>にパッキングされるのは、コンテキストの保存と回復を高速化させるためである。</p>
</div></blockquote>
</div>
<div class="section" id="id8">
<h2>3.8. ベクトル拡張のリセット状態について<a class="headerlink" href="#id8" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトル拡張はリセット時に矛盾の発生していない状態でなければならない。特に、<code class="docutils literal notranslate"><span class="pre">vtype</span></code>および<code class="docutils literal notranslate"><span class="pre">vl</span></code>は<code class="docutils literal notranslate"><span class="pre">vsetvl</span></code>命令により読み込みおよびリストアできなければならない。</p>
<blockquote>
<div><p>リセット時には<code class="docutils literal notranslate"><span class="pre">vtype.vill</span></code>は1が設定されており、残りの<code class="docutils literal notranslate"><span class="pre">vtype</span></code>レジスタはゼロが設定されており、<code class="docutils literal notranslate"><span class="pre">vl</span></code>は0が設定されている状態が推奨される。</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">vstart</span></code>, <code class="docutils literal notranslate"><span class="pre">vxrm</span></code>
,<code class="docutils literal notranslate"><span class="pre">vxsat</span></code>CSRはリセット時にはどのような値が設定されていても構わない。</p>
<blockquote>
<div><p>ベクトルユニットを使用するときはいかなる時も最初に<code class="docutils literal notranslate"><span class="pre">vsetvl{i}</span></code>を実行し、<code class="docutils literal notranslate"><span class="pre">vstart</span></code>をリセットさせる必要がある。<code class="docutils literal notranslate"><span class="pre">vxrm</span></code>および<code class="docutils literal notranslate"><span class="pre">vxsat</span></code>フィールドはソフトウェアにより使用前に明示的にリセットを行うべきである。</p>
</div></blockquote>
<p>ベクトルレジスタはリセット時にはどのような値が設定されていても構わない。</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="chapter4_mapping_vector_elements.html" class="btn btn-neutral float-right" title="4. ベクトル要素のベクトルレジスタへの割り付け" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="RISC-V “V” Extension" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; 著作権 2019, msyksphinz

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>