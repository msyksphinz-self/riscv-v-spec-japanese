

<!DOCTYPE html>
<html class="writer-html5" lang="ja" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>v1.0-rc1からの変更点 &mdash; riscv-v-spec-japanese  ドキュメント</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script src="_static/translations.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" />
    <link rel="prev" title="RISC-V &#34;V&#34; ベクトル拡張" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> riscv-v-spec-japanese
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">v1.0-rc1からの変更点</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">現在まで変更なし。</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#id2">イントロダクション</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id3">実装により定義される定数パラメータ</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id4">ベクトル拡張のプログラミングモデル</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id5">ベクトルレジスタ</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mstatus"><cite>mstatus</cite> 内のベクトルコンテキストステータス</a></li>
<li class="toctree-l2"><a class="reference internal" href="#vtype">ベクトル型レジスタ <cite>vtype</cite></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#vsew-2-0">ベクトル選択要素幅 <cite>vsew[2:0]</cite></a></li>
<li class="toctree-l3"><a class="reference internal" href="#vlmul-2-0">ベクトルレジスタのグループ化(<cite>vlmul[2:0]</cite>)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tail-agnostic-vector-mask-agnostic-vta-vma">Tail Agnostic とVector Mask Agnostic <cite>vta</cite> と <cite>vma</cite></a></li>
<li class="toctree-l3"><a class="reference internal" href="#vill">不正ベクトル型 <cite>vill</cite></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#vl">ベクトル長レジスタ <cite>vl</cite></a></li>
<li class="toctree-l2"><a class="reference internal" href="#vlenb">ベクトルバイト長 <cite>vlenb</cite></a></li>
<li class="toctree-l2"><a class="reference internal" href="#csr-vstart">ベクトルスタートインデックスCSR <cite>vstart</cite></a></li>
<li class="toctree-l2"><a class="reference internal" href="#vxrm">ベクトル固定小数点丸めモードレジスタ <cite>vxrm</cite></a></li>
<li class="toctree-l2"><a class="reference internal" href="#vxsat">ベクトル固定小数点飽和フラグ <cite>vxsat</cite></a></li>
<li class="toctree-l2"><a class="reference internal" href="#vector-vcsr">Vector 制御・ステータスレジスタ <cite>vcsr</cite></a></li>
<li class="toctree-l2"><a class="reference internal" href="#id12">リセット時のベクトル拡張の状態</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#id13">ベクトルレジスタ状態へのベクトル要素のマッピング</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#lmul-1">LMUL = 1 時のマッピング</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id14">LMUL &lt; 1の場合のマッピング</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id15">LMUL &gt; 1 のマッピング</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id16">混合幅演算でのマッピングについて</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lmul-1-elen-vlen">LMUL &gt; 1 かつ ELEN &gt; VLEN のマッピング</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sec-mask-register-layout">マスクレジスタのレイアウト</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id18">マスク要素の場所</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#id19">ベクトル命令フォーマット</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id20">スカラオペランド</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id21">ベクトルオペランド</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id22">ベクトルマスキング</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#sec-vector-mask-encoding">マスクエンコーディング</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#sec-inactive-defs">プリスタート、アクティブ、非アクティブ、ボディ、末尾要素の定義</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#vsetvli-vsetivl-vsetvl">コンフィグレーション設定命令 (<cite>vsetvli</cite>/<cite>vsetivl</cite>/<cite>vsetvl</cite>)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id29"><cite>vtype</cite> エンコーディング</a></li>
<li class="toctree-l2"><a class="reference internal" href="#avl">AVLのエンコーディング</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id30"><cite>vl</cite> 設定の制約</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sew">ストリップマイニングとSEW変更の例</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#sec-vector-memory">ベクトルロード・ストア命令</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id32">ベクトルロードストア命令のエンコーディング</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id33">ベクトルロードストアアドレッシングモード</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sec-vector-loadstore-width-encoding">ベクトルロードストア幅のエンコーディング</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id35">ベクトルユニットストライド命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id36">ベクトルストライド命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id37">ベクトルインデックス命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fault-only-first">ユニットストライドFault-Only-Firstロード</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sec-aos">ベクトルロードストアセグメント命令</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id43">ベクトルユニットストライドセグメントロードストア命令</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id44">ベクトルストライドセグメントロードストア命令</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id45">ベクトルインデックスセグメントロードストア命令</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id46">ベクトル全体レジスタロードストア命令</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#id57">ベクトルメモリアラインメント制約</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id58">ベクトルメモリコンシステンシモデル</a></li>
<li class="toctree-l1"><a class="reference internal" href="#id59">ベクトル算術演算命令</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#sec-arithmetic-encoding">ベクトル算術演算命令エンコーディング</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sec-widening">幅拡張ベクトル算術演算命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sec-narrowing">ベクトル幅縮小算術演算命令</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#sec-vector-integer">ベクトル整数算術演算命令</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id64">ベクトル単一幅整数加算減算命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id65">ベクトル幅拡張整数加減算命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id66">ベクトル整数拡張</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id67">ベクトル整数 キャリー付き加算 / ボロー付き減算命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id68">ベクトル論理命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id69">ベクトル単一幅ビットシフト命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id70">ベクトルサイズ幅縮退整数右シフト命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id71">ベクトル整数比較命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id72">ベクトル整数最大/最小命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id73">ベクトル単一幅整数乗算命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id74">ベクトル整数除算命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id75">ベクトル幅拡張乗算命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id76">ベクトル単一幅整数乗算加算命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id77">ベクトル幅拡張整数乗算加算命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id78">ベクトル整数マージ命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id79">ベクトル整数移動命令</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#sec-vector-fixed-point">ベクトル固定小数点算術演算命令</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id83">ベクトル単一幅飽和加算と飽和減算</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id84">ベクトル単一幅平均加算と平均減算命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id85">丸めと飽和を用いたベクトル単一幅分数乗算</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id86">ベクトル単一幅スケーリングシフト命令</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id87">ベクトル固定小数点幅縮小クリップ命令</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#sec-vector-float">ベクトル浮動小数点命令</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id89">ベクトル浮動小数点例外フラグ</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id90">ベクトル単一幅浮動小数点加減算命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id91">ベクトル幅拡張浮動小数点加減算命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id92">ベクトル単一幅浮動小数点乗算除算命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id93">ベクトル幅拡張浮動小数点乗算命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id94">ベクトル単一幅浮動小数点複合乗算加算命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id95">ベクトル幅拡張浮動小数点複合乗算加算命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id96">ベクトル浮動小数点平方根命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id97">ベクトル浮動小数点逆平方根推定命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id98">ベクトル浮動小数点逆数推定命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#min-max">ベクトル浮動小数点MIN/MAX命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id103">ベクトル浮動小数点符号挿入命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id104">ベクトル浮動小数点比較命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id105">ベクトル浮動小数点分類命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id106">ベクトル浮動小数点マージ命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id107">ベクトル浮動小数点移動命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id108">単一幅浮動所数点/整数型変換命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id109">幅拡張浮動小数点/整数型変換命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id110">浮動小数点/整数 幅縮小型変換命令</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#id111">ベクトルリダクション操作</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#sec-vector-integer-reduce">ベクトル単一幅整数リダクション命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sec-vector-integer-reduce-widen">ベクトル幅拡張整数リダクション命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sec-vector-float-reduce">ベクトル単一幅浮動小数点リダクション命令</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id117">ベクトル順序付き単一幅浮動小数点リダクション加算命令</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id118">ベクトル順序無し単一幅浮動小数点リダクション加算命令</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id119">ベクトル単一幅浮動小数点最大・最小リダクション</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#sec-vector-float-reduce-widen">ベクトル幅拡張浮動小数点リダクション命令</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#sec-vector-mask">ベクトルマスク命令</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#sec-mask-register-logical">ベクトルマスクレジスタ論理命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pop-vpopc">ベクトルマスクPopカウント <cite>vpopc</cite></a></li>
<li class="toctree-l2"><a class="reference internal" href="#vfirst-find-first-set"><cite>vfirst</cite> find-first-set マスクビット命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#vmsbf-m-set-before-first"><cite>vmsbf.m</cite> set-before-firstマスクビット</a></li>
<li class="toctree-l2"><a class="reference internal" href="#vmsif-m-set-including-first"><cite>vmsif.m</cite> set-including-first マスクビット命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#vmsof-m-set-only-first"><cite>vmsof.m</cite> set-only-first マスクビット命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id123">ベクトルマスク命令の使用例</a></li>
<li class="toctree-l2"><a class="reference internal" href="#iota">ベクトルIota命令</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#sec-vector-permute">ベクトル組み合わせ命令</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id125">整数スカラ移動命令</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id126">浮動小数点スカラ移動命令</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id127">ベクトルスライド命令</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id128">ベクトルスライドアップ命令</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id129">ベクトルスライドダウン命令</a></li>
<li class="toctree-l3"><a class="reference internal" href="#slide1up">ベクトル Slide1up</a></li>
<li class="toctree-l3"><a class="reference internal" href="#slide1down">ベクトル Slide1down 命令</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id134">ベクトルレジスタギャザー命令</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id135">ベクトル圧縮命令</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#vdecompress"><cite>vdecompress</cite> の合成</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id136">ベクトルレジスタ全体移動命令</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#id137">例外処理</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id138">正確なベクトル例外</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id139">不正確ベクトル例外</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id140">正確・不正確選択可能な例外</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id141">スワップ可能な例外</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#sec-vector-extensions">標準ベクトル拡張</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#zve">Zve*: 組み込みプロセッサ用のベクトル拡張</a></li>
<li class="toctree-l2"><a class="reference internal" href="#v">V: アプリケーションプロセッサのためのベクトル拡張</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#id143">ベクトル命令リスト</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">riscv-v-spec-japanese</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>v1.0-rc1からの変更点</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/v-spec.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <p>Version 1.0-rc2-draft
:doctype: article
:encoding: utf-8
:lang: en
:toc: left
:numbered:
:stem: latexmath
:le: &amp;#8804;
:ge: &amp;#8805;
:ne: &amp;#8800;
:approx: &amp;#8776;
:inf: &amp;#8734;</p>
<p>Contributors include: Alon Amid, Krste Asanovic, Allen Baum, Alex
Bradbury, Tony Brewer, Chris Celio, Aliaksei Chapyzhenka, Silviu
Chiricescu, Ken Dockser, Bob Dreyer, Roger Espasa, Sean Halle, John
Hauser, David Horner, Bruce Hoult, Bill Huffman, Nicholas Knight,
Constantine Korikov,
Ben Korpan, Hanna Kruppe, Yunsup Lee, Guy Lemieux, Grigorios Magklis,
Filip Moc, Rich Newell, Albert Ou, David Patterson, Colin Schmidt,
Alex Solomatnikov, Steve Wallach, Andrew Waterman, Jim Wilson.</p>
<dl class="field-list simple">
<dt class="field-odd">sectnums!</dt>
<dd class="field-odd"><p></p></dd>
</dl>
<div class="section" id="v1-0-rc1">
<h1>v1.0-rc1からの変更点<a class="headerlink" href="#v1-0-rc1" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="section" id="id1">
<h2>現在まで変更なし。<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="field-list simple">
<dt class="field-odd">sectnums</dt>
<dd class="field-odd"><p></p></dd>
</dl>
</div>
</div>
<div class="section" id="id2">
<h1>イントロダクション<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>このドキュメントは、RISC-Vベクトル拡張のバージョン1.0の第2リリース候補のドラフトであり、
パブリックレビューのためのものです。</p>
<p><em>これはパブリックレビュー用の1.0の凍結版ではありません。</em></p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>パブリックレビューのために送り出されることを意図しています。
また、バージョン1.0は、上流のソフトウェアプロジェクトを含め、ツールチェイン、機能シミュレータ、
初期実装の開発を開始するのに十分な安定性があると考えられており、
批准中に重大な問題が発見された場合を除き、
大きな機能変更はないと予想されています。批准されると、仕様書のバージョンは2.0になります。</p>
</div>
<p>本仕様書ドラフトには、現在定義されているベクトル命令の全セットが含まれています。
<a class="reference internal" href="#sec-vector-extensions"><span class="std std-ref">標準ベクトル拡張</span></a>   セクションには、標準的なベクトル拡張機能と、
それぞれの拡張機能でサポートされる命令および要素幅が記載されています。</p>
</div>
<div class="section" id="id3">
<h1>実装により定義される定数パラメータ<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>ベクトル拡張をサポートする各hartには、2つのパラメータが定義されています。</p>
<ul class="simple">
<li><p>任意の演算で生成または消費できるベクトル要素の最大サイズ(ビット) <em>ELEN</em> {ge} 8 で、これは2の累乗でなければなりません。</p></li>
<li><p>1つのベクトルレジスタのビット数 <em>VLEN</em> 、これは2の累乗でなければならず、2の累乗であり、2^16^以上であってはなりません。</p></li>
</ul>
<p>標準的なベクトル拡張(<a class="reference internal" href="#sec-vector-extensions"><span class="std std-ref">標準ベクトル拡張</span></a>  セクション)とアーキテクチャプロファイルは、 <em>ELEN</em> と <em>VLEN</em> にさらなる制約を設定することができます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>(LMUL=8およびSEW=8でVLEN=65,536の場合、最大のVLMAXは65,536になります)。
将来的にクトルレジスタあたり64Kib以上に拡張する場合は、
新しいコンフィグレーション命令が必要になりますが、
従来のコンフィグレーション命令を使用しているソフトウェアでは、
ベクトルの長さが大きくなることはありません。</p>
</div>
<p>ISAは、特定の制約の下で、VLENパラメータの値が異なるhart上でバイナリコードが実行されるポータブルな記述をサポートしていますが、
両方のhartが必要な要素型をサポートしていることが条件となります。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>VLENまたはELENパラメータに違いのあるhart間で実行中にコンテキストを移動するとはできません。</p>
</div>
</div>
<div class="section" id="id4">
<h1>ベクトル拡張のプログラミングモデル<a class="headerlink" href="#id4" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>ベクトル拡張はRISC-VのベーススカラISAに対して、
32本のベクトルレジスタと7つの非特権CSR(<cite>vstart</cite>, <cite>vxsat</cite>, <cite>vxrm</cite>, <cite>vcsr</cite>, <cite>vl</cite>, <cite>vlenb</cite>)が追加されます。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 9%" />
<col style="width: 12%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>アドレス</p></th>
<th class="head"><p>特権</p></th>
<th class="head"><p>名前</p></th>
<th class="head"><p>説明</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x008</p></td>
<td><p>URW</p></td>
<td><p>vstart</p></td>
<td><p>ベクトル操作開始位置</p></td>
</tr>
<tr class="row-odd"><td><p>0x009</p></td>
<td><p>URW</p></td>
<td><p>vxsat</p></td>
<td><p>固定小数点飽和フラグ</p></td>
</tr>
<tr class="row-even"><td><p>0x00A</p></td>
<td><p>URW</p></td>
<td><p>vxrm</p></td>
<td><p>固定小数点丸めモード</p></td>
</tr>
<tr class="row-odd"><td><p>0x00F</p></td>
<td><p>URW</p></td>
<td><p>vcsr</p></td>
<td><p>ベクトル制御・ステータスレジスタ</p></td>
</tr>
<tr class="row-even"><td><p>0xC20</p></td>
<td><p>URO</p></td>
<td><p>vl</p></td>
<td><p>ベクトル長</p></td>
</tr>
<tr class="row-odd"><td><p>0xC21</p></td>
<td><p>URO</p></td>
<td><p>vtype</p></td>
<td><p>ベクトルデータ型レジスタ</p></td>
</tr>
<tr class="row-even"><td><p>0xC22</p></td>
<td><p>URO</p></td>
<td><p>vlenb</p></td>
<td><p>VLEN/8 (バイト単位でのベクトルレジスタ長)</p></td>
</tr>
</tbody>
</table>
<div class="section" id="id5">
<h2>ベクトルレジスタ<a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトル拡張により、RISC-VベーススカラISAに対して
32本のアーキテクチャベクトルレジスタ <cite>v0</cite>-<cite>v31</cite> が追加されます。</p>
<p>各ベクトルレジスタのサイズは固定長でVLENビットです。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>整数レジスタファイル上で実行する新しいISAオプションです。
Vector 1.0拡張はZfinxに対して互換性があります。</p>
</div>
</div>
<div class="section" id="mstatus">
<h2><cite>mstatus</cite> 内のベクトルコンテキストステータス<a class="headerlink" href="#mstatus" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトルコンテキストステータスフィールド <cite>VS</cite> は、
<cite>mstatus[10:9]</cite> に追加され、
<cite>sstatus[10:9]</cite> でシャドウイングされます。
これは、浮動小数点コンテキストステータスフィールドである <cite>FS</cite> と同様に定義されます。</p>
<p><cite>VS</cite> フィールドがOFFに設定されている場合は、
ベクトル命令を実行しようとしたり、ベクトルCSRにアクセスしようとすると、
不正命令例外が発生します。</p>
<p><cite>VS</cite> フィールドがInitialまたはCleanに設定されている場合、
ベクトルCSRを含むベクトルの状態を変更する命令を実行すると、<cite>VS</cite> がDirtyに変更されます。
また、実装では、ベクトルの状態が変化していなくても、
いつでも <cite>VS</cite> フィールドをInitialまたはCleanからDirtyに変更することができます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>ソフトウェアは通常、コンテキストスワップのオーバーヘッドを減らすためにVSを使用します。</p>
</div>
<p>実装では、書き込み可能な <cite>misa.v</cite> フィールドを持つことができます。
浮動小数点演算ユニットの処理方法と同様に、
<cite>misa.v</cite> がクリアされていても <cite>mstatus.vs</cite> フィールドが存在する場合があります。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>ベクトル操作のエミュレーションが可能になり、書き込み可能な <cite>misa.v</cite> を持つシステムでの <cite>mstatus.vs</cite> の処理が簡単になります。</p>
</div>
</div>
<div class="section" id="vtype">
<h2>ベクトル型レジスタ <cite>vtype</cite><a class="headerlink" href="#vtype" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>読み取り専用のXLEN幅を持つ <em>ベクトル</em> <em>型</em> CSR (<cite>vtype</cite>)は、
ベクトルレジスタファイルの内容を解釈するために使用されるデフォルトの型を提供し、
<cite>vset{i}vl{i}</cite> 命令によってのみ更新することができます。
ベクトル型は、各ベクトルレジスタの要素の構成や、複数のベクトルレジスタをどのようにグループ化するかを決定します。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p><cite>vtype</cite> レジスタの状態の維持が容易になります。</p>
</div>
<p><cite>vtype</cite> レジスタには、 <cite>vill</cite> 、 <cite>vma</cite> 、 <cite>vta</cite> 、 <cite>vsew[2:0]</cite> 、 <cite>vlmul[2:0]</cite> の5つのフィールドがあります。</p>
<p>include::vtype-format.adoc[]</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p><cite>ma</cite> と <cite>ta</cite> に 2 ビット、<cite>vsew[1:0]</cite> に 2 ビット、
<cite>vlmul[2:0]</cite> に 3 ビットです。
<cite>vill</cite> で表される不正な値は、<cite>vsew[1:0]</cite> の不正な64ビットの組み合わせを使って内部的にエンコードすることができ、
<cite>vill</cite> を保持するための追加のストレージビットを必要としません。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>より多様なデータ型がサポートされるようになります。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>これらのフィールドを命令エンコーディング内で静的に指定できるようになることが予想されます。</p>
</div>
<div class="section" id="vsew-2-0">
<h3>ベクトル選択要素幅 <cite>vsew[2:0]</cite><a class="headerlink" href="#vsew-2-0" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><cite>vsew</cite> の値は、動的な <em>選択要素幅</em> (SEW)を設定します。
デフォルトでは、ベクトルレジスタは、
VLEN/SEW要素に分割されているとみなされます。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 29%" />
<col style="width: 29%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" colspan="3"><p>vsew[2:0]</p></th>
<th class="head"><p>SEW</p></th>
<th class="head"></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>8</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>16</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>32</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>64</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>128</p></td>
<td><p>予約</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>256</p></td>
<td><p>予約</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>512</p></td>
<td><p>予約</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>1024</p></td>
<td><p>予約</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>より大きな <cite>vsew[2:0]</cite> エンコーディング (<cite>100</cite>-<cite>111</cite>) が使用されることが予想されますが、
このエンコーディングは、現時点では正式には <em>予約</em> です。</p>
</div>
<table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 86%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>SEW</p></td>
<td><p>ベクトルレジスタあたりの要素数</p></td>
</tr>
<tr class="row-even"><td><p>64</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>32</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p>16</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-odd"><td><p>8</p></td>
<td><p>16</p></td>
</tr>
</tbody>
</table>
<p>サポートされる要素の幅はLMULによって異なりますが、
プロファイルはLMUL=1でサポートされなければならない最小のSEWを義務付けている場合があります。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>大きなSEWをサポートする場合があります。
大きなSEWに依存しているソフトウェアは、コードを実行できる実装の数を増やすために、
最大のLMULを使用し、したがって最小のベクトルレジスタグループを使用するようにしてください。
また、<cite>vtype</cite> を設定した後に、<cite>vtype</cite> の <cite>vill</cite> ビットをチェックして、
その構成がサポートされているかどうかを確認し、
サポートされていない場合には、代替のコードパスを提供する必要があります。
また、プロファイルでは、各LMULの設定で最小のSEWを義務付けることもできます。</p>
</div>
</div>
<div class="section" id="vlmul-2-0">
<h3>ベクトルレジスタのグループ化(<cite>vlmul[2:0]</cite>)<a class="headerlink" href="#vlmul-2-0" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>複数のベクトルレジスタをグループ化することで、1つのベクトル命令で複数のベクトルレジスタを操作することができます。
本仕様書では、ベクトル命令の単一オペランドとして使用される1つまたは複数のベクトルレジスタを指すために <em>ベクトルレジスタグループ</em> という用語を使用しています。
ベクトルレジスタグループは、2倍以上の幅の要素を、選択された幅の要素と同じベクトル長で操作することを可能にします。
また、ベクトルレジスタグループは、長いアプリケーションベクトルの実行効率を高めます。</p>
<p>ベクトル長 の倍数 <em>LMUL</em> が1より大きい場合は、ベクトルレジスタグループ形成するために
結合されるベクトルレジスタのデフォルト数を表します。
実装では、LMULは整数値1,2,4,8をサポートする必要があります。</p>
<p>LMUL は、ベクトルレジスタで使用されるビット数を減らすために、小数値を取ることもできます。
LMUL は、1/2、1/4、1/8 の分数値を持つことができます。
小数点以下のLMULは、幅の広いベクトルが複数のベクトルレジスタを使用する必要がないため、
幅の異なる値を操作する際に使用可能なアーキテクチャーレジスタの数を増やすために使用されます。
その代わり、幅の広い値は1つのベクトルレジスタを占有し、
幅の狭い値はベクトルレジスタの端数を占有することができます。</p>
<p>実装では、LMUL {ge}  SEW~LMUL1MIN~/SEW~LMUL1MAX~ の小数の LMUL 設定をサポートする必要があります。
SEW~LMUL1MIN~ はLMUL=1でサポートされる最も狭いSEW値で、
SEW~LMUL1MAX~ はLMUL=1でサポートされる最も広いSEW値です。
サポートされていないSEWとLMULの設定を行おうとすると、 <cite>vtype</cite> の <cite>vill</cite> ビットが設定されます。</p>
<p>サポートされている小数のLMUL設定に対して、
実装はSEW~LMUL1MIN~ とLMUL * SEW~LMUL1MAX~ の間のSEW設定をサポートしなければなりません。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>幅の広い要素を保持するために1つのベクトルレジスタのみを使用し、幅の狭い要素を保持するために小数のLMULを使用することができます。
LMUL &lt; SEW~LMUL1MIN~/SEW~LMUL1MAX~ の場合、VLEN=SEW~LMUL1MAX~ が有効な実装選択であるため、
少なくとも1つの要素を格納するのに十分なビットが小数ベクトル・レジスタにあるという保証はありません。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>この制約はELENではなくSEW~LMUL1MAX~ を使用して記述されています。
このような場合には、コードがより狭い幅の演算も実行しているときに、単一のベクトルレジスタに保持できる最も広くサポートされた要素を保持するために、
単一のベクトルレジスタ以上のものが必要とされないように、制約が保証されることに注意してください。</p>
</div>
<p>LMUL &lt; SEW~LMUL1MIN~/SEW~LMUL1MAX~ での <cite>vtype</cite> エンコーディングの使用は**予約**ですが、
実装はこれらの構成をサポートしていない場合、 <cite>vill</cite> を設定することができます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>将来的に拡張機能でこのケースを使用することができなくなるため、
LMUL&lt;SEW~LMUL1MIN~/SEW~LMUL1MAX~ の動作を将来的に定義できるように、
このケースの使用は <strong>予約</strong> であると考えます。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>エラーではなく警告を出すことを推奨します。</p>
</div>
<p>LMULは、<cite>vtype</cite> の符号付き <cite>vlmul</cite> フィールドで設定されます (LMUL = 2^`vlmul[2:0]`^)。</p>
<p>VLMAX = LMUL*VLEN/SEW の導出値は、以下の表に示すように、
現在のSEWとLMULの設定があれば、1つのベクト命令で操作できる要素の最大数を表します。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 6%" />
<col style="width: 4%" />
<col style="width: 4%" />
<col style="width: 8%" />
<col style="width: 13%" />
<col style="width: 17%" />
<col style="width: 49%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" colspan="3"><p>vlmul[2:0]</p></th>
<th class="head"><p>LMUL</p></th>
<th class="head"><p>#groups</p></th>
<th class="head"><p>VLMAX</p></th>
<th class="head"><p>Registers grouped with register n</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>reserved</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>1/8</p></td>
<td><p>32</p></td>
<td><p>VLEN/SEW/8</p></td>
<td><p>v n (single register in group)</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>1/4</p></td>
<td><p>32</p></td>
<td><p>VLEN/SEW/4</p></td>
<td><p>v n (single register in group)</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>1/2</p></td>
<td><p>32</p></td>
<td><p>VLEN/SEW/2</p></td>
<td><p>v n (single register in group)</p></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>32</p></td>
<td><p>VLEN/SEW</p></td>
<td><p>v n (single register in group)</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>2</p></td>
<td><p>16</p></td>
<td><p>2*VLEN/SEW</p></td>
<td><p>v n, v n+1</p></td>
</tr>
<tr class="row-even"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
<td><p>4</p></td>
<td><p>8</p></td>
<td><p>4*VLEN/SEW</p></td>
<td><p>v n, …, v n+3</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
<td><p>8</p></td>
<td><p>4</p></td>
<td><p>8*VLEN/SEW</p></td>
<td><p>v n, …, v n+7</p></td>
</tr>
</tbody>
</table>
<p>LMUL=2の場合、ベクトレジスタグループには、ベクトレジスタ <cite>v</cite> <a href="#id6"><span class="problematic" id="id7">**</span></a>n**とベクトレジスタ <cite>v</cite> <a href="#id8"><span class="problematic" id="id9">**</span></a>n**+1が含まれ、
ビット単位で2倍のベクト長になります。
LMUL=2のベクトレジスタグループで、奇数番号のベクトレジスタを指定する命令は予約されています。</p>
<p>LMUL=4 の場合、ベクトレジスタグループには 4 個のベクトレジスタが含まれ、
4 の倍数ではないベクトレジスタ番号を使用して
LMUL=4 のベクトレジスタグループを指定する命令は予約されます。</p>
<p>LMUL=8 の場合、ベクトレジスタグループには 8 個のベクトレジスタが含まれ、
8 の倍数ではないレジスタ番号を使用して LMUL=8 ベクトレジスタグループを指定する命令は予約されています。</p>
<p>マスクレジスタは、LMULにかかわらず、常に1つのベクトレジスタとして取り扱われます。</p>
</div>
<div class="section" id="tail-agnostic-vector-mask-agnostic-vta-vma">
<span id="sec-agnostic"></span><h3>Tail Agnostic とVector Mask Agnostic <cite>vta</cite> と <cite>vma</cite><a class="headerlink" href="#tail-agnostic-vector-mask-agnostic-vta-vma" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>これらの2つのビットは、ベクトル命令の実行中に、書き込みレジスタのTail要素および
書き込みレジスタの非アクティブなマスクオフされた要素の動作をそれぞれ変更します。
Tailセットと非アクティブセットには、<a class="reference internal" href="#sec-inactive-defs"><span class="std std-ref">プリスタート、アクティブ、非アクティブ、ボディ、末尾要素の定義</span></a>  項で定義されているように、
ベクトル演算中に新しい結果を受け取らない要素の位置を含んでいます。</p>
<p>すべてのシステムは、4つのオプションすべてをサポートしなければなりません。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 32%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>vta</p></th>
<th class="head"><p>vma</p></th>
<th class="head"><p>末尾要素</p></th>
<th class="head"><p>非アクティブ要素</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>undisturbed</p></td>
<td><p>undisturbed</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>undisturbed</p></td>
<td><p>agnostic</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>agnostic</p></td>
<td><p>undisturbed</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>agnostic</p></td>
<td><p>agnostic</p></td>
</tr>
</tbody>
</table>
<p>セットがundisturbedに設定されている場合、ベクトルレジスタグループ内の対応するセットの書き込み要素は、
以前の値を保持します。
マスクの書き込み値は、<cite>vta</cite> の設定にかかわらず、
常にTail Agnosticとして扱われます。</p>
<p>セットがAgnosticとして設定されている場合、任意のベクトル書き込みオペランドの要素における対応するセットは、
以前保持していた値か、1で上書きされるかのいずれかになります。
1つのベクトル命令の中で、各書き込み要素は、任意の組み合わせで、値を保持したり、1で上書きしたりすることができ、
同じ入力で命令を実行したときに、値を保持するか1で上書きしたりするパタンは、常に決定している必要はありません。
また、マスクロード命令を除き、マスク結果の末尾にある任意の要素には、
マスク生成演算が <a href="#id10"><span class="problematic" id="id11">`</span></a>vl`=VLMAX で計算したであろう値を書き込むこともできます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>深い一時的なベクトルレジスタを持つマシンに対応するために追加されました。
Agnosticなポリシでは、新しい物理書き込みベクトルレジスタにコピーするために、
すべての要素を古い物理書き込みベクトルレジスタから読み込まなければなりません。
これは、これらの非アクティブまたは末尾の要素値が後続の計算に必要でない場合、効率が悪くなります。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>マスクレジスタ値のTail Undisturbedをサポートするソフトウェアの必要性はほとんどないと思われます。
マスクを生成する命令が命令の結果を書き戻すことを許可すると、末尾をマスクアウトするロジックの必要性がなくなります。
ただし、マスクロードは、ソフトウェアの意図を超えてメモリにアクセスすることになるため、
宛先のマスクテールにメモリ値を書き込むことはできません。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>ソフトウェア開発者が書き込まれた値に依存しないようにするためです。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>互換性とスレッドの移行をサポートするために、<cite>vta</cite> と <cite>vma</cite> のステートビットは <cite>vtype</cite> で提供されなければなりません。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>tail-agnostic + mask-agnostic を tail-agnostic + mask-undisturbed を使って実装することを選択できます。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>レジスタリネーミングのある大きなアウトオブオーダコア上のhart(おそらくagnostic要素を1で上書きする)の間でアプリケーションスレッドを
移行することに対応するため、緩く残されています。
途中で再起動する必要があるかもしれないので、1つのベクトル命令の中で、Agnosticなポリシを任意に混在させることができます。
このようなポリシの混在を許容することで、
例えば、アクティブに操作されている要素内ではundisturbedを使用し、テールの要素ではすべて1にリネームするなど、
ベクトルレジスタの異なる要素に対してポリシを変更するような実装も可能になります。</p>
</div>
<p>アセンブリ構文では、 <cite>vsetvli</cite> 命令に2つのフラグが追加されています。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ta</span>   <span class="c1"># Tail agnostic</span>
<span class="n">tu</span>   <span class="c1"># Tail undisturbed</span>
<span class="n">ma</span>   <span class="c1"># Mask agnostic</span>
<span class="n">mu</span>   <span class="c1"># Mask undisturbed</span>

<span class="n">vsetvli</span> <span class="n">t0</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">e32</span><span class="p">,</span> <span class="n">m4</span><span class="p">,</span> <span class="n">ta</span><span class="p">,</span> <span class="n">ma</span>   <span class="c1"># Tail agnostic, mask agnostic</span>
<span class="n">vsetvli</span> <span class="n">t0</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">e32</span><span class="p">,</span> <span class="n">m4</span><span class="p">,</span> <span class="n">tu</span><span class="p">,</span> <span class="n">ma</span>   <span class="c1"># Tail undisturbed, mask agnostic</span>
<span class="n">vsetvli</span> <span class="n">t0</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">e32</span><span class="p">,</span> <span class="n">m4</span><span class="p">,</span> <span class="n">ta</span><span class="p">,</span> <span class="n">mu</span>   <span class="c1"># Tail agnostic, mask undisturbed</span>
<span class="n">vsetvli</span> <span class="n">t0</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">e32</span><span class="p">,</span> <span class="n">m4</span><span class="p">,</span> <span class="n">tu</span><span class="p">,</span> <span class="n">mu</span>   <span class="c1"># Tail undisturbed, mask undisturbed</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>デフォルトで mask-undisturbed/tail-undisturbed とすべきです。
しかし、これらのフラグを持たない <cite>vsetvli</cite> の使用は非推奨とし、
フラグ設定の指定が必須となるようにします。
どちらかというと、デフォルトはtail-agnostic/mask-agnosticにすべきなので、
ソフトウェアは非アクティブ要素を気にするタイミングを指定する必要がありますが、
これらのフラグが導入される前の命令の歴史的な意味を考えると、
将来のアセンブリコードでは常にフラグを要求するのが最も安全です。</p>
</div>
</div>
<div class="section" id="vill">
<h3>不正ベクトル型 <cite>vill</cite><a class="headerlink" href="#vill" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><cite>vill</cite> ビットは、過去の <cite>vset{i}vl{i}</cite> 命令がサポートされていない値を <cite>vtype</cite> に書き込もうとしたことをエンコードするために使用されます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>符号を検査する分岐命令で不正な値をチェックできます。</p>
</div>
<p><cite>vill</cite> ビットがセットされている場合、<cite>vtype</cite> に依存するベクトル命令を実行しようとすると、
不正命令例外が発生します。</p>
<p><cite>vill</cite> ビットがセットされているときは、
<cite>vtype</cite> の他のXLEN-1ビットはゼロでなければなりません。</p>
</div>
</div>
<div class="section" id="vl">
<h2>ベクトル長レジスタ <cite>vl</cite><a class="headerlink" href="#vl" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><em>XLEN</em> ビット幅の読み込み専用 <cite>vl</cite> CSRは、<cite>vset{i}vl{i}</cite> 命令と、
<em>fault-only-first</em> ベクトルロード命令によってのみ更新することができます。</p>
<p><cite>vl</cite> レジスタは、セクション <a class="reference internal" href="#sec-inactive-defs"><span class="std std-ref">プリスタート、アクティブ、非アクティブ、ボディ、末尾要素の定義</span></a>  で詳しく説明されているように、
ベクトル命令の結果で更新される要素数を指定する符号なし整数を保持します。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>VLEN=32 で SEW=8 をサポートする最小のベクトル実装では、0～32 の値を保持するために、
<cite>vl</cite> に少なくとも 6 ビットが必要になります (VLEN=32 で LMUL=8 と SEW=8 を使用すると、VLMAX=32 になります)。</p>
</div>
</div>
<div class="section" id="vlenb">
<h2>ベクトルバイト長 <cite>vlenb</cite><a class="headerlink" href="#vlenb" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><em>XLEN</em> ビット幅の読み取り専用CSR <cite>vlenb</cite> は、値VLEN/8、すなわち、
バイト単位でのベクトルレジスタの長さを保持します。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>コードは現在の <cite>vl</cite> と <cite>vtype</cite> の設定を乱す必要があり、
それらを保存したり復元したりする必要があります。</p>
</div>
</div>
<div class="section" id="csr-vstart">
<h2>ベクトルスタートインデックスCSR <cite>vstart</cite><a class="headerlink" href="#csr-vstart" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>読み書き可能なCSRである <cite>vstart</cite> は、 <a class="reference internal" href="#sec-inactive-defs"><span class="std std-ref">プリスタート、アクティブ、非アクティブ、ボディ、末尾要素の定義</span></a>  項で説明したように、
ベクトル命令で実行される最初の要素のインデックスを指定します。</p>
<p>通常、<cite>vstart</cite> はベクトル命令の例外発生時にハードウェアによってのみ書き込まれ、
<cite>vstart</cite> の値は例外発生した要素 (同期例外または非同期割り込み) を表し、
再開可能な例外が処理された後に実行が再開されるべき要素を表します。</p>
<p>すべてのベクトル命令は、 <cite>vstart</cite> CSR で指定された要素インデックスから実行を開始し、
書き込みベクトル内の以前の要素には影響を与えず、実行終了時には <cite>vstart</cite> CSR をゼロにリセットするように定義されています。</p>
<p><cite>vstart</cite>  は、不正命令例外を発生させるベクトル命令によって変更されません。</p>
<p><cite>vstart</cite> CSR は、最大の要素インデックスを保持するのに十分な書き込み可能なビットのみを持つように定義されます (最大 VLMAX より 1 つ少ない)。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>例えば、VLEN=256の場合、<cite>vstart</cite> は、0から255までのインデックスを表す8ビットを持つことになります。</p>
</div>
<p>現在のSEW設定の最大要素インデックスよりも大きい <cite>vstart</cite> 値の使用は予約されています。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>上位の <cite>vstart</cite> ビットの将来的な使用法として、
不正確な例外情報を保存することが考えられるため、
例外を発生させることは必須ではありません。</p>
</div>
<p><cite>vstart</cite> CSR は非特権コードによって書き込み可能ですが、
非ゼロの <cite>vstart</cite> 値はいくつかの実装でベクトル命令の実行速度を大幅に低下させる可能性があるため、
<cite>vstart</cite> はアプリケーション・プログラマーが使用すべきではありません。
いくつかのベクトル命令は、非ゼロの <cite>vstart</cite> 値では実行できず、
以下に定義するような不正な命令例外を発生させます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>ユーザレベルのスレッディングライブラリをサポートします。</p>
</div>
<p>実装は、同じ <cite>vtype</cite> 設定で同じ命令を実行した場合でも、
実装が決して生成できない <cite>vstart</cite> の値を持つベクトル命令を実行しようとした場合、
不正命令例外を発生させることが許可されています。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>命令が完了するまで待って割り込みを受け取ります。
そのような実装では、 <cite>vstart</cite> が0でないときにベクトル演算命令を実行しようとすると、
不正な命令例外を発生させることができます。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p><cite>vstart</cite> 値は新しい hart のマイクロアーキテクチャーではサポートされていない可能性があります。
その場合、受信側の hart のランタイムは、サポートされている vstart 要素の位置への命令実行をエミュレートしなければならないかもしれません。
あるいは、移行イベントは、相互にサポートされる <cite>vstart</cite> 位置でのみ発生するように制約することもできます。</p>
</div>
</div>
<div class="section" id="vxrm">
<h2>ベクトル固定小数点丸めモードレジスタ <cite>vxrm</cite><a class="headerlink" href="#vxrm" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトル固定小数点丸めモード・レジスタは、2ビットの読み書き可能な丸め込みモード・フィールドを保持します。
ベクトル固定小数点丸め込みモードは、独立してアクセスできるように、
別のCSRアドレスが与えられていますが、 <cite>vcsr</cite> のフィールドとしても反映されています。</p>
<p>固定小数点丸めのアルゴリズムは以下のように規定されています。
丸め前の結果を <cite>v</cite> とし、その結果の <cite>d</cite> ビットを丸めるとします。
このとき、丸められた結果は <cite>(v &gt;&gt; d) + r</cite> となり、 <cite>r</cite>  は次の表にあるように丸めモードに依存します。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 14%" />
<col style="width: 45%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" colspan="2"><p>vxrm[1:0]</p></th>
<th class="head"><p>Abbreviation</p></th>
<th class="head"><p>Rounding Mode</p></th>
<th class="head"><p>Rounding increment, r</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>rnu</p></td>
<td><p>round-to-nearest-up (add +0.5 LSB)</p></td>
<td><p>v[d-1]</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>rne</p></td>
<td><p>round-to-nearest-even</p></td>
<td><p>v[d-1] &amp; (v[d-2:0]≠0 | v[d])</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>rdn</p></td>
<td><p>round-down (truncate)</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>rod</p></td>
<td><p>round-to-odd (OR bits into LSB, aka &quot;jam&quot;)</p></td>
<td><p>!v[d] &amp; v[d-1:0]≠0</p></td>
</tr>
</tbody>
</table>
<p>以下の命令の説明では、丸め関数を表すために以下の操作が使用されています。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">roundoff</span><span class="o">*</span><span class="n">unsigned</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">unsigned</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="n">r</span>
<span class="n">roundoff</span><span class="o">*</span><span class="n">signed</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">signed</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="n">r</span>
</pre></div>
</div>
<p><cite>vxrm[XLEN-1:2]</cite> はゼロが書き込まれるべきです。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>新しい丸め込みモードを設定することができます。</p>
</div>
</div>
<div class="section" id="vxsat">
<h2>ベクトル固定小数点飽和フラグ <cite>vxsat</cite><a class="headerlink" href="#vxsat" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><cite>vxsat</cite> CSRは読み書き可能な1ビットを保持しており、
固定小数点命令が出力値を出力先のフォーマットに収めるために飽和させる必要があったかどうかを示します。</p>
<p><cite>vxsat</cite> ビットは <cite>vcsr</cite> のミラーです。</p>
</div>
<div class="section" id="vector-vcsr">
<h2>Vector 制御・ステータスレジスタ <cite>vcsr</cite><a class="headerlink" href="#vector-vcsr" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><cite>vxrm</cite> と <cite>vxsat</cite> CSRは、ベクトル制御・ステータスCSRである <cite>vcsr</cite> のフィールドを介してアクセスすることもできます。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 11%" />
<col style="width: 20%" />
<col style="width: 69%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Bits</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>2:1</p></td>
<td><p>vxrm[1:0]</p></td>
<td><p>Fixed-point rounding mode</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>vxsat</p></td>
<td><p>Fixed-point accrued saturation flag</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id12">
<h2>リセット時のベクトル拡張の状態<a class="headerlink" href="#id12" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトル拡張は、リセット時に一貫した状態を持っている必要があります。
特に、<cite>vtype</cite> と <cite>vl</cite> は、1つの <cite>vsetvl</cite> 命令で読み取ってから復元できる値を持っていなければなりません。</p>
<p><cite>vstart</cite>, <cite>vxrm</cite>, <cite>vxsat</cite> CSR は、リセット時に任意の値を持つことができます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>これにより <cite>vstart</cite> がリセットされます。
<cite>vxrm</cite> と <cite>vxsat</cite> フィールドは、使用前にソフトウェアで明示的にリセットする必要があります。</p>
</div>
<p>ベクトルレジスタはリセット時に任意の値を持つことができます。</p>
</div>
</div>
<div class="section" id="id13">
<h1>ベクトルレジスタ状態へのベクトル要素のマッピング<a class="headerlink" href="#id13" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>以下の図は、現在のSEWおよびLMULの設定と、実装のVLENに応じて、
異なる幅の要素がどのようにベクトルレジスタのバイトに詰め込まれるかを示しています。
要素は、最下位バイトが最下位ビットになるように各ベクトルレジスタに詰め込まれます。</p>
<div class="section" id="lmul-1">
<h2>LMUL = 1 時のマッピング<a class="headerlink" href="#lmul-1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>LMUL=1の場合、要素はベクトルレジスタの最下位ビットから最上位ビットの順に単純にパックされます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>バイトアドレスが右から左に向かって増加するように並べられています。
要素内のビットはリトルエンディアン形式で番号付けされており、
右から左へのビットインデックスの増加は大きさの増加に対応します。</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// LMUL=1 examples.
LMUL=1の例

The element index is given in hexadecimal and is shown placed at the
least-significant byte of the stored element.

要素のインデックスは16進数で与えられ、
格納された要素の最下位バイトに配置されて表示されます。

 VLEN=32b

 Byte         3 2 1 0

 SEW=8b       3 2 1 0
 SEW=16b        1   0
 SEW=32b            0

 VLEN=64b

 Byte        7 6 5 4 3 2 1 0

 SEW=8b      7 6 5 4 3 2 1 0
 SEW=16b       3   2   1   0
 SEW=32b           1       0
 SEW=64b                   0

 VLEN=128b

 Byte        F E D C B A 9 8 7 6 5 4 3 2 1 0

 SEW=8b      F E D C B A 9 8 7 6 5 4 3 2 1 0
 SEW=16b       7   6   5   4   3   2   1   0
 SEW=32b           3       2       1       0
 SEW=64b                   1               0
 SEW=128b                                  0

 VLEN=256b

 Byte     1F1E1D1C1B1A19181716151413121110 F E D C B A 9 8 7 6 5 4 3 2 1 0

 SEW=8b   1F1E1D1C1B1A19181716151413121110 F E D C B A 9 8 7 6 5 4 3 2 1 0
 SEW=16b     F   E   D   C   B   A   9   8   7   6   5   4   3   2   1   0
 SEW=32b         7       6       5       4       3       2       1       0
 SEW=64b                 3               2               1               0
 SEW=128b                                1                               0
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h2>LMUL &lt; 1の場合のマッピング<a class="headerlink" href="#id14" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>LMUL &lt; 1 の場合、ベクトルレジスタの最初の LMUL*VLEN/SEW 要素のみが使用される。
ベクトルレジスタ内の残りのスペースはテールの一部として扱われるため、
vtaの設定に従わなければなりません。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Example</span><span class="p">,</span> <span class="n">VLEN</span><span class="o">=</span><span class="mi">128</span><span class="n">b</span><span class="p">,</span> <span class="n">LMUL</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span>
<span class="n">VLEN</span><span class="o">=</span><span class="mi">128</span><span class="n">b</span><span class="p">,</span> <span class="n">LMUL</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="n">の例</span>

<span class="n">Byte</span>        <span class="n">F</span> <span class="n">E</span> <span class="n">D</span> <span class="n">C</span> <span class="n">B</span> <span class="n">A</span> <span class="mi">9</span> <span class="mi">8</span> <span class="mi">7</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span>

<span class="n">SEW</span><span class="o">=</span><span class="mi">8</span><span class="n">b</span>      <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span>
<span class="n">SEW</span><span class="o">=</span><span class="mi">16</span><span class="n">b</span>       <span class="o">-</span>   <span class="o">-</span>   <span class="o">-</span>   <span class="o">-</span>   <span class="o">-</span>   <span class="o">-</span>   <span class="mi">1</span>   <span class="mi">0</span>
<span class="n">SEW</span><span class="o">=</span><span class="mi">32</span><span class="n">b</span>           <span class="o">-</span>       <span class="o">-</span>       <span class="o">-</span>       <span class="mi">0</span>
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h2>LMUL &gt; 1 のマッピング<a class="headerlink" href="#id15" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトルレジスタがグループ化されると、ベクトルレジスタグループの要素は、構成するベクトルレジスタ間でストライプされます。
要素は、グループ内の各ベクトルレジスタに要素順に連続して詰められ、
各ベクトルレジスタが満たされると、グループ内の次の最高番号(訳注:ここが上手く訳せない)のベクトルレジスタに移動します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">LMUL</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="n">examples</span>

<span class="n">LMUL</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="n">の例</span>

 <span class="n">VLEN</span><span class="o">=</span><span class="mi">32</span><span class="n">b</span><span class="p">,</span> <span class="n">SEW</span><span class="o">=</span><span class="mi">8</span><span class="n">b</span><span class="p">,</span> <span class="n">LMUL</span><span class="o">=</span><span class="mi">2</span>

 <span class="n">Byte</span>         <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span>
 <span class="n">v2</span><span class="o">*</span><span class="n">n</span>         <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span>
 <span class="n">v2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span>       <span class="mi">7</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">4</span>

 <span class="n">VLEN</span><span class="o">=</span><span class="mi">32</span><span class="n">b</span><span class="p">,</span> <span class="n">SEW</span><span class="o">=</span><span class="mi">16</span><span class="n">b</span><span class="p">,</span> <span class="n">LMUL</span><span class="o">=</span><span class="mi">2</span>

 <span class="n">Byte</span>         <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span>
 <span class="n">v2</span><span class="o">*</span><span class="n">n</span>           <span class="mi">1</span>   <span class="mi">0</span>
 <span class="n">v2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span>         <span class="mi">3</span>   <span class="mi">2</span>

 <span class="n">VLEN</span><span class="o">=</span><span class="mi">32</span><span class="n">b</span><span class="p">,</span> <span class="n">SEW</span><span class="o">=</span><span class="mi">16</span><span class="n">b</span><span class="p">,</span> <span class="n">LMUL</span><span class="o">=</span><span class="mi">4</span>

 <span class="n">Byte</span>         <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span>
 <span class="n">v4</span><span class="o">*</span><span class="n">n</span>           <span class="mi">1</span>   <span class="mi">0</span>
 <span class="n">v4</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span>         <span class="mi">3</span>   <span class="mi">2</span>
 <span class="n">v4</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span>         <span class="mi">5</span>   <span class="mi">4</span>
 <span class="n">v4</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">3</span>         <span class="mi">7</span>   <span class="mi">6</span>

 <span class="n">VLEN</span><span class="o">=</span><span class="mi">32</span><span class="n">b</span><span class="p">,</span> <span class="n">SEW</span><span class="o">=</span><span class="mi">32</span><span class="n">b</span><span class="p">,</span> <span class="n">LMUL</span><span class="o">=</span><span class="mi">4</span>

 <span class="n">Byte</span>         <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span>
 <span class="n">v4</span><span class="o">*</span><span class="n">n</span>               <span class="mi">0</span>
 <span class="n">v4</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span>             <span class="mi">1</span>
 <span class="n">v4</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span>             <span class="mi">2</span>
 <span class="n">v4</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">3</span>             <span class="mi">3</span>

 <span class="n">VLEN</span><span class="o">=</span><span class="mi">64</span><span class="n">b</span><span class="p">,</span> <span class="n">SEW</span><span class="o">=</span><span class="mi">32</span><span class="n">b</span><span class="p">,</span> <span class="n">LMUL</span><span class="o">=</span><span class="mi">2</span>

 <span class="n">Byte</span>         <span class="mi">7</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span>
 <span class="n">v2</span><span class="o">*</span><span class="n">n</span>               <span class="mi">1</span>       <span class="mi">0</span>
 <span class="n">v2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span>             <span class="mi">3</span>       <span class="mi">2</span>

 <span class="n">VLEN</span><span class="o">=</span><span class="mi">64</span><span class="n">b</span><span class="p">,</span> <span class="n">SEW</span><span class="o">=</span><span class="mi">32</span><span class="n">b</span><span class="p">,</span> <span class="n">LMUL</span><span class="o">=</span><span class="mi">4</span>

 <span class="n">Byte</span>         <span class="mi">7</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span>
 <span class="n">v4</span><span class="o">*</span><span class="n">n</span>               <span class="mi">1</span>       <span class="mi">0</span>
 <span class="n">v4</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span>             <span class="mi">3</span>       <span class="mi">2</span>
 <span class="n">v4</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span>             <span class="mi">5</span>       <span class="mi">4</span>
 <span class="n">v4</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">3</span>             <span class="mi">7</span>       <span class="mi">6</span>

 <span class="n">VLEN</span><span class="o">=</span><span class="mi">128</span><span class="n">b</span><span class="p">,</span> <span class="n">SEW</span><span class="o">=</span><span class="mi">32</span><span class="n">b</span><span class="p">,</span> <span class="n">LMUL</span><span class="o">=</span><span class="mi">2</span>

 <span class="n">Byte</span>        <span class="n">F</span> <span class="n">E</span> <span class="n">D</span> <span class="n">C</span> <span class="n">B</span> <span class="n">A</span> <span class="mi">9</span> <span class="mi">8</span> <span class="mi">7</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span>
 <span class="n">v2</span><span class="o">*</span><span class="n">n</span>              <span class="mi">3</span>       <span class="mi">2</span>       <span class="mi">1</span>       <span class="mi">0</span>
 <span class="n">v2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span>            <span class="mi">7</span>       <span class="mi">6</span>       <span class="mi">5</span>       <span class="mi">4</span>

 <span class="n">VLEN</span><span class="o">=</span><span class="mi">128</span><span class="n">b</span><span class="p">,</span> <span class="n">SEW</span><span class="o">=</span><span class="mi">32</span><span class="n">b</span><span class="p">,</span> <span class="n">LMUL</span><span class="o">=</span><span class="mi">4</span>

 <span class="n">Byte</span>          <span class="n">F</span> <span class="n">E</span> <span class="n">D</span> <span class="n">C</span> <span class="n">B</span> <span class="n">A</span> <span class="mi">9</span> <span class="mi">8</span> <span class="mi">7</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span>
 <span class="n">v4</span><span class="o">*</span><span class="n">n</span>                <span class="mi">3</span>       <span class="mi">2</span>       <span class="mi">1</span>       <span class="mi">0</span>
 <span class="n">v4</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span>              <span class="mi">7</span>       <span class="mi">6</span>       <span class="mi">5</span>       <span class="mi">4</span>
 <span class="n">v4</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span>              <span class="n">B</span>       <span class="n">A</span>       <span class="mi">9</span>       <span class="mi">8</span>
 <span class="n">v4</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">3</span>              <span class="n">F</span>       <span class="n">E</span>       <span class="n">D</span>       <span class="n">C</span>
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h2>混合幅演算でのマッピングについて<a class="headerlink" href="#id16" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトルISAは、明示的な追加再配置命令を必要とせずに、混合幅の演算をサポートするように設計されています。
異なる精度のベクトルを操作する場合、推奨されるソフトウェア戦略は、<cite>vtype</cite> を動的に変更して、
SEW/LMULを一定に保つことです(したがって、VLMAXも一定になります)。</p>
<p>次の例では、VLEN=128bの実装において、4つの異なるパックエレメント幅(8b、16b、32b、64b)を示しています。
ベクトルレジスタのグループ化係数(LMUL)は、各グループが同じ数のベクトル要素(この例ではVLMAX=8)を保持できるように、
相対的な要素サイズによって増加し、ストリップマイニングコードを簡素化します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Example</span> <span class="n">VLEN</span><span class="o">=</span><span class="mi">128</span><span class="n">b</span><span class="p">,</span> <span class="k">with</span> <span class="n">SEW</span><span class="o">/</span><span class="n">LMUL</span><span class="o">=</span><span class="mi">16</span>

<span class="n">Byte</span>      <span class="n">F</span> <span class="n">E</span> <span class="n">D</span> <span class="n">C</span> <span class="n">B</span> <span class="n">A</span> <span class="mi">9</span> <span class="mi">8</span> <span class="mi">7</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span>
<span class="n">vn</span>        <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="mi">7</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span>  <span class="n">SEW</span><span class="o">=</span><span class="mi">8</span><span class="n">b</span><span class="p">,</span> <span class="n">LMUL</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span>

<span class="n">vn</span>          <span class="mi">7</span>   <span class="mi">6</span>   <span class="mi">5</span>   <span class="mi">4</span>   <span class="mi">3</span>   <span class="mi">2</span>   <span class="mi">1</span>   <span class="mi">0</span>  <span class="n">SEW</span><span class="o">=</span><span class="mi">16</span><span class="n">b</span><span class="p">,</span> <span class="n">LMUL</span><span class="o">=</span><span class="mi">1</span>

<span class="n">v2</span><span class="o">*</span><span class="n">n</span>            <span class="mi">3</span>       <span class="mi">2</span>       <span class="mi">1</span>       <span class="mi">0</span>  <span class="n">SEW</span><span class="o">=</span><span class="mi">32</span><span class="n">b</span><span class="p">,</span> <span class="n">LMUL</span><span class="o">=</span><span class="mi">2</span>
<span class="n">v2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span>          <span class="mi">7</span>       <span class="mi">6</span>       <span class="mi">5</span>       <span class="mi">4</span>

<span class="n">v4</span><span class="o">*</span><span class="n">n</span>                    <span class="mi">1</span>               <span class="mi">0</span>  <span class="n">SEW</span><span class="o">=</span><span class="mi">64</span><span class="n">b</span><span class="p">,</span> <span class="n">LMUL</span><span class="o">=</span><span class="mi">4</span>
<span class="n">v4</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span>                  <span class="mi">3</span>               <span class="mi">2</span>
<span class="n">v4</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span>                  <span class="mi">5</span>               <span class="mi">4</span>
<span class="n">v4</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">3</span>                  <span class="mi">7</span>               <span class="mi">6</span>
</pre></div>
</div>
<p>次の表は、幅が混在しているループで考えられる一定のSEW/LMULの動作点を示しています。
各列は一定のSEW/LMUL動作点を表しています。
表のエントリは、その行のデータ幅に対して、その列のSEW/LMUL値をもたらすLMUL値です。
各列のデータ幅のLMUL設定は、同じ列のLMUL設定を持つ他のデータ幅と、すべてが同じVLMAXになるように整列できることを示しています。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 4%" />
<col style="width: 4%" />
<col style="width: 4%" />
<col style="width: 4%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>SEW/LMUL</p></th>
<th class="head"><p>1</p></th>
<th class="head"><p>2</p></th>
<th class="head"><p>4</p></th>
<th class="head"><p>8</p></th>
<th class="head"><p>16</p></th>
<th class="head"><p>32</p></th>
<th class="head"><p>64</p></th>
<th class="head"><p>128</p></th>
<th class="head"><p>256</p></th>
<th class="head"><p>512</p></th>
<th class="head"><p>1024</p></th>
<th class="head"><p>2048</p></th>
<th class="head"><p>4096</p></th>
<th class="head"><p>8192</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>SEW= 8</p></td>
<td><p>8</p></td>
<td><p>4</p></td>
<td><p>2</p></td>
<td><p>1</p></td>
<td><p>1/2</p></td>
<td><p>1/4</p></td>
<td><p>1/8</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>SEW= 16</p></td>
<td></td>
<td><p>8</p></td>
<td><p>4</p></td>
<td><p>2</p></td>
<td><p>1</p></td>
<td><p>1/2</p></td>
<td><p>1/4</p></td>
<td><p>1/8</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>SEW= 32</p></td>
<td></td>
<td></td>
<td><p>8</p></td>
<td><p>4</p></td>
<td><p>2</p></td>
<td><p>1</p></td>
<td><p>1/2</p></td>
<td><p>1/4</p></td>
<td><p>1/8</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>SEW= 64</p></td>
<td></td>
<td></td>
<td></td>
<td><p>8</p></td>
<td><p>4</p></td>
<td><p>2</p></td>
<td><p>1</p></td>
<td><p>1/2</p></td>
<td><p>1/4</p></td>
<td><p>1/8</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>SEW= 128</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p>8</p></td>
<td><p>4</p></td>
<td><p>2</p></td>
<td><p>1</p></td>
<td><p>1/2</p></td>
<td><p>1/4</p></td>
<td><p>1/8</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>SEW= 256</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p>8</p></td>
<td><p>4</p></td>
<td><p>2</p></td>
<td><p>1</p></td>
<td><p>1/2</p></td>
<td><p>1/4</p></td>
<td><p>1/8</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p>SEW= 512</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p>8</p></td>
<td><p>4</p></td>
<td><p>2</p></td>
<td><p>1</p></td>
<td><p>1/2</p></td>
<td><p>1/4</p></td>
<td><p>1/8</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>SEW=1024</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p>8</p></td>
<td><p>4</p></td>
<td><p>2</p></td>
<td><p>1</p></td>
<td><p>1/2</p></td>
<td><p>1/4</p></td>
<td><p>1/8</p></td>
</tr>
</tbody>
</table>
<p>LMULの設定を大きくすると、単純にベクトルの長さを長くして命令のフェッチとディスパッチのオーバーヘッドを減らすことができ、
ベクトルレジスタグループの数が少なくて済む場合にも使用できます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>より多くのアーキテクチャレジスタを有効にしていないため、有用な動作ポイントを追加していません。</p>
</div>
</div>
<div class="section" id="lmul-1-elen-vlen">
<h2>LMUL &gt; 1 かつ ELEN &gt; VLEN のマッピング<a class="headerlink" href="#lmul-1-elen-vlen" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>より大きなSEWをサポートするためにベクトルレジスタがグループ化され、ELEN &gt; VLENとなった場合、
グループ内のベクトルレジスタは連結されて1つのバイト配列となり、
グループ内で最も番号の低いレジスタが、メモリレイアウトから最も低いアドレスのバイトを保持します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LMUL</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="n">ELEN</span><span class="o">&gt;</span><span class="n">VLEN</span><span class="p">,</span> <span class="n">examples</span>

<span class="n">VLEN</span><span class="o">=</span><span class="mi">32</span><span class="n">b</span><span class="p">,</span> <span class="n">SEW</span><span class="o">=</span><span class="mi">64</span><span class="n">b</span><span class="p">,</span> <span class="n">LMUL</span><span class="o">=</span><span class="mi">2</span>

<span class="n">Byte</span>         <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span>
<span class="n">v2</span><span class="o">*</span><span class="n">n</span>               <span class="mi">0</span>
<span class="n">v2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span>

<span class="n">VLEN</span><span class="o">=</span><span class="mi">32</span><span class="n">b</span><span class="p">,</span> <span class="n">SEW</span><span class="o">=</span><span class="mi">64</span><span class="n">b</span><span class="p">,</span> <span class="n">LMUL</span><span class="o">=</span><span class="mi">4</span>

<span class="n">Byte</span>         <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span>
<span class="n">v4</span><span class="o">*</span><span class="n">n</span>               <span class="mi">0</span>
<span class="n">v4</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span>
<span class="n">v4</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span>             <span class="mi">1</span>
<span class="n">v4</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">3</span>

<span class="n">VLEN</span><span class="o">=</span><span class="mi">32</span><span class="n">b</span><span class="p">,</span> <span class="n">SEW</span><span class="o">=</span><span class="mi">64</span><span class="n">b</span><span class="p">,</span> <span class="n">LMUL</span><span class="o">=</span><span class="mi">8</span>

<span class="n">Byte</span>         <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span>
<span class="n">v8</span><span class="o">*</span><span class="n">n</span>               <span class="mi">0</span>
<span class="n">v8</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span>
<span class="n">v8</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span>             <span class="mi">1</span>
<span class="n">v8</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">3</span>
<span class="n">v8</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">4</span>             <span class="mi">2</span>
<span class="n">v8</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">5</span>
<span class="n">v8</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">6</span>             <span class="mi">3</span>
<span class="n">v8</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">7</span>
</pre></div>
</div>
</div>
<div class="section" id="sec-mask-register-layout">
<span id="id17"></span><h2>マスクレジスタのレイアウト<a class="headerlink" href="#sec-mask-register-layout" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトルマスクは、SEWやLMULに関係なく、1つのベクトルレジスタのみを占有します。
各要素には、マスクベクトルレジスタに1つのマスクビットが割り当てられます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>0.9デザインでは、MLEN=1です。</p>
</div>
<div class="section" id="id18">
<h3>マスク要素の場所<a class="headerlink" href="#id18" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>要素 <em>i</em> のマスクビットは、SEWやLMULとは関係なく、マスクレジスタのビット <em>i</em> に配置されます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">VLEN</span><span class="o">=</span><span class="mi">32</span><span class="n">b</span>

         <span class="n">Byte</span>    <span class="mi">3</span>   <span class="mi">2</span>   <span class="mi">1</span>   <span class="mi">0</span>
<span class="n">LMUL</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">SEW</span><span class="o">=</span><span class="mi">8</span><span class="n">b</span>
                 <span class="mi">3</span>   <span class="mi">2</span>   <span class="mi">1</span>   <span class="mi">0</span>  <span class="n">Element</span>
               <span class="p">[</span><span class="mi">03</span><span class="p">][</span><span class="mi">02</span><span class="p">][</span><span class="mi">01</span><span class="p">][</span><span class="mi">00</span><span class="p">]</span> <span class="n">Mask</span> <span class="n">bit</span> <span class="n">position</span> <span class="ow">in</span> <span class="n">decimal</span>

<span class="n">LMUL</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">SEW</span><span class="o">=</span><span class="mi">16</span><span class="n">b</span>
                     <span class="mi">1</span>       <span class="mi">0</span>
                   <span class="p">[</span><span class="mi">01</span><span class="p">]</span>    <span class="p">[</span><span class="mi">00</span><span class="p">]</span>
                     <span class="mi">3</span>       <span class="mi">2</span>
                   <span class="p">[</span><span class="mi">03</span><span class="p">]</span>    <span class="p">[</span><span class="mi">02</span><span class="p">]</span>

<span class="n">LMUL</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span><span class="n">SEW</span><span class="o">=</span><span class="mi">32</span><span class="n">b</span>               <span class="mi">0</span>
                           <span class="p">[</span><span class="mi">00</span><span class="p">]</span>
                             <span class="mi">1</span>
                           <span class="p">[</span><span class="mi">01</span><span class="p">]</span>
                             <span class="mi">2</span>
                           <span class="p">[</span><span class="mi">02</span><span class="p">]</span>
                             <span class="mi">3</span>
                           <span class="p">[</span><span class="mi">03</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LMUL</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">SEW</span><span class="o">=</span><span class="mi">8</span><span class="n">b</span>
                 <span class="mi">3</span>   <span class="mi">2</span>   <span class="mi">1</span>   <span class="mi">0</span>
               <span class="p">[</span><span class="mi">03</span><span class="p">][</span><span class="mi">02</span><span class="p">][</span><span class="mi">01</span><span class="p">][</span><span class="mi">00</span><span class="p">]</span>
                 <span class="mi">7</span>   <span class="mi">6</span>   <span class="mi">5</span>   <span class="mi">4</span>
               <span class="p">[</span><span class="mi">07</span><span class="p">][</span><span class="mi">06</span><span class="p">][</span><span class="mi">05</span><span class="p">][</span><span class="mi">04</span><span class="p">]</span>

<span class="n">LMUL</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span><span class="n">SEW</span><span class="o">=</span><span class="mi">32</span><span class="n">b</span>
                             <span class="mi">0</span>
                           <span class="p">[</span><span class="mi">00</span><span class="p">]</span>
                             <span class="mi">1</span>
                           <span class="p">[</span><span class="mi">01</span><span class="p">]</span>
                             <span class="mi">2</span>
                           <span class="p">[</span><span class="mi">02</span><span class="p">]</span>
                             <span class="mi">3</span>
                           <span class="p">[</span><span class="mi">03</span><span class="p">]</span>
                             <span class="mi">4</span>
                           <span class="p">[</span><span class="mi">04</span><span class="p">]</span>
                             <span class="mi">5</span>
                           <span class="p">[</span><span class="mi">05</span><span class="p">]</span>
                             <span class="mi">6</span>
                           <span class="p">[</span><span class="mi">06</span><span class="p">]</span>
                             <span class="mi">7</span>
                           <span class="p">[</span><span class="mi">07</span><span class="p">]</span>

<span class="n">LMUL</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span><span class="n">SEW</span><span class="o">=</span><span class="mi">8</span><span class="n">b</span>
                 <span class="mi">3</span>   <span class="mi">2</span>   <span class="mi">1</span>   <span class="mi">0</span>
               <span class="p">[</span><span class="mi">03</span><span class="p">][</span><span class="mi">02</span><span class="p">][</span><span class="mi">01</span><span class="p">][</span><span class="mi">00</span><span class="p">]</span>
                 <span class="mi">7</span>   <span class="mi">6</span>   <span class="mi">5</span>   <span class="mi">4</span>
               <span class="p">[</span><span class="mi">07</span><span class="p">][</span><span class="mi">06</span><span class="p">][</span><span class="mi">05</span><span class="p">][</span><span class="mi">04</span><span class="p">]</span>
                 <span class="n">B</span>   <span class="n">A</span>   <span class="mi">9</span>   <span class="mi">8</span>
               <span class="p">[</span><span class="mi">11</span><span class="p">][</span><span class="mi">10</span><span class="p">][</span><span class="mi">09</span><span class="p">][</span><span class="mi">08</span><span class="p">]</span>
                 <span class="n">F</span>   <span class="n">E</span>   <span class="n">D</span>   <span class="n">C</span>
               <span class="p">[</span><span class="mi">15</span><span class="p">][</span><span class="mi">14</span><span class="p">][</span><span class="mi">13</span><span class="p">][</span><span class="mi">12</span><span class="p">]</span>
                <span class="mi">13</span>  <span class="mi">12</span>  <span class="mi">11</span>  <span class="mi">10</span>
               <span class="p">[</span><span class="mi">19</span><span class="p">][</span><span class="mi">18</span><span class="p">][</span><span class="mi">17</span><span class="p">][</span><span class="mi">16</span><span class="p">]</span>
                <span class="mi">17</span>  <span class="mi">16</span>  <span class="mi">15</span>  <span class="mi">14</span>
               <span class="p">[</span><span class="mi">23</span><span class="p">][</span><span class="mi">22</span><span class="p">][</span><span class="mi">21</span><span class="p">][</span><span class="mi">20</span><span class="p">]</span>
                <span class="mi">1</span><span class="n">B</span>  <span class="mi">1</span><span class="n">A</span>  <span class="mi">19</span>  <span class="mi">18</span>
               <span class="p">[</span><span class="mi">27</span><span class="p">][</span><span class="mi">26</span><span class="p">][</span><span class="mi">25</span><span class="p">][</span><span class="mi">24</span><span class="p">]</span>
                <span class="mi">1</span><span class="n">F</span>  <span class="mi">1</span><span class="n">E</span>  <span class="mi">1</span><span class="n">D</span>  <span class="mi">1</span><span class="n">C</span>
               <span class="p">[</span><span class="mi">31</span><span class="p">][</span><span class="mi">30</span><span class="p">][</span><span class="mi">29</span><span class="p">][</span><span class="mi">28</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="id19">
<h1>ベクトル命令フォーマット<a class="headerlink" href="#id19" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>ベクトル拡張の命令は、既存の2つのメジャーオペコード(LOAD-FP、STORE-FP)と1つの新しいメジャーオペコード(OP-V)に当てはまります。</p>
<p>ベクトルのロードとストアは、スカラ浮動小数点のロードとストアのメジャーオペコード(LOAD-FP/STORE-FP)の中にエンコードされます。
ベクトルロード/ストアのエンコーディングは、標準的なスカラ浮動小数点ロード/ストアの12ビット即値フィールドの一部を再利用して、
さらにベクトル命令のエンコーディングを行い、ビット25には標準的なベクトルマスクビット ( <a class="reference internal" href="#sec-vector-mask-encoding"><span class="std std-ref">マスクエンコーディング</span></a>  を参照)を格納します。</p>
<p>include::vmem-format.adoc[]</p>
<p>include::valu-format.adoc[]</p>
<p>include::vcfg-format.adoc[]</p>
<p>ベクトル命令は、スカラまたはベクトルのソースオペランドを持ち、
スカラまたはベクトルの結果を生成することができ、
ほとんどのベクトル命令は、無条件またはマスクの下で条件付きで実行することができます。</p>
<p>ベクトルのロードとストアは、ベクトルのレジスタ要素とメモリの間でビットパタンを移動させます。
ベクトル演算命令は、ベクトルレジスタ要素に保持された値を演算します。</p>
<div class="section" id="id20">
<h2>スカラオペランド<a class="headerlink" href="#id20" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>スカラオペランドは即値、または <cite>x</cite> レジスタ、<cite>f</cite>  レジスタ、またはベクトルレジスタの要素 0 から取得することができます。
スカラの結果は <cite>x</cite> または <cite>f</cite> レジスタ、またはベクトルレジスタの要素 0 に書き込まれます。
現在の LMUL の設定に関わらず、どのベクトルレジスタもスカラを保持するために使用できます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p><cite>f</cite> レジスタをオーバーレイしないことで、ベクトルレジスタが圧迫させないようにし、
標準的な呼び出し規則との相互作用を避け、高性能なスカラ浮動小数点の設計を簡素化し、Zfinx ISA オプションとの互換性を実現します。
<cite>f</cite> と <cite>v</cite> を重ねると、実装によってはステート・ビット数を減らせるというメリットがありますが、
高性能な設計が複雑になり、Zfinx ISAオプションとの互換性もなくなります。</p>
</div>
</div>
<div class="section" id="id21">
<h2>ベクトルオペランド<a class="headerlink" href="#id21" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>各ベクトルオペランドは、ベクトルレジスタグループ内のすべての要素のサイズと位置を決定するために使用される <em>effective</em> <em>element</em> <em>width</em> (EEW) と <em>effective</em> <em>LMUL</em> (EMUL)を持っています。
デフォルトでは、ほとんどの命令のほとんどのオペランドで、EEW=SEW、EMUL=LMULとなります。</p>
<p>ベクトル命令の中には、ソースと書き込みベクトルオペランドの要素数が同じでも幅が異なるものがあり、
その場合、EEWとEMULはそれぞれSEWとLMULと異なりますが、EEW/EMUL = SEW/LMULとなります。
例えば、Widening演算命令の多くは、ソースグループがEEW=SEW、EMUL=LMULで、
書き込みグループがEEW=2*SEW、EMUL=2*LMULとなっています。
Narrowing命令は、ソースオペランドはEEW=2*SEW、EMUL=2*LMULですが、
書き込みレジスタはEEW=SEW、EMUL=LMULです。</p>
<p>ベクトルオペランドまたは演算結果は、EMULに応じて1つまたは複数のベクトルレジスタを占めることがありますが、
常にグループ内で最も低い番号のベクトルレジスタを使用して指定されます。
ベクトルレジスタグループの指定に最下位のベクトルレジスタ以外を使用するエンコーディングは予約されています。</p>
<p>書き込みベクトルレジスタグループは、次のいずれかが成立する場合に限り、
ソースベクトルレジスタグループとオーバーラップすることができます。</p>
<ul class="simple">
<li><p>書き込みレジスタのEEWとソースのEEWが等しい。</p></li>
<li><p>書き込みレジスタのEEWがソースのEEWよりも小さく、オーバーラップする部分がソースのレジスタグループの最も低い番号の部分である(例えば、LMUL=1の場合、 <cite>vnsrl.wi v0, v0, 3</cite> は合法だが、<cite>v1</cite> の書き込みは合法ではない)。</p></li>
<li><p>書き込みレジスタのEEWがソースのEEWよりも大きく、ソースのEMULが少なくとも1であり、オーバーラップが書き込みレジスタグループの最も高い番号の部分にある場合(例えば、LMUL=8の場合、 <cite>vzext.vf4 v0, v6</cite> は合法ですが、ソースの <cite>v0</cite> 、 <cite>v2</cite> 、<cite>v4</cite> は合法ではない)。</p></li>
</ul>
<p>レジスタグループのオーバーラップ制約のために、マスク要素はEEW=1となります。</p>
<p>ある命令で使用される最大のベクトルレジスタグループは、8個以上のベクトル・レジスタであってはならず(すなわち、EMUL{le}8)、
ベクトル命令が8個以上のベクトルレジスタグループを必要とする場合には、その命令エンコーディングは予約されます。
例えば、LMUL=8のときにWideringされたベクトルレジスタ群の結果を得るWidening演算は、EMUL=16の結果を意味するため、予約されます。</p>
<p>Wideningされたスカラ値(Wideningリダクション演算の結果など)は、
ベクトルレジスタの最初の要素に保持され、EMUL=1となる。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>暗黙のうちにEMULが1となるため、wide スカラリダクションの結果を保持するためにベクトルレジスタグループを使用することはできません。
この場合、スカラリダクション要素のEMULを指定する独立したパラメータが必要になります。</p>
</div>
</div>
<div class="section" id="id22">
<h2>ベクトルマスキング<a class="headerlink" href="#id22" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>マスキングは多くのベクトル命令でサポートされています。
マスクオフされた(非アクティブな)要素の操作は、例外を発生させません。
マスクオフされた要素に対応する書き込みベクトルレジスタの要素は、<cite>vtype</cite> の <cite>vma</cite> ビットの
設定に応じて、mask-undisturbedまたはmask-agnosticのいずれかのポリシで処理されます(セクション <a class="reference internal" href="#sec-agnostic"><span class="std std-ref">Tail Agnostic とVector Mask Agnostic vta と vma</span></a>  )。</p>
<p>マスクされたベクトル命令の実行を制御するために使用されるマスク値は、
常にベクトルレジスタ <cite>v0</cite> によって提供されます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>より長い命令エンコーディングを提供するかもしれません。</p>
</div>
<p>マスクド・ベクトル命令の書き込みベクトルレジスタグループは、書き込みベクトルレジスタにマスク値(比較など)やリダクションのスカラ結果が書き込まれていない限り、
ソースマスクレジスタ(<cite>v0</cite>)とオーバーラップすることはできません。
これらの命令エンコーディングは予約済みです。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>例えば、 <cite>vadd.vv v0, v1, v2, v0.m</cite> は、以前は LMUL=1 の場合には合法でしたが、現在は常に違法です。</p>
</div>
<p>作業用マスクの値を保持するために他のベクトルレジスタを使用することができ、
述語計算を行うためのマスクベクトル論理演算が提供されています。
.. _sec-mask-vector-logical:を参照してください。</p>
<p><a class="reference internal" href="#sec-agnostic"><span class="std std-ref">Tail Agnostic とVector Mask Agnostic vta と vma</span></a>   で規定されているように、マスクの書き込み値は <cite>vta</cite> の設定にかかわらず、
常に tail-agnostic として扱われます。</p>
<div class="section" id="sec-vector-mask-encoding">
<span id="id23"></span><h3>マスクエンコーディング<a class="headerlink" href="#sec-vector-mask-encoding" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>マスキングが可能な場合は、命令内の1ビットの <cite>vm</cite> フィールドにエンコードされます( <cite>inst[25]</cite> )。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 6%" />
<col style="width: 94%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>vm</p></th>
<th class="head"><p>説明</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>ベクトル演算の結果は v0.mask[i]=1の領域にのみ書き込まれる</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>マスクされない</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p><cite>v0</cite> を使った真と補填マスキングと、スカラ演算の符号化を行っていました。</p>
</div>
<p>ベクトルのマスキングはアセンブラのコードでは別のベクトルオペランドとして表現され、<cite>.t</cite> は <cite>v0.mask[i]</cite> が <cite>1</cite> のときに演算が行われるかどうかを示します。
マスキングオペランドが指定されていない場合は、ベクトル実行はマスクされていない(<cite>vm=1</cite>)とされます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vop</span><span class="o">.</span><span class="n">v</span><span class="o">*</span>    <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">,</span> <span class="n">v0</span><span class="o">.</span><span class="n">t</span>  <span class="c1"># マスク有効、v0.mask[i]=1の部分がマスクされる</span>
<span class="n">vop</span><span class="o">.</span><span class="n">v</span><span class="o">*</span>    <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span>        <span class="c1"># マスク無効</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>アセンブリ構文では、マスクレジスタ指定子を追加し、真のマスキングと負のマスキングの両方をサポートする可能性のある将来の拡張と互換性を持たせるために、完全な文法を書き出します。
マスキングオペランドの接尾辞 <cite>.t</cite> は、マスクの使用を視覚的に符号化するのにも役立ちます。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p><cite>v0.mask[i]</cite> のように文章中にマスクベクトルに添え字として使用されるだけです。</p>
</div>
</div>
</div>
<div class="section" id="sec-inactive-defs">
<span id="id24"></span><h2>プリスタート、アクティブ、非アクティブ、ボディ、末尾要素の定義<a class="headerlink" href="#sec-inactive-defs" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトル命令の実行時に操作される出力要素のインデックスは、3つのサブセットに分けられます。</p>
<ul class="simple">
<li><p><em>プリスタート</em> 要素は、要素のインデックスが <cite>vstart</cite> レジスタの初期値よりも小さいものです。</p></li>
</ul>
<p>プリスタート要素は、例外を発生させず、書き込みベクトルレジスタも更新しません。</p>
<ul class="simple">
<li><p><em>ボディ</em> 要素は、要素のインデックスが <cite>vstart</cite> レジスタの初期値以上で、</p></li>
</ul>
<p><cite>vl</cite> の現在のベクトル長設定よりも小さいものです。ボディは2つの分離したサブセットに分割することができます。</p>
<p>** ベクトル命令の実行中の <em>アクティブ</em> 要素は、ボディ内の要素で、
その要素位置で現在のマスクが有効になっているところです。
アクティブな要素は、例外を発生させたり、書き込みベクトルレジスタグループを更新することができます。</p>
<p>** <em>非アクティブ</em> 要素は、ボディ内の要素で、その要素の位置で現在のマスクが無効になっている要素です。
非アクティブな要素は、 masked agnostic が指定されていない限り (<a href="#id25"><span class="problematic" id="id26">`</span></a>vtype.vma`=1)、
例外を発生させず、書き込みベクトルレジスタグループを更新しません。
この場合、非アクティブな要素は 1 で上書きされる可能性があります。</p>
<ul class="simple">
<li><p>ベクトル命令実行中の <em>末尾</em> 要素は、<cite>vl</cite> で指定された現在のベクトル長設定を超えた要素です。</p></li>
</ul>
<p>末尾要素は例外を発生させず、Tail Agunostics指定されていない限り (<a href="#id27"><span class="problematic" id="id28">`</span></a>vtype.vta`=1)、
書き込みベクトルレジスタグループを更新しません。
この場合、末尾要素は 1 で上書きされるか、マスクロードを除くマスク生成命令の場合は命令の結果で上書きされる可能性があります。
LMUL &lt; 1の場合、末尾には同じベクトルレジスタに保持されているVLMAX以降の要素が含まれます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>for element index x
prestart(x) = (0 &lt;= x &lt; vstart)
body(x)     = (vstart &lt;= x &lt; vl)
tail(x)     = (vl &lt;= x &lt; max(VLMAX,VLEN/SEW))
mask(x)     = unmasked || v0.mask[x] == 1
active(x)   = body(x) &amp;&amp; mask(x)
inactive(x) = body(x) &amp;&amp; !mask(x)
</pre></div>
</div>
<p><cite>vstart</cite> {ge} <cite>vl</cite> のとき、ボディの要素はなく、どの書き込みベクトルレジスタグループの要素も更新されず、
これは末尾要素がagnosticな値で更新されないことも含みます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>書き込みベクトルレジスタグループはAgnosticな要素を含めて、いかなる要素も更新されません。</p>
</div>
<p><cite>x</cite> レジスタや <cite>f</cite> レジスタを書き込む命令は、
<cite>vl</cite> =0のときも含めて、<cite>vstart</cite> {ge} <cite>vl</cite> のときにも実行されます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p><cite>vl</cite> または VLMAX を超えるインデックスを読み取ることがあります。
一般的なポリシは、インデックスがソースベクトルレジスタグループのVLMAXよりも大きい場合、値0を返します。</p>
</div>
</div>
</div>
<div class="section" id="vsetvli-vsetivl-vsetvl">
<span id="sec-vector-config"></span><h1>コンフィグレーション設定命令 (<cite>vsetvli</cite>/<cite>vsetivl</cite>/<cite>vsetvl</cite>)<a class="headerlink" href="#vsetvli-vsetivl-vsetvl" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>多数の要素を処理するための一般的なアプローチの一つに、ループの各イタレーションでいくつかの要素を処理し、
すべての要素が処理されるまでイタレーションを続ける&quot;ストリップマイニング&quot;があります。
RISC-Vのベクトル仕様では、この手法を直接かつポータブルにサポートしています。
アプリケーションは、処理する要素の総数(アプリケーションベクトル長、AVL)を <cite>vl</cite> の候補値として指定し、
ハードウェアは、マイクロアーキテクチャの実装と <cite>vtype</cite> の設定に基づいて、
ハードウェアが反復ごとに処理する要素数( <cite>vl</cite> に格納されている) を、汎用レジスタを介して応答します。
<span class="xref std std-ref">example-stripmin-sew</span>  に示されている簡単なループ構造は、コードが残りの要素数とハードウェアが処理する1回あたりの量を簡単に追跡していることを示しています。</p>
<p>アプリケーションのニーズに合わせて <cite>vl</cite> と <cite>vtype</cite> の値を迅速に設定できるように、一連の命令が提供されています。
<cite>vset{i}vl{i}</cite> 命令は、その引数に基づいて、<cite>vtype</cite> と <cite>vl</cite> の CSR を設定し、<cite>rd</cite> に <cite>vl</cite> の新しい値を書き込みます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vsetvli</span> <span class="n">rd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vtypei</span>   <span class="c1"># rd = new vl, rs1 = AVL, vtypei = new vtype setting</span>
<span class="n">vsetivli</span> <span class="n">rd</span><span class="p">,</span> <span class="n">uimm</span><span class="p">,</span> <span class="n">vtypei</span> <span class="c1"># rd = new vl, uimm = AVL, vtypei = new vtype setting</span>
<span class="n">vsetvl</span>  <span class="n">rd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">rs2</span>      <span class="c1"># rd = new vl, rs1 = AVL, rs2 = new vtype value</span>
</pre></div>
</div>
<p>include::vcfg-format.adoc[]</p>
<div class="section" id="id29">
<h2><cite>vtype</cite> エンコーディング<a class="headerlink" href="#id29" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>include::vtype-format.adoc[]</p>
<p>新しい <cite>vtype</cite> の設定は、 <cite>vsetvli</cite> と <cite>vsetivli</cite> の即時フィールド、および <cite>vsetvl</cite> の <cite>rs2</cite> レジスタにエンコードされます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="n">vset</span><span class="p">{</span><span class="n">i</span><span class="p">}</span><span class="n">vli</span> <span class="n">の即値vtipeiで提案されるアセンブラ名</span>

 <span class="n">e8</span>    <span class="c1"># SEW=8b</span>
 <span class="n">e16</span>   <span class="c1"># SEW=16b</span>
 <span class="n">e32</span>   <span class="c1"># SEW=32b</span>
 <span class="n">e64</span>   <span class="c1"># SEW=64b</span>
 <span class="n">e128</span>  <span class="c1"># SEW=128b</span>
 <span class="n">e256</span>  <span class="c1"># SEW=256b</span>
 <span class="n">e512</span>  <span class="c1"># SEW=512b</span>
 <span class="n">e1024</span> <span class="c1"># SEW=1024b</span>

 <span class="n">mf8</span>  <span class="c1"># LMUL=1/8</span>
 <span class="n">mf4</span>  <span class="c1"># LMUL=1/4</span>
 <span class="n">mf2</span>  <span class="c1"># LMUL=1/2</span>
 <span class="n">m1</span>   <span class="c1"># LMUL=1, mの設定を省略した場合</span>
 <span class="n">m2</span>   <span class="c1"># LMUL=2</span>
 <span class="n">m4</span>   <span class="c1"># LMUL=4</span>
 <span class="n">m8</span>   <span class="c1"># LMUL=8</span>

<span class="n">例</span><span class="p">:</span>
    <span class="n">vsetvli</span> <span class="n">t0</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">e8</span>          <span class="c1"># SEW= 8, LMUL=1</span>
    <span class="n">vsetvli</span> <span class="n">t0</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">e8</span><span class="p">,</span> <span class="n">m2</span>      <span class="c1"># SEW= 8, LMUL=2</span>
    <span class="n">vsetvli</span> <span class="n">t0</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">e32</span><span class="p">,</span> <span class="n">mf2</span>    <span class="c1"># SEW=32, LMUL=1/2</span>
</pre></div>
</div>
<p><cite>vsetvl</cite> の動作は、<cite>rs2</cite> から <cite>vtype</cite> の値を受け取ることと、
コンテキストの復元に使えることを除いて、<cite>vsetvli</cite> と同様になります。</p>
<p><cite>vtype</cite> の設定が実装でサポートされていない場合には、<cite>vtype</cite> に <cite>vill</cite> ビットが設定され、
<cite>vtype</cite> の残りのビットは 0 に設定され、<cite>vl</cite> レジスタも 0 に設定されます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>しかし、これはISAへのCSRの書き込み時に最初のデータ依存の例外を追加することになりました。
実装では、 <cite>vill</cite> を設定する代わりに、 <cite>vtype</cite> に不正な値が書き込まれたときに例外することを選択して、
エミュレーションで新しい構成をサポートできるようにして、将来の互換性を確保することができます。
現在のスキームは、ある設定に対して <cite>vill</cite> がクリアされているかどうかをチェックすることで、
サポートされているベクトルユニットの設定をランタイムに軽く照会することをサポートしています。</p>
</div>
</div>
<div class="section" id="avl">
<h2>AVLのエンコーディング<a class="headerlink" href="#avl" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>新しいベクトル長の設定はAVLに基づいており、 <cite>vsetvli</cite> と <cite>vsetvl</cite> では、 <cite>rs1</cite> と <cite>rd</cite> のフィールドに以下のようにエンコードされます。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 23%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>rd</p></th>
<th class="head"><p>rs1</p></th>
<th class="head"><p>AVL値</p></th>
<th class="head"><p>vl を更新する</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>!x0</p></td>
<td><p>x[rs1] の値</p></td>
<td><p>通常のストリップマイニング</p></td>
</tr>
<tr class="row-odd"><td><p>!x0</p></td>
<td><p>x0</p></td>
<td><p>~0</p></td>
<td><p>vl を VLMAXに設定する</p></td>
</tr>
<tr class="row-even"><td><p>x0</p></td>
<td><p>x0</p></td>
<td><p>vl レジスタの値</p></td>
<td><p>vl をキープする(もちろん、 vtype は変更される)</p></td>
</tr>
</tbody>
</table>
<p><cite>rs1</cite> が <cite>x0</cite> でない場合、AVL は <cite>rs1</cite> で指定された <cite>x</cite> レジスタに保持される符号なし整数となり、
新しい <cite>vl</cite> 値も <cite>rd</cite> で指定された <cite>x</cite> レジスタに書き込まれます。</p>
<p><cite>rs1=x0</cite> であるが、 <cite>rd!=x0</cite> のときは、符号なし整数の最大値 (<cite>~0</cite>) が AVL として使用され、
結果として VLMAX が <cite>vl</cite> に書き込まれ、 <cite>rd</cite> で指定された <cite>x</cite> レジスタにも書き込まれます。</p>
<p><cite>rs1=x0</cite> かつ <cite>rd=x0</cite> の場合、この命令は <cite>vl</cite> の現在のベクトル長をAVLとして使用し、
結果の値は <cite>vl</cite> に書き込まれますが、書き込みレジスタには書き込まれません。
この形式はVLMAXの場合にのみ使用でき、したがって <cite>vl</cite> は新しいSEW/LMUL比によって実際には変更されません。
VLMAXの変更をもたらすような新しいSEW/LMUL比率の命令の使用は予約済みです。
この場合、実装では <cite>vill</cite> を設定することができます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>この設計は、現在の <cite>vtype</cite> 設定に対して <cite>vl</cite> が常に正当な値を保持するように選択されました。
現在の <cite>vl</cite> 値は <cite>vl</cite> CSR から読み取ることができます。
新しいSEW/LMUL比率によってVLMAXが縮小する場合、この命令によって <cite>vl</cite> 値が減少する可能性がありますが、
これが一般的に有用な動作であることは明らかではないため、このケースは留保されています。
また、実装は、マイクロアーキテクチャを最適化するために、この命令によって <cite>vl</cite> が変更されないと仮定することができます。</p>
</div>
<p><cite>vsetivli</cite> 命令では、AVLは <cite>rs1</cite> フィールドの
5ビットのゼロ拡張即時値(0～31)としてエンコードされます。</p>
<p><cite>vsetivli</cite> 命令は、ベクトルサイズが小さく、ベクトルレジスタ内に収まることがわかっているため、
ストリップマイニングのオーバーヘッドが不要な場合に、よりコンパクトなコードを提供します。</p>
</div>
<div class="section" id="id30">
<h2><cite>vl</cite> 設定の制約<a class="headerlink" href="#id30" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><cite>vset{i}vl{i}</cite> 命令は、まず引数の <cite>vtype</cite> にしたがってVLMAXを設定し、
次に以下の制約にしたがって <cite>vl</cite> を設定します。</p>
<ul class="simple">
<li><p><cite>AVL {le} VLMAX</cite> のときは <cite>vl = AVL</cite></p></li>
<li><p><cite>AVL W (2 * VLMAX)</cite> のときは <cite>ceil(AVL / ) {le} vl {le} VLMAX</cite></p></li>
<li><p><cite>AVL {ge} (2 * VLMAX)</cite> のときは <cite>vl = VLMAX</cite></p></li>
<li><p>同一の入力AVLおよびVLMAX値に対して、任意の実装で決定される</p></li>
<li><p>これらの具体的な特性は、事前のルールから導かれます。</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p><cite>AVL = 0</cite> なら <cite>vl = 0</cite></p></li>
<li><p><cite>AVL &gt; 0</cite> なら <cite>vl &gt; 0</cite></p></li>
<li><p><cite>vl {le} VLMAX</cite></p></li>
<li><p><cite>vl {le} AVL</cite></p></li>
<li><p><cite>vl</cite> から読み込んだ値を <cite>vset{i}vl{i}</cite> の AVL 引数として使用すると、<cite>vl</cite> 内の同じ値になります。 ただし、結果として得られる VLMAX が <cite>vl</cite> が読み込まれた時点での VLMAX の値と同じであることが条件です。</p></li>
</ul>
</div></blockquote>
<p>[NOTE]
--
<cite>vl</cite> の設定ルールは、<cite>AVL {le} VLMAX</cite> では、レジスタの流出やコンテキストの入れ替えがあっても <cite>vl</cite> の動作を維持できるよう、
十分に厳密に設計されています。しかし、 <cite>AVL &gt; VLMAX</cite> の場合は、ベクトルレーンの使用率を向上させることができる柔軟性を備えています。
例えば、 <cite>VLMAX &lt; AVL &lt; 2*VLMAX</cite> の場合、<cite>vl = ceil(AVL / 2)</cite> と設定することで、ストリップマイニングループの最後の2回の反復に作業を均等に分散させることができます。
要件2は、 <cite>AVL &lt; 2*VLMAX</cite> の場合であっても、リダクションループの最初のストリップミン反復では、
すべての反復の中で最大のベクトル長を使用することを保証する。
これにより、ソフトウェアは、ストリップマイニングループで観測されたベクトル長の実行最大値を明示的に計算する必要がなくなります。
また、要件2では、 <cite>VLMAX &lt; AVL &lt; 2*VLMAX</cite> の場合、vlをVLMAXに設定することができます。</p>
<p>--</p>
</div>
<div class="section" id="sew">
<span id="example-stripmine-sew"></span><h2>ストリップマイニングとSEW変更の例<a class="headerlink" href="#sew" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>SEWとLMULの設定を動的に変更することで、1つのループで幅が混在するオペレーションでも高い処理能力を発揮します。
..</p>
<blockquote>
<div><p># Example: Load 16-bit values, widen multiply to 32b, shift 32b result
# right by 3, store 32b values.
# On entry:
#  a0 holds the total number of elements to process
#  a1 holds the address of the source array
#  a2 holds the address of the destination array</p>
<dl>
<dt>loop:</dt><dd><dl class="simple">
<dt>vsetvli a3, a0, e16, m4, ta, ma  # vtype = 16-bit integer vectors;</dt><dd><p># also update a3 with vl (# of elements this iteration)</p>
</dd>
</dl>
<p>vle16.v v4, (a1)        # Get 16b vector
slli t1, a3, 1          # Multiply # elements this iteration by 2 bytes/source element
add a1, a1, t1          # Bump pointer
vwmul.vx v8, v4, x10    # Widening multiply into 32b in &lt;v8--v15&gt;</p>
<p>vsetvli x0, x0, e32, m8, ta, ma  # Operate on 32b values
vsrl.vi v8, v8, 3
vse32.v v8, (a2)        # Store vector of 32b elements
slli t1, a3, 2          # Multiply # elements this iteration by 4 bytes/destination element
add a2, a2, t1          # Bump pointer
sub a0, a0, a3          # Decrement count by vl
bnez a0, loop           # Any more?</p>
</dd>
</dl>
</div></blockquote>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 例: 16ビットの値をロードし、32ビットに拡張し乗算を行い、</span>
<span class="c1"># 結果の32ビットを3ビット右にシフトし、結果の32ビットをストアする</span>
<span class="c1"># プログラムの先頭では:</span>
<span class="c1">#  a0は処理を行う全体の要素数を保持している</span>
<span class="c1">#  a1はソース配列のアドレスを保持している</span>
<span class="c1">#  a2は書き込み配列のアドレスを保持している</span>
<span class="n">loop</span><span class="p">:</span>
    <span class="n">vsetvli</span> <span class="n">a3</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">e16</span><span class="p">,</span> <span class="n">m4</span><span class="p">,</span> <span class="n">ta</span><span class="p">,</span> <span class="n">ma</span>  <span class="c1"># vtype = 16-bit 整数ベクトル</span>
                                     <span class="c1"># a3をvlに更新する(個のイタレーションにおける要素の個数)</span>
    <span class="n">vle16</span><span class="o">.</span><span class="n">v</span> <span class="n">v4</span><span class="p">,</span> <span class="p">(</span><span class="n">a1</span><span class="p">)</span>        <span class="c1"># 16ビットのベクトルを取得する</span>
    <span class="n">slli</span> <span class="n">t1</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="mi">1</span>          <span class="c1"># このイタレーションで処理する要素の個数から要素の2バイト数を計算する</span>
    <span class="n">add</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">t1</span>          <span class="c1"># ポインタを進める</span>
    <span class="n">vwmul</span><span class="o">.</span><span class="n">vx</span> <span class="n">v8</span><span class="p">,</span> <span class="n">v4</span><span class="p">,</span> <span class="n">x10</span>    <span class="c1"># v4の値を32ビットに拡張して&lt;v8--v15&gt;に格納する</span>

    <span class="n">vsetvli</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">e32</span><span class="p">,</span> <span class="n">m8</span><span class="p">,</span> <span class="n">ta</span><span class="p">,</span> <span class="n">ma</span>  <span class="c1"># 32ビット操作に変更する</span>
    <span class="n">vsrl</span><span class="o">.</span><span class="n">vi</span> <span class="n">v8</span><span class="p">,</span> <span class="n">v8</span><span class="p">,</span> <span class="mi">3</span>
    <span class="n">vse32</span><span class="o">.</span><span class="n">v</span> <span class="n">v8</span><span class="p">,</span> <span class="p">(</span><span class="n">a2</span><span class="p">)</span>        <span class="c1"># 32ビットの値をベクトルにストアする</span>
    <span class="n">slli</span> <span class="n">t1</span><span class="p">,</span> <span class="n">a3</span><span class="p">,</span> <span class="mi">2</span>          <span class="c1"># このイタレーションで処理する要素の個数から要素の4バイト数を計算する</span>
    <span class="n">add</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">t1</span>          <span class="c1"># ポインタを進める</span>
    <span class="n">sub</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a3</span>          <span class="c1"># vlだけカウンタを減少させる</span>
    <span class="n">bnez</span> <span class="n">a0</span><span class="p">,</span> <span class="n">loop</span>           <span class="c1"># これ以上処理する？</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="sec-vector-memory">
<span id="id31"></span><h1>ベクトルロード・ストア命令<a class="headerlink" href="#sec-vector-memory" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>ベクトルのロードとストアは、ベクトルレジスタとメモリの間で値を移動させます。
ベクトルロードとストアはマスクされ、非アクティブな要素で例外を発生させません。
マスク付きベクトルロード命令は、マスク付きAgnostics (<cite>vtype.vma`=1) が指定されていない限り、
書き込みベクトルレジスタグループの非アクティブな要素を更新しません。
マスク付きベクトルストアは、アクティブなメモリ要素のみを更新します。
すべてのベクトルロードとストアは、ゼロではない `vstart</cite> 値を生成して受け入れることができます。</p>
<div class="section" id="id32">
<h2>ベクトルロードストア命令のエンコーディング<a class="headerlink" href="#id32" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>include::vmem-format.adoc[]</p>
<p>ベクトルメモリユニットストライドおよびコンスタントストライド操作では、転送するデータのEEWを命令内で直接静的にエンコードすることで、
幅が混在するルーチンでメモリをアクセスする際の <cite>vtype</cite> の変更回数を減らすことができます。
インデックス付き演算では、命令内の明示的なEEWエンコーディングにより、
使用するインデックスのサイズを設定し、SEW/LMULによりデータ幅を指定します。</p>
</div>
<div class="section" id="id33">
<h2>ベクトルロードストアアドレッシングモード<a class="headerlink" href="#id33" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトル拡張は、ユニットストライド、ストライド、インデックス(スキャッター/ギャザー)のアドレッシングモードをサポートしています。
ベクトルのロード/ストアベースレジスタとストライドは、GPRの <cite>x</cite> レジスタから取得されます。</p>
<p>すべてのベクトルアクセスのベースとなる実効アドレスは、
<cite>rs1</cite> で指定された <cite>x</cite> レジスタの内容で与えられます。</p>
<p>ベクトルのユニットストライド演算は、ベース有効アドレスからメモリ内に連続して格納されている要素をアクセスします。</p>
<p>ベクトルの定数ストライド演算では、ベース実効アドレスで最初のメモリ要素をアクセスし、
その後、 <cite>rs2</cite> で指定される <cite>x</cite> レジスタに含まれるバイトオフセットで与えられるアドレス増分で後続の要素をアクセスします。</p>
<p>ベクトルインデックス演算では、 <cite>vs2</cite> で指定されたベクトルオフセットオペランドの各要素の内容をベース実効アドレスに加算し、
各要素の実効アドレスを得ることができます。
データベクトルレジスタ群は、EEW=SEW、EMUL=LMUL、オフセットベクトルレジスタ群は、
命令内でEEW符号化、EMUL=(EEW/SEW)*LMULとなります。</p>
<p>ベクトル・オフセット・オペランドは、バイトアドレス・オフセットのベクトルとして扱われます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>この場合、<cite>vs2</cite> ベクトルはオブジェクトのベースへのポインタを保持し、スカラ <cite>x</cite> レジスタは各オブジェクト内のメンバ・フィールドのオフセットを保持します。
このケースをサポートすることが、要素のインデックスをデータEEWでスケーリングするインデックス付き演算が定義されなかった理由です。</p>
</div>
<p>ベクトルオフセットの要素がXLENより狭い場合は、ベースの実効アドレスに追加する前にXLENまでゼロ拡張されます。
ベクトルオフセット要素の幅がXLENよりも広い場合は、アドレスの計算に最下位のXLENビットが使用されます。
EEWがオフセット要素に対してサポートされていない場合、実装は不正な命令例外を発生させることができます。</p>
<p>ベクトルアドレッシングモードは、2ビットの <cite>mop[1:0]</cite> フィールドを使ってエンコードされます。</p>
<p>ベクトルのユニットストライドおよびコンスタントストライドのメモリアクセスでは、個々の要素のアクセス間の順序付けは保証されません。
ベクトルのインデックス付きロードおよびストアのメモリ操作には、順序付きと非順序付きの2つの形式があります。
indexed-ordered の場合は、メモリアクセス時の要素の順序を保持します。</p>
<p>順序なしの命令(<cite>mop</cite>!=11)では、要素アクセスの順序は保証されません。
強く順序付けられたIO領域へのアクセスの場合、要素のアクセスはどのような順序でも開始できます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>順序付けられたインデックス付き命令を使用する必要があります。</p>
</div>
<p>精密なベクトル例外を備えた実装では、
インデックス付きの非順序型ストアの例外も精密でなければなりません。</p>
<p>追加のユニットストライドベクトルアドレッシングモードは、
ユニットストライドロード命令およびストア命令のエンコーディングにおいて、
それぞれ5ビットの <cite>lumop</cite> および <cite>sumop</cite> フィールドにエンコードされます。</p>
<p><cite>nf[2:0]</cite> フィールドは、各セグメントのフィールドの数をエンコードします。
通常のベクトルロード/ストアでは、 <cite>nf`=0で、各要素の位置でベクトルレジスタグループとメモリーの間で1つの値が移動することを示します。
より大きな値の `nf</cite> フィールドは、後述の <a class="reference internal" href="#sec-aos"><span class="std std-ref">ベクトルロードストアセグメント命令</span></a>  項で説明するように、
セグメント内の複数の連続したフィールドにアクセスするために使用されます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>アドレスオフセットフィールドのための同じビットの使用に取って代わりました。
セグメントロード/ストアは、メモリとの間でアイテムを移動するためのより強力なプリミティブを追加する一方で、
オフセットは単一のスカラ整数の計算で置き換えることができます。</p>
</div>
<p>また、 <cite>nf[2:0]</cite> フィールドは、全体ベクトルレジスタの
ロード/ストア命令で転送する全体ベクトルレジスタの数をエンコードします。</p>
</div>
<div class="section" id="sec-vector-loadstore-width-encoding">
<span id="id34"></span><h2>ベクトルロードストア幅のエンコーディング<a class="headerlink" href="#sec-vector-loadstore-width-encoding" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトルのロードとストアは、命令に直接EEWがエンコードされています。
対応するEMULはEMUL = (EEW/SEW)*LMULとして計算されます。
EMULが範囲外(EMUL&gt;8またはEMUL&lt;1/8)になる場合は、命令のエンコーディングは予約されます。
ベクトルレジスタグループには、選択されたEMULに対応する正当なレジスタ指定子がなければならず、
それ以外の命令エンコーディングは予約済みとみなされます。</p>
<p>ベクトルユニットストライドおよび定数ストライドでは、データ値に命令でエンコードされたEEW/EMULを使用し、
ベクトルインデックスロードおよびストアでは、インデックス値に命令でエンコードされたEEW/EMULを使用し、
データ値に <cite>vtype</cite> でエンコードされたSEW/LMULを使用します。</p>
<p>ベクトルのロード・ストアは、標準的なスカラ浮動小数点の
ロード・ストアが明示していない幅の値を使ってエンコードされます。</p>
<p><cite>mew</cite> ビット(<cite>inst[28]</cite>)は、128ビット以上の拡張メモリサイズをエンコードするために使用されることが期待されますが、
これらのエンコードは現時点では <em>予約</em> です。</p>
<p>サポートされているすべてのSEW設定のEEWのベクトルロード/ストアは、実装で提供されなければなりません。
サポートされていないEEW幅のベクトルロード・ストアエンコーディングは予約済みです。</p>
<p>Mem bits は、メモリにアクセスされる各要素のサイズです。</p>
<p>Data reg bits は、レジスタにアクセスされる各データ要素のサイズです。</p>
<p>Index bits は、レジスタにアクセスされる各インデックスのサイズです。</p>
<p>64b以上のデータおよびインデックスビットのEEWエンコーディングは現在予約済みです。</p>
</div>
<div class="section" id="id35">
<h2>ベクトルユニットストライド命令<a class="headerlink" href="#id35" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># ベクトルユニットストライドロードストア命令</span>

<span class="c1"># vd は書き込みレジスタ, rs1 はベースアドレス, vm はマスクエンコーディング (v0.t or &lt;missing&gt;)</span>
<span class="n">vle8</span><span class="o">.</span><span class="n">v</span>    <span class="n">vd</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vm</span>  <span class="c1">#    8-bit ユニットストライドロード</span>
<span class="n">vle16</span><span class="o">.</span><span class="n">v</span>   <span class="n">vd</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vm</span>  <span class="c1">#   16-bit ユニットストライドロード</span>
<span class="n">vle32</span><span class="o">.</span><span class="n">v</span>   <span class="n">vd</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vm</span>  <span class="c1">#   32-bit ユニットストライドロード</span>
<span class="n">vle64</span><span class="o">.</span><span class="n">v</span>   <span class="n">vd</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vm</span>  <span class="c1">#   64-bit ユニットストライドロード</span>
<span class="c1"># vle128.v  vd, (rs1), vm  #  128-bit ユニットストライドロード、予約済み</span>
<span class="c1"># vle256.v  vd, (rs1), vm  #  256-bit ユニットストライドロード、予約済み</span>
<span class="c1"># vle512.v  vd, (rs1), vm  #  512-bit ユニットストライドロード、予約済み</span>
<span class="c1"># vle1024.v vd, (rs1), vm  # 1024-bit ユニットストライドロード、予約済み</span>

<span class="c1"># vs3はストアデータ, rs1はベースアドレス, vmはマスクエンコーディング (v0.t or &lt;missing&gt;)</span>
<span class="n">vse8</span><span class="o">.</span><span class="n">v</span>    <span class="n">vs3</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vm</span>  <span class="c1">#    8-bit ユニットストライドストア</span>
<span class="n">vse16</span><span class="o">.</span><span class="n">v</span>   <span class="n">vs3</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vm</span>  <span class="c1">#   16-bit ユニットストライドストア</span>
<span class="n">vse32</span><span class="o">.</span><span class="n">v</span>   <span class="n">vs3</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vm</span>  <span class="c1">#   32-bit ユニットストライドストア</span>
<span class="n">vse64</span><span class="o">.</span><span class="n">v</span>   <span class="n">vs3</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vm</span>  <span class="c1">#   64-bit ユニットストライドストア</span>
<span class="c1"># vse128.v  vs3, (rs1), vm  #  128-bit ユニットストライドストア、予約済み</span>
<span class="c1"># vse256.v  vs3, (rs1), vm  #  256-bit ユニットストライドストア、予約済み</span>
<span class="c1"># vse512.v  vs3, (rs1), vm  #  512-bit ユニットストライドストア、予約済み</span>
<span class="c1"># vse1024.v vs3, (rs1), vm  # 1024-bit ユニットストライドストア、予約済み</span>
</pre></div>
</div>
<p>マスク値をメモリとの間で転送するために、ユニットストライドのロード/ストアが追加されました。
これは、実効ベクトル長が <code class="docutils literal notranslate"><span class="pre">evl``=ceil(``vl</span></code>/8) (つまりEMUL=1)であることと、
転送先のレジスタが常にテールアグノスティックポリシで書き込まれることを除けば、
マスクなしのバイトロード/ストア(EEW=8)と同じ動作をします。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># ベクトルユニットストライドマスクロード命令</span>
<span class="n">vlm</span><span class="o">.</span><span class="n">v</span> <span class="n">vd</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">)</span>   <span class="c1">#  ceil(vl/8)バイト長だけバイトデータをロードする</span>

<span class="c1"># ベクトルユニットストライドマスクストア命令</span>
<span class="n">vsm</span><span class="o">.</span><span class="n">v</span> <span class="n">vs3</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">)</span>  <span class="c1">#  ceil(vl/8)バイト長だけバイトデータをストアする</span>
</pre></div>
</div>
<p><cite>vlm.v</cite> と <cite>vsm.v</cite> は、<cite>vle8.v</cite> と <cite>vse8.v</cite> と同様に <cite>width[2:0]`=0 でエンコードされますが、
`lumop</cite> と <cite>sumop</cite> のエンコードが異なることで区別されます。
<cite>vlm.v</cite> と <cite>vsm.v</cite> はバイトロードとストアとして動作するので、
これらの命令では <cite>vstart</cite> はバイト単位になります。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>これらの命令と他の要素のロード/ストア命令で長さの扱いが異なるため、混乱を招きました。
ソフトウェアの混乱を避けるために、これらの古いアセンブラニーモニックはエイリアスとして残されています。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>データパス間の配線を減らすためにデータを内部で再配置するマシンをサポートすることです。
また、 <cite>vl</cite> を変更する必要がないため、マスクのスピル/フィルのコストを削減することができます。</p>
</div>
</div>
<div class="section" id="id36">
<h2>ベクトルストライド命令<a class="headerlink" href="#id36" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># ベクトルストライドロードストア命令</span>

<span class="c1"># vdは書き込みレジスタ, rs1はベースレジスタ, rs2はバイトストライド</span>
<span class="n">vlse8</span><span class="o">.</span><span class="n">v</span>    <span class="n">vd</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">rs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1">#    8-bit ストライドロード命令</span>
<span class="n">vlse16</span><span class="o">.</span><span class="n">v</span>   <span class="n">vd</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">rs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1">#   16-bit ストライドロード命令</span>
<span class="n">vlse32</span><span class="o">.</span><span class="n">v</span>   <span class="n">vd</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">rs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1">#   32-bit ストライドロード命令</span>
<span class="n">vlse64</span><span class="o">.</span><span class="n">v</span>   <span class="n">vd</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">rs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1">#   64-bit ストライドロード命令</span>
<span class="c1"># vlse128.v  vd, (rs1), rs2, vm  #  128-bit ストライドロード命令、予約済み</span>
<span class="c1"># vlse256.v  vd, (rs1), rs2, vm  #  256-bit ストライドロード命令、予約済み</span>
<span class="c1"># vlse512.v  vd, (rs1), rs2, vm  #  512-bit ストライドロード命令、予約済み</span>
<span class="c1"># vlse1024.v vd, (rs1), rs2, vm  # 1024-bit ストライドロード命令、予約済み</span>

<span class="c1"># vs3 store data, rs1 base address, rs2 byte stride</span>
<span class="n">vsse8</span><span class="o">.</span><span class="n">v</span>    <span class="n">vs3</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">rs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1">#    8-bit ストライドストア命令</span>
<span class="n">vsse16</span><span class="o">.</span><span class="n">v</span>   <span class="n">vs3</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">rs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1">#   16-bit ストライドストア命令</span>
<span class="n">vsse32</span><span class="o">.</span><span class="n">v</span>   <span class="n">vs3</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">rs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1">#   32-bit ストライドストア命令</span>
<span class="n">vsse64</span><span class="o">.</span><span class="n">v</span>   <span class="n">vs3</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">rs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1">#   64-bit ストライドストア命令</span>
<span class="c1"># vsse128.v  vs3, (rs1), rs2, vm  #  128-bit ストライドストア命令、予約済み</span>
<span class="c1"># vsse256.v  vs3, (rs1), rs2, vm  #  256-bit ストライドストア命令、予約済み</span>
<span class="c1"># vsse512.v  vs3, (rs1), rs2, vm  #  512-bit ストライドストア命令、予約済み</span>
<span class="c1"># vsse1024.v vs3, (rs1), rs2, vm  # 1024-bit ストライドストア命令、予約済み</span>
</pre></div>
</div>
<p>負の数のストライドとゼロストライドに対応しています。</p>
<p>ストライド命令内の要素アクセスは、互いに順序付けられていません。</p>
<p><cite>rs2`=`x0</cite> の場合、実装はアクティブな要素の数よりも少ないメモリ操作を実行することが許されますが、必須ではありません。
また、同じ静的に同じ命令の異なる動的な実行において、異なる数のメモリ操作を実行することができます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>即時ストライドが <cite>0</cite> のときに rs2 に <cite>x0</cite> 形式を使用しないように、
コンパイラーは注意しなければなりません。</p>
</div>
<p><cite>rs2!=x0</cite> で <cite>x[rs2]=0</cite> の場合、実装はアクティブな要素ごとに1回のメモリアクセスを
行わなければなりません(ただし、これらのアクセスは順序付けられません)。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>順序付きインデックス操作を使用することができます。</p>
</div>
</div>
<div class="section" id="id37">
<h2>ベクトルインデックス命令<a class="headerlink" href="#id37" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># ベクトルインデックスロードストア命令</span>

<span class="c1"># ベクトル順序無しインデックスロード命令</span>
<span class="c1"># vdは書き込みベクトルレジスタ, rs1はベースアドレス, vs2はインデックス</span>
<span class="n">vluxei8</span><span class="o">.</span><span class="n">v</span>    <span class="n">vd</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># unordered  8-bit SEWデータのインデックスロード命令</span>
<span class="n">vluxei16</span><span class="o">.</span><span class="n">v</span>   <span class="n">vd</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># unordered 16-bit SEWデータのインデックスロード命令</span>
<span class="n">vluxei32</span><span class="o">.</span><span class="n">v</span>   <span class="n">vd</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># unordered 32-bit SEWデータのインデックスロード命令</span>
<span class="n">vluxei64</span><span class="o">.</span><span class="n">v</span>   <span class="n">vd</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># unordered 64-bit SEWデータのインデックスロード命令</span>

<span class="c1"># ベクトル順序付きインデックスロード命令</span>
<span class="c1"># vdは書き込みベクトルレジスタ, rs1はベースアドレス, vs2はインデックス</span>
<span class="n">vloxei8</span><span class="o">.</span><span class="n">v</span>    <span class="n">vd</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ordered  8-bit SEWデータのインデックスロード命令</span>
<span class="n">vloxei16</span><span class="o">.</span><span class="n">v</span>   <span class="n">vd</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ordered 16-bit SEWデータのインデックスロード命令</span>
<span class="n">vloxei32</span><span class="o">.</span><span class="n">v</span>   <span class="n">vd</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ordered 32-bit SEWデータのインデックスロード命令</span>
<span class="n">vloxei64</span><span class="o">.</span><span class="n">v</span>   <span class="n">vd</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ordered 64-bit SEWデータのインデックスロード命令</span>

<span class="c1"># ベクトル順序無しインデックスストア命令</span>
<span class="c1"># vs3はストアデータ, rs1はベースアドレス, vs2はインデックス</span>
<span class="n">vsuxei8</span><span class="o">.</span><span class="n">v</span>   <span class="n">vs3</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span> <span class="c1"># unordered  8-bit SEWデータのインデックスストア命令</span>
<span class="n">vsuxei16</span><span class="o">.</span><span class="n">v</span>  <span class="n">vs3</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span> <span class="c1"># unordered 16-bit SEWデータのインデックスストア命令</span>
<span class="n">vsuxei32</span><span class="o">.</span><span class="n">v</span>  <span class="n">vs3</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span> <span class="c1"># unordered 32-bit SEWデータのインデックスストア命令</span>
<span class="n">vsuxei64</span><span class="o">.</span><span class="n">v</span>  <span class="n">vs3</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span> <span class="c1"># unordered 64-bit SEWデータのインデックスストア命令</span>

<span class="c1"># ベクトル順序付きインデックスストア命令</span>
<span class="c1"># vs3はストアデータ, rs1はベースアドレス, vs2はインデックス</span>
<span class="n">vsoxei8</span><span class="o">.</span><span class="n">v</span>    <span class="n">vs3</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ordered  8-bit SEWデータのインデックスストア命令</span>
<span class="n">vsoxei16</span><span class="o">.</span><span class="n">v</span>   <span class="n">vs3</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ordered 16-bit SEWデータのインデックスストア命令</span>
<span class="n">vsoxei32</span><span class="o">.</span><span class="n">v</span>   <span class="n">vs3</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ordered 32-bit SEWデータのインデックスストア命令</span>
<span class="n">vsoxei64</span><span class="o">.</span><span class="n">v</span>   <span class="n">vs3</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ordered 64-bit SEWデータのインデックスストア命令</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>静的にエンコードされたEEWがデータではなくインデックスであることを示すために、
<a href="#id38"><span class="problematic" id="id39">``</span></a>e``**x** の代わりに <a href="#id40"><span class="problematic" id="id41">``</span></a>ei``**x** を使用しています。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>他のベクトルアドレッシングモードには文字がありません。
この方法は、一貫性に欠けるかもしれませんが、VSXEIが以前は&quot;順序付き&quot;を意味していたように、
既存のソフトウェアの混乱を最小限に抑えることができます。
また、移行中にオペコードを別名として保持することで、ソフトウェアの解約を減らすことができます。</p>
</div>
</div>
<div class="section" id="fault-only-first">
<h2>ユニットストライドFault-Only-Firstロード<a class="headerlink" href="#fault-only-first" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ユニットストライドfault-only-first load命令は、データに依存した終了条件を持つループ(&quot;while &quot;ループ)をベクトル化するために使用されます。
これらの命令は、要素0で発生した同期例外による例外のみを取得することを除いて、
通常のロードと同様に実行されます。 要素 &gt; 0 で例外が発生した場合、対応する例外は取られず、
ベクトル長 <cite>vl</cite> は例外が発生したであろう要素のインデックスに縮小されます。</p>
<p>ロード命令は、例外が報告された要素のインデックスを超えて、アクティブな書き込みベクトルレジスタグループの要素を上書きする可能性があります。
同様に、fault-only-firstのロード命令では、書き込みレジスタの要素が、ベクトルの長さを切り詰める原因となる要素を超えて更新されることがあります(ただし、元のベクトルの長さを超えることはありません)。
これらの疑似更新の値は、アドレスされたメモリ位置のメモリ内の値と一致する必要はありません。
非占有のメモリ位置は、対応する要素のロード操作が例外やベクトル長のトリミングによって再起動されないことがわかっている場合にのみアクセスできます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># ベクトルユニットストライドfault-only-firstロード</span>

<span class="c1"># vdは書き込みレジスタ, rs1はベースアドレス, vmはマスクエンコーディング (v0.t もしくは&lt;指定なし&gt;)</span>
<span class="n">vle8ff</span><span class="o">.</span><span class="n">v</span>    <span class="n">vd</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vm</span>  <span class="c1">#    8-bit ユニットストライドfault-only-firstロード</span>
<span class="n">vle16ff</span><span class="o">.</span><span class="n">v</span>   <span class="n">vd</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vm</span>  <span class="c1">#   16-bit ユニットストライドfault-only-firstロード</span>
<span class="n">vle32ff</span><span class="o">.</span><span class="n">v</span>   <span class="n">vd</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vm</span>  <span class="c1">#   32-bit ユニットストライドfault-only-firstロード</span>
<span class="n">vle64ff</span><span class="o">.</span><span class="n">v</span>   <span class="n">vd</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vm</span>  <span class="c1">#   64-bit ユニットストライドfault-only-firstロード</span>
<span class="c1"># vle128ff.v  vd, (rs1), vm  #  128-bit ユニットストライドfault-only-firstロード(予約)</span>
<span class="c1"># vle256ff.v  vd, (rs1), vm  #  256-bit ユニットストライドfault-only-firstロード(予約)</span>
<span class="c1"># vle512ff.v  vd, (rs1), vm  #  512-bit ユニットストライドfault-only-firstロード(予約)</span>
<span class="c1"># vle1024ff.v vd, (rs1), vm  # 1024-bit ユニットストライドfault-only-firstロード(予約)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ユニットストライドfault</span><span class="o">-</span><span class="n">only</span><span class="o">-</span><span class="n">first命令によるstrlenの例</span>

<span class="n">include</span><span class="p">::</span><span class="n">example</span><span class="o">/</span><span class="n">strlen</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="n">lines</span><span class="o">=</span><span class="mf">4.</span><span class="o">.-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>セキュリティ上の懸念があります。 ストライドおよびスキャッター/ギャザーのfault-on-firstロード命令は、エンコーディング空間がないため提供されていません。
また、より大きなセキュリティ全体となる可能性があり、ソフトウェアは例外を経験することなく、
複数のランダムなページのアクセス性を簡単にチェックすることができます。
ユニットストライド版では、既知の領域とすぐに隣接する領域のプロービングしかできないため、セキュリティに大きな影響はありません。
将来のベクトル拡張では、非連続アクセスの fault-only-first を可能にするセキュリティ緩和策が実装される可能性があります。</p>
</div>
<p>例外が発生しない場合でも、実装では <cite>vl</cite> より少ない要素を処理し、それに応じて <cite>vl</cite> を減らすことが許可されていますが、
<cite>vstart`=0 かつ `vl</cite>&gt;0 の場合は、少なくとも 1 つの要素を処理する必要があります。</p>
<p>fault-on-firstロード命令が割り込みによる例外を発生する場合、
実装は <cite>vl</cite> を削減せず、代わりに <cite>vstart</cite> の値を設定する必要があります。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>実装は <cite>vl</cite> を減らすのではなく、イベントが失われる可能性があるため、
デバッグ・例外をトリガーするべきです。</p>
</div>
</div>
<div class="section" id="sec-aos">
<span id="id42"></span><h2>ベクトルロードストアセグメント命令<a class="headerlink" href="#sec-aos" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>この命令サブセットには、ISAの文字列名 <cite>Zvlsseg</cite> が与えられています。</p>
<p>ベクトルロード/ストアセグメント命令は、メモリ上の複数の連続したフィールドを、
連続した番号のベクトルレジスタとの間で移動します。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>&quot;構造体の配列&quot;データタイプの操作をサポートします。</p>
</div>
<p>ベクトル命令の符号化における3ビットの <cite>nf</cite> フィールドは、セグメントごとのフィールド数 <em>NFIELDS</em> よりも1つ少ない符号なし整数です。</p>
<p>EMULの設定は、EMUL * NFIELDS {le} 8となるようにしなければならず、
そうでない場合は、命令のエンコーディングは予約されています。</p>
<p>EMUL * NFIELDSは、セグメント化されたロード/ストア命令でタッチされる基本的なベクトルレジスタの数を表しています。
この制約により、この合計はアーキテクチャレジスタファイルの1/4以下となり、EMUL=8の通常の演算と同じになります。</p>
<p>各フィールドは、連続した番号のベクトルレジスタグループに保持されます。
EMUL&gt;1の場合、各フィールドは複数の連続した番号のベクトルレジスタで保持されるベクトルレジスタグループを占有し、
各フィールドのベクトルレジスタグループは通常のベクトルレジスタアライメント制約に従わなければなりません
(例えば、EMUL=2、NFIELDS=4の場合、各フィールドのベクトルレジスタグループは偶数のベクトルレジスタで開始しなければなりませんが、
8の倍数のベクトルレジスタ番号で開始する必要はありません)。</p>
<p>セグメント・ロードまたはストアによってアクセスされるベクトルレジスタ番号が31を超えてインクリメントされる場合、
その命令エンコーディングは予約されています。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>将来のより長い命令エンコーディングとの前方互換性を確保するためのものです。</p>
</div>
<p><cite>vl</cite> レジスタは、移動する構造体の数を示しており、
これは各ベクトルレジスタグループに転送される要素の数と同じです。
マスキングは構造体全体のレベルでも適用されます。</p>
<p>セグメントロードおよびストアでは、各セグメント内のフィールドにアクセスするために使用される個々のメモリアクセスは、
順序付きのインデックス付きのセグメントロードおよびストアであっても、お互いに順序付けられていません。</p>
<p>例外が発生した場合、<cite>vstart</cite> は構造体の単位になります。
構造体へのアクセスの途中で例外が発生した場合、
構造体へのアクセスのサブセットを実行するかどうかは、実装で定義されています。</p>
<div class="section" id="id43">
<h3>ベクトルユニットストライドセグメントロードストア命令<a class="headerlink" href="#id43" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ベクトルユニットストライドのセグメントロードおよびセグメントストア命令は、
パックされた連続したセグメント(&quot;array-of-structures&quot;)を
複数の書き込みベクトルレジスタグループに移動させます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>ソフトウェアは追加の命令を使ってセグメントから構造体フィールドをアンパックすることができます。</p>
</div>
<p>ユニットストライドのセグメントロードとストアには、
それぞれ <cite>vlseg</cite>/<cite>vsseg</cite> というアセンブラのプレフィックスが使われます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># フォーマット</span>
<span class="n">vlseg</span><span class="o">&lt;</span><span class="n">nf</span><span class="o">&gt;</span><span class="n">e</span><span class="o">&lt;</span><span class="n">eew</span><span class="o">&gt;.</span><span class="n">v</span> <span class="n">vd</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vm</span>       <span class="c1"># ユニットストライドセグメントロードのテンプレート</span>
<span class="n">vsseg</span><span class="o">&lt;</span><span class="n">nf</span><span class="o">&gt;</span><span class="n">e</span><span class="o">&lt;</span><span class="n">eew</span><span class="o">&gt;.</span><span class="n">v</span> <span class="n">vs3</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vm</span>       <span class="c1"># ユニットストライドセグメントストア命令のテンプレート</span>

<span class="c1"># Examples</span>
<span class="n">vlseg8e8</span><span class="o">.</span><span class="n">v</span> <span class="n">vd</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vm</span>   <span class="c1"># 1バイトフィールドを8つ持つ要素を8つのベクトルレジスタにロードする</span>

<span class="n">vsseg3e32</span><span class="o">.</span><span class="n">v</span> <span class="n">vs3</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vm</span>  <span class="c1"># 3*4バイトセグメントの要素をvs3,vs3+1,vs3+2からメモリにストアする</span>
</pre></div>
</div>
<p>ロードの場合、<cite>vd</cite> レジスタはセグメントからロードされる最初のフィールドを保持します。
ストアの場合は、 <cite>vs3</cite> レジスタが読み込まれ、各セグメントに格納される最初のフィールドが提供されます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 例1</span>
<span class="c1"># パッキングされたRGBピクセル(8bppの24ビットデータ構造)</span>
<span class="n">vsetvli</span> <span class="n">a1</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">e8</span><span class="p">,</span> <span class="n">ta</span><span class="p">,</span> <span class="n">ma</span>
<span class="n">vlseg3e8</span><span class="o">.</span><span class="n">v</span> <span class="n">v8</span><span class="p">,</span> <span class="p">(</span><span class="n">a0</span><span class="p">),</span> <span class="n">vm</span>
<span class="c1"># v8 は赤ピクセルを持っている</span>
<span class="c1"># v9 は緑ピクセルを持っている</span>
<span class="c1"># v10 青ピクセルを持っている</span>

<span class="c1"># 例2</span>
<span class="c1"># メモリ構造は複素数を持っている。32ビットの実数と32ビットの虚数を持っている</span>
<span class="n">vsetvli</span> <span class="n">a1</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">e32</span><span class="p">,</span> <span class="n">ta</span><span class="p">,</span> <span class="n">ma</span>
<span class="n">vlseg2e32</span><span class="o">.</span><span class="n">v</span> <span class="n">v8</span><span class="p">,</span> <span class="p">(</span><span class="n">a0</span><span class="p">),</span> <span class="n">vm</span>
<span class="c1"># v8 は実数を持っている</span>
<span class="c1"># v9 虚数を持っている</span>
</pre></div>
</div>
<p>ユニットストライド命令については、fault-only-first版も定義されている。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># ベクトルfault-only-firstユニットストライドセグメントロード命令の例</span>
<span class="n">vlseg</span><span class="o">&lt;</span><span class="n">nf</span><span class="o">&gt;</span><span class="n">e</span><span class="o">&lt;</span><span class="n">eew</span><span class="o">&gt;</span><span class="n">ff</span><span class="o">.</span><span class="n">v</span> <span class="n">vd</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span>  <span class="n">vm</span>          <span class="c1"># ユニットストライドfault-only-firstセグメントロード</span>
</pre></div>
</div>
<p>fault-only-firstセグメントのロードでは、セグメントへのアクセスの途中で例外が検出された場合、
要素のインデックスがゼロであるかどうかにかかわらず、セグメントのサブセットをロードするかどうかは実装で定義されます。</p>
<p>これらの命令は、例外が報告された時点や、ベクトル長がトリムされた時点を過ぎても、
書き込みベクトルレジスタグループの要素を上書きすることがあります。</p>
</div>
<div class="section" id="id44">
<h3>ベクトルストライドセグメントロードストア命令<a class="headerlink" href="#id44" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ベクトルのストライドセグメントは、GPRの引数 <cite>rs2</cite> で指定されたバイトストライドの
オフセットで区切られた連続したセグメントを移動してロード、ストアします。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># フォーマット</span>
<span class="n">vlsseg</span><span class="o">&lt;</span><span class="n">nf</span><span class="o">&gt;</span><span class="n">e</span><span class="o">&lt;</span><span class="n">eew</span><span class="o">&gt;.</span><span class="n">v</span> <span class="n">vd</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">rs2</span><span class="p">,</span> <span class="n">vm</span>          <span class="c1"># ストライドセグメントロード</span>
<span class="n">vssseg</span><span class="o">&lt;</span><span class="n">nf</span><span class="o">&gt;</span><span class="n">e</span><span class="o">&lt;</span><span class="n">eew</span><span class="o">&gt;.</span><span class="n">v</span> <span class="n">vs3</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">rs2</span><span class="p">,</span> <span class="n">vm</span>         <span class="c1"># ストライドセグメントストア</span>

<span class="c1"># 例</span>
<span class="n">vsetvli</span> <span class="n">a1</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">e8</span><span class="p">,</span> <span class="n">ta</span><span class="p">,</span> <span class="n">ma</span>
<span class="n">vlsseg3e8</span><span class="o">.</span><span class="n">v</span> <span class="n">v4</span><span class="p">,</span> <span class="p">(</span><span class="n">x5</span><span class="p">),</span> <span class="n">x6</span>   <span class="c1"># アドレスx5+i*x6をv4[i]に格納する</span>
                          <span class="c1">#  x5+i*x6+1をv5[i]に格納する</span>
                          <span class="c1">#  x5+i*x6+2をv6[i]に格納する</span>

<span class="c1"># 例</span>
<span class="n">vsetvli</span> <span class="n">a1</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">e32</span><span class="p">,</span> <span class="n">ta</span><span class="p">,</span> <span class="n">ma</span>
<span class="n">vssseg2e32</span><span class="o">.</span><span class="n">v</span> <span class="n">v2</span><span class="p">,</span> <span class="p">(</span><span class="n">x5</span><span class="p">),</span> <span class="n">x6</span>   <span class="c1"># v2[i]のワードをアドレスx5+i*x6にストアする</span>
                            <span class="c1">#   また、v3[i]のワードをx5+i*x6+4にストアする</span>
</pre></div>
</div>
<p>各セグメント内のフィールドへのアクセスは、
セグメントがメモリ内で重なるようなバイトストライドの場合も含め、
どのような順序でも行うことができます。</p>
</div>
<div class="section" id="id45">
<h3>ベクトルインデックスセグメントロードストア命令<a class="headerlink" href="#id45" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>各セグメントは、<cite>rs1</cite> フィールドのスカラのベースアドレスと、ベクトルレジスタ <cite>vs2</cite> のバイトオフセットを足したアドレスに位置します。
Index-Ordered形式とIndex-Unordered形式の両方が提供されており、
Index-Ordered形式はセグメントを要素順にアクセスします。
しかし、順序付けられた形式でも、個々のセグメント内のフィールドへのアクセスは、お互いに順序付けられていません。</p>
<p>データベクトルレジスタ群はEEW=SEW、EMUL=LMUL、
インデックスベクトルレジスタ群はEEWがEMUL=(EEW/SEW)*LMULで命令にエンコードされています。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 例</span>
<span class="n">vluxseg</span><span class="o">&lt;</span><span class="n">nf</span><span class="o">&gt;</span><span class="n">ei</span><span class="o">&lt;</span><span class="n">eew</span><span class="o">&gt;.</span><span class="n">v</span> <span class="n">vd</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># Indexed-unorderedセグメントロード</span>
<span class="n">vloxseg</span><span class="o">&lt;</span><span class="n">nf</span><span class="o">&gt;</span><span class="n">ei</span><span class="o">&lt;</span><span class="n">eew</span><span class="o">&gt;.</span><span class="n">v</span> <span class="n">vd</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># Indexed-orderedセグメントロード</span>
<span class="n">vsuxseg</span><span class="o">&lt;</span><span class="n">nf</span><span class="o">&gt;</span><span class="n">ei</span><span class="o">&lt;</span><span class="n">eew</span><span class="o">&gt;.</span><span class="n">v</span> <span class="n">vs3</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># Indexed-unorderedセグメントストア</span>
<span class="n">vsoxseg</span><span class="o">&lt;</span><span class="n">nf</span><span class="o">&gt;</span><span class="n">ei</span><span class="o">&lt;</span><span class="n">eew</span><span class="o">&gt;.</span><span class="n">v</span> <span class="n">vs3</span><span class="p">,</span> <span class="p">(</span><span class="n">rs1</span><span class="p">),</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># Indexed-orderedセグメントストア</span>

<span class="c1"># 例</span>
<span class="n">vsetvli</span> <span class="n">a1</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">e8</span><span class="p">,</span> <span class="n">ta</span><span class="p">,</span> <span class="n">ma</span>
<span class="n">vluxseg3ei32</span><span class="o">.</span><span class="n">v</span> <span class="n">v4</span><span class="p">,</span> <span class="p">(</span><span class="n">x5</span><span class="p">),</span> <span class="n">v3</span>   <span class="c1"># アドレスx5+v3[i]のバイトデータをv4[i]にロードする</span>
                          <span class="c1">#  アドレスx5+v3[i]+1のバイトデータをv5[i]にロードする</span>
                          <span class="c1">#  アドレスx5+v3[i]+2のバイトデータをv6[i]にロードする</span>

<span class="c1"># 例</span>
<span class="n">vsetvli</span> <span class="n">a1</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">e32</span><span class="p">,</span> <span class="n">ta</span><span class="p">,</span> <span class="n">ma</span>
<span class="n">vsuxseg2ei32</span><span class="o">.</span><span class="n">v</span> <span class="n">v2</span><span class="p">,</span> <span class="p">(</span><span class="n">x5</span><span class="p">),</span> <span class="n">v5</span>   <span class="c1"># v2[i]中のワードをアドレスx5+v5[i]にストアする</span>
                          <span class="c1">#   v3[i]中のワードをアドレスx5+v5[i]+4にストアする</span>
</pre></div>
</div>
<p>ベクトルインデックスセグメントロードでは、
書き込みベクトルレジスタグループはソースベクトルレジスタグループ(<cite>vs2</cite> で指定)と重なることはできません。</p>
</div>
</div>
<div class="section" id="id46">
<h2>ベクトル全体レジスタロードストア命令<a class="headerlink" href="#id46" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>LOAD-FPメジャーオペコードのベクトルロード全体レジスタ命令のフォーマット</p>
<p><a href="#id47"><span class="problematic" id="id48">``</span></a><a href="#id49"><span class="problematic" id="id50">`</span></a>wavedrom
{reg: [</p>
<blockquote>
<div><p>{bits: 7, name: 0x07, attr: 'VL*R*'},
{bits: 5, name: 'vd', attr: 'destination of load', type: 2},
{bits: 3, name: 'width'},
{bits: 5, name: 'rs1', attr: 'base address', type: 4},
{bits: 5, name: 8, attr: 'lumop'},
{bits: 1, name: 1, attr: 'vm'},
{bits: 2, name: 0x10000, attr: 'mop'},
{bits: 1, name: 'mew'},
{bits: 3, name: 'nf'},</p>
</div></blockquote>
<p><a href="#id51"><span class="problematic" id="id52">``</span></a><a href="#id53"><span class="problematic" id="id54">`</span></a>wavedrom
{reg: [</p>
<blockquote>
<div><p>{bits: 7, name: 0x27, attr: 'VS*R*'},
{bits: 5, name: 'vs3', attr: 'store data', type: 2},
{bits: 3, name: 0x1000},
{bits: 5, name: 'rs1', attr: 'base address', type: 4},
{bits: 5, name: 8, attr: 'sumop'},
{bits: 1, name: 1, attr: 'vm'},
{bits: 2, name: 0x100, attr: 'mop'},
{bits: 1, name: 0x100, attr: 'mew'},
{bits: 3, name: 'nf'},</p>
</div></blockquote>
<p>これらの命令は、ベクトルレジスタグループ全体をロードおよびストアします。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p><cite>vl</cite> や <cite>vtype</cite> を変更するとコストがかかる場合に、ベクトル・レジスタの保存や復元に使用することを目的としています。
例えば、コンパイラのレジスタ・スピル、ベクトル・レジスタで値が渡されるベクトル関数呼び出し、割り込みハンドラ、OSのコンテキスト・スイッチなどです。
ソフトウェアは、 <cite>vlenb</cite> レジスタを読むことで、転送されたバイト数を知ることができます。</p>
</div>
<p>ロード命令では、通常のユニットストライド・ロードのパターンに従って、
<cite>mew</cite> および <cite>width</cite> フィールドにEEWがエンコードされています。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>EEWに関係なく同じデータが出力先のレジスタ群に書き込まれます。
そのため、EEW=8 のバリエーションだけを用意すれば十分でした。
EEWのバリエーションをすべて用意したのは、エンコードされたEEWをヒントにして、
次にこのEEWでアクセスされる書き込みレジスタグループを示すことができるようにするためで、
これは内部的にデータを再配置する実装の助けになります。</p>
</div>
<p>ベクトル全体レジスタストア命令は、EEW=8 のマスクされていない
ユニットストライドストアと同様にエンコードされます。</p>
<p>フィールド <cite>nf</cite> は、ロードおよびストアするベクトルレジスタの数をエンコードします。
符号化されたレジスタ数は2の累乗でなければならず、
ベクトルレジスタ番号はベクトルレジスタグループと同様にアラインメントされていなければならず、
そうでなければ命令の符号化は予約されます。
<cite>nf</cite> フィールドは、転送するベクトルレジスタの数をエンコードするもので、
ベースの後に連続して番号が付けられます。
<cite>nf</cite> の値は1、2、4、8のみがサポートされており、その他の値は予約されています。
複数のレジスタを転送する場合、最も低い番号のベクトルレジスタは最も低い番号のメモリアドレスに保持され、
連続したベクトルレジスタ番号はメモリに連続して配置されます。</p>
<p>この命令は、 <cite>vtype</cite> や <cite>vl</cite> の現在の設定にかかわらず、 <cite>evl`=`nf</cite> <a href="#id55"><span class="problematic" id="id56">*</span></a>VLEN/EEWという実効ベクトル長で動作します。
<cite>vstart</cite> {ge} <cite>vl</cite> の場合には要素が書き込まれないという通常の特性は、 <cite>vtype</cite> や <cite>vl</cite> の現在の設定に関係なく動作します。
<cite>vstart</cite> {ge} <cite>vl</cite> の場合には要素が書き込まれないという通常の特性は、
これらの命令には適用されません。
代わりに、<cite>vstart</cite> {ge} <cite>evl</cite> の場合には要素は書き込まれません。</p>
<p>この命令は、要素のマスクされていないユニットストライドロードおよびストア命令と同様に動作し、
ベースアドレスは <cite>rs1</cite> で指定されるスカラ <cite>x</cite> レジスタで渡されます。</p>
<p>実装では、ベースアドレスが、エンコードされたEEWのサイズ(バイト)(EEW/8)と実装でサポートされている
SEWの最小サイズ(バイト)(SEW~MIN~/8)のいずれか大きい方に自然にアラインされていない場合、
レジスタ全体のロードとストアでアドレスのずれの例外を発生させることができます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>これらの命令の実装が簡素化されます。
サブセットの実装によっては、より小さなSEW幅をサポートしていない場合があるため、
エンコードされたEEWよりも大きくても、サポートされている最小のSEWに対してミスアラインド例外を報告することが許可されています。
極端な実装では、例えば SEW~MIN~&gt;XLEN のようになります。
ソフトウェア環境は、ABIをサポートするための最小アラインメント要件を義務付けることができます。</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 全体レジスタロードストア命令のフォーマット</span>
<span class="n">vl1r</span><span class="o">.</span><span class="n">v</span> <span class="n">v3</span><span class="p">,</span> <span class="p">(</span><span class="n">a0</span><span class="p">)</span>       <span class="c1"># vl1re8.vの疑似命令</span>

<span class="n">vl1re8</span><span class="o">.</span><span class="n">v</span>    <span class="n">v3</span><span class="p">,</span> <span class="p">(</span><span class="n">a0</span><span class="p">)</span>  <span class="c1"># a0に保持されているアドレスからVLEN/8バイトだけロードしv3に格納する</span>
<span class="n">vl1re16</span><span class="o">.</span><span class="n">v</span>   <span class="n">v3</span><span class="p">,</span> <span class="p">(</span><span class="n">a0</span><span class="p">)</span>  <span class="c1"># a0に保持されているアドレスからVLEN/16バイトだけロードしv3に格納する</span>
<span class="n">vl1re32</span><span class="o">.</span><span class="n">v</span>   <span class="n">v3</span><span class="p">,</span> <span class="p">(</span><span class="n">a0</span><span class="p">)</span>  <span class="c1"># a0に保持されているアドレスからVLEN/32バイトだけロードしv3に格納する</span>
<span class="n">vl1re64</span><span class="o">.</span><span class="n">v</span>   <span class="n">v3</span><span class="p">,</span> <span class="p">(</span><span class="n">a0</span><span class="p">)</span>  <span class="c1"># a0に保持されているアドレスからVLEN/64バイトだけロードしv3に格納する</span>
<span class="c1"># vl1re128.v  v3, (a0)</span>
<span class="c1"># vl1re256.v  v3, (a0)</span>
<span class="c1"># vl1re512.v  v3, (a0)</span>
<span class="c1"># vl1re1024.v v3, (a0)</span>

<span class="n">vl2r</span><span class="o">.</span><span class="n">v</span> <span class="n">v2</span><span class="p">,</span> <span class="p">(</span><span class="n">a0</span><span class="p">)</span>       <span class="c1"># vl2re8.v v2, (a0)の疑似命令</span>

<span class="n">vl2re8</span><span class="o">.</span><span class="n">v</span>    <span class="n">v2</span><span class="p">,</span> <span class="p">(</span><span class="n">a0</span><span class="p">)</span>  <span class="c1"># a0に保持されているアドレスから2*VLEN/8バイトだけロードしv2-v3に格納する</span>
<span class="n">vl2re16</span><span class="o">.</span><span class="n">v</span>   <span class="n">v2</span><span class="p">,</span> <span class="p">(</span><span class="n">a0</span><span class="p">)</span>  <span class="c1"># a0に保持されているアドレスから2*VLEN/16バイトだけロードしv2-v3に格納する</span>
<span class="n">vl2re32</span><span class="o">.</span><span class="n">v</span>   <span class="n">v2</span><span class="p">,</span> <span class="p">(</span><span class="n">a0</span><span class="p">)</span>  <span class="c1"># a0に保持されているアドレスから2*VLEN/32バイトだけロードしv2-v3に格納する</span>
<span class="n">vl2re64</span><span class="o">.</span><span class="n">v</span>   <span class="n">v2</span><span class="p">,</span> <span class="p">(</span><span class="n">a0</span><span class="p">)</span>  <span class="c1"># a0に保持されているアドレスから2*VLEN/64バイトだけロードしv2-v3に格納する</span>
<span class="c1"># vl2re128.v  v2, (a0)</span>
<span class="c1"># vl2re256.v  v2, (a0)</span>
<span class="c1"># vl2re512.v  v2, (a0)</span>
<span class="c1"># vl2re1024.v v2, (a0)</span>

<span class="n">vl4r</span><span class="o">.</span><span class="n">v</span> <span class="n">v4</span><span class="p">,</span> <span class="p">(</span><span class="n">a0</span><span class="p">)</span>       <span class="c1"># vl4re8.vの疑似命令</span>

<span class="n">vl4re8</span><span class="o">.</span><span class="n">v</span>    <span class="n">v4</span><span class="p">,</span> <span class="p">(</span><span class="n">a0</span><span class="p">)</span>  <span class="c1"># a0に保持されているアドレスから4*VLEN/8バイトだけロードしv4-v7に格納する</span>
<span class="n">vl4re16</span><span class="o">.</span><span class="n">v</span>   <span class="n">v4</span><span class="p">,</span> <span class="p">(</span><span class="n">a0</span><span class="p">)</span>
<span class="n">vl4re32</span><span class="o">.</span><span class="n">v</span>   <span class="n">v4</span><span class="p">,</span> <span class="p">(</span><span class="n">a0</span><span class="p">)</span>
<span class="n">vl4re64</span><span class="o">.</span><span class="n">v</span>   <span class="n">v4</span><span class="p">,</span> <span class="p">(</span><span class="n">a0</span><span class="p">)</span>
<span class="c1"># vl4re128.v  v4, (a0)</span>
<span class="c1"># vl4re256.v  v4, (a0)</span>
<span class="c1"># vl4re512.v  v4, (a0)</span>
<span class="c1"># vl4re1024.v v4, (a0)</span>

<span class="n">vl8r</span><span class="o">.</span><span class="n">v</span> <span class="n">v8</span><span class="p">,</span> <span class="p">(</span><span class="n">a0</span><span class="p">)</span>       <span class="c1"># vl8re8.vの疑似命令</span>

<span class="n">vl8re8</span><span class="o">.</span><span class="n">v</span>    <span class="n">v8</span><span class="p">,</span> <span class="p">(</span><span class="n">a0</span><span class="p">)</span>  <span class="c1"># a0に保持されているアドレスから8*VLEN/8バイトだけロードしv8-v15に格納する</span>
<span class="n">vl8re16</span><span class="o">.</span><span class="n">v</span>   <span class="n">v8</span><span class="p">,</span> <span class="p">(</span><span class="n">a0</span><span class="p">)</span>
<span class="n">vl8re32</span><span class="o">.</span><span class="n">v</span>   <span class="n">v8</span><span class="p">,</span> <span class="p">(</span><span class="n">a0</span><span class="p">)</span>
<span class="n">vl8re64</span><span class="o">.</span><span class="n">v</span>   <span class="n">v8</span><span class="p">,</span> <span class="p">(</span><span class="n">a0</span><span class="p">)</span>
<span class="c1"># vl8re128.v  v8, (a0)</span>
<span class="c1"># vl8re256.v  v8, (a0)</span>
<span class="c1"># vl8re512.v  v8, (a0)</span>
<span class="c1"># vl8re1024.v v8, (a0)</span>

<span class="n">vs1r</span><span class="o">.</span><span class="n">v</span> <span class="n">v3</span><span class="p">,</span> <span class="p">(</span><span class="n">a1</span><span class="p">)</span>      <span class="c1"># v3をa1に保持されているアドレスにストアする</span>
<span class="n">vs2r</span><span class="o">.</span><span class="n">v</span> <span class="n">v2</span><span class="p">,</span> <span class="p">(</span><span class="n">a1</span><span class="p">)</span>      <span class="c1"># v2-v3をa1に保持されているアドレスにストアする</span>
<span class="n">vs4r</span><span class="o">.</span><span class="n">v</span> <span class="n">v4</span><span class="p">,</span> <span class="p">(</span><span class="n">a1</span><span class="p">)</span>      <span class="c1"># v4-v7をa1に保持されているアドレスにストアする</span>
<span class="n">vs8r</span><span class="o">.</span><span class="n">v</span> <span class="n">v8</span><span class="p">,</span> <span class="p">(</span><span class="n">a1</span><span class="p">)</span>      <span class="c1"># v8-v15をa1に保持されているアドレスにストアする</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>実装上、不正命令例外を発生させる必要があります。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>これは現在PoRにはありません。</p>
</div>
</div>
</div>
<div class="section" id="id57">
<h1>ベクトルメモリアラインメント制約<a class="headerlink" href="#id57" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>ベクトルメモリ命令でアクセスした要素のサイズが自然にアラインされていない場合、
その要素は正常に転送されるか、その要素に対してアドレスミスアラインの例外が発生します。</p>
<p>ベクトルメモリアクセスのミスアラインメントのサポートは、
スカラメモリアクセスのミスアラインメントのサポートとは独立しています。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>関連するアドレス範囲でベクトルのミスアラインドアクセスがサポートされているかどうかを判断するために、別のPMAを定義する必要があります。</p>
</div>
<p>ベクトルのミスアラインドメモリアクセスは、
スカラのミスアラインドメモリアクセスと同じアトミック性のルールに従います。</p>
</div>
<div class="section" id="id58">
<h1>ベクトルメモリコンシステンシモデル<a class="headerlink" href="#id58" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>ベクトルメモリアクセス命令は、ローカルのhartではプログラム順に実行されているように見えます。</p>
<p>ベクトルメモリアクセス命令は、命令レベルではRVWMOに従います。</p>
<p>Index-Ordered形式以外のロード・ストア命令を除き、要素操作は命令内では順不同です。</p>
<p>Index-Ordered形式ロード・ストア命令は、
要素をメモリに読み書きする際に、それぞれ要素順に行います。</p>
<p>ベクトル長レジスタ <cite>vl</cite> の影響を受ける命令は、データ依存ではなく、
<cite>vl</cite> への制御依存を持ちます。
同様に、マスクされたベクトル命令は、データ依存ではなく、ソースマスクレジスタへの制御依存を持ちます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>ここでは通常、分岐命令が使用されていました。
マスクを制御として扱うことで、マスクされたベクトルロード命令は、
マスク値が判明する前にメモリにアクセスすることができ、
分岐予測失敗時に回復するメカニズムを必要としません。</p>
</div>
</div>
<div class="section" id="id59">
<h1>ベクトル算術演算命令<a class="headerlink" href="#id59" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>ベクトル演算命令では、OP-FPに隣接する新しいメジャーオペコード(OP-V = 1010111~2~)を使用します。
3ビットの <cite>funct3</cite> フィールドは、ベクトル命令のサブカテゴリを定義するのに使われます。</p>
<p>include::valu-format.adoc[]</p>
<div class="section" id="sec-arithmetic-encoding">
<span id="id60"></span><h2>ベクトル算術演算命令エンコーディング<a class="headerlink" href="#sec-arithmetic-encoding" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><cite>funct3</cite> フィールによりオペランドのタイプとソース位置をエンコードします。</p>
<p>整数演算は、オペコードに応じて符号なしまたは2の補数の符号付き整数演算で行われます。</p>
<p>すべての標準ベクトル浮動小数点演算は、IEEE-754/2008 規格に準拠しています。
すべてのベクトル浮動小数点演算は、<cite>frm</cite> レジスタのダイナミック丸めモードを使用します。
丸めモードに依存しない命令であっても、ベクトル浮動小数点演算命令で無効な丸めモードが含まれている場合や、
<cite>vl`=0 の場合、または `vstart</cite> {ge} <cite>vl</cite> の場合の <cite>frm</cite> フィールドの使用は予約されています。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>実装では、制御ロジックを単純化するために、丸めモードが無効なときにすべてのベクトルFP命令が例外を報告するようにすることができます。</p>
</div>
<p>ベクトル演算は、<cite>vs2</cite> と <cite>vs1</cite> でそれぞれ指定されたベクトルレジスタグループから、
オペランドの2つのベクトルを取ります。</p>
<p>ベクトル・スカラ演算には3つの形式がありますが、いずれの場合も、
<cite>vs2</cite> で指定されたベクトルレジスタ群から1つのベクトルのオペランドを取り、
3つの代替ソースのうちの1つから2つ目のスカラソースのオペランドを取ります。</p>
<ul class="simple">
<li><p>整数演算の場合、スカラは <cite>rs1</cite> フィールドでエンコードされた5ビットの即値になります。</p></li>
</ul>
<p>この値は、特に指定がない限り、SEWビットに符号拡張されます。
* 整数演算では、スカラは <cite>rs1</cite> で指定されたスカラ <cite>x</cite> レジスタから取ることができます。
XLEN&gt;SEWの場合、特に指定がない限り、<cite>x</cite> レジスタの最下位SEWビットが使用されます。
XLEN&lt;SEWの場合、<cite>x</cite> レジスタからの値はSEWビットに符号拡張されます。
浮動小数点演算の場合、スカラはスカラ <cite>f</cite> レジスタから取得できます。
FLEN &gt; SEWの場合、 <cite>f</cite> レジスタの値が有効なNaNボックス値であるかどうかがチェックされ、
その場合は <cite>f</cite> レジスタの最下位SEWビットが使用され、そうでない場合は正規のNaN値が使用されます。
浮動小数点ベクトルオペランドのEEWがサポートされていない浮動小数点型の幅であるベクトル命令(FLEN &lt; SEWの場合を含む)は予約されています。</p>
<p>ベクトル演算命令は、<cite>vm</cite> フィールドの制御下でマスクされます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># ベクトル2項算術演算命令のアセンブリ構文パタン</span>

<span class="c1"># ベクトル演算の結果はvm(v0.t, &lt;指定なし&gt;)によりマスクされる</span>
<span class="n">vop</span><span class="o">.</span><span class="n">vv</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># 整数 ベクトル-ベクトル vd[i] = vs2[i] op vs1[i]</span>
<span class="n">vop</span><span class="o">.</span><span class="n">vx</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># 整数 ベクトル-スカラ   vd[i] = vs2[i] op x[rs1]</span>
<span class="n">vop</span><span class="o">.</span><span class="n">vi</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">imm</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># 整数 ベクトル-即値     vd[i] = vs2[i] op imm</span>

<span class="n">vfop</span><span class="o">.</span><span class="n">vv</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span> <span class="c1"># 浮動小数点 ベクトル-ベクトル 演算 vd[i] = vs2[i] fop vs1[i]</span>
<span class="n">vfop</span><span class="o">.</span><span class="n">vf</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span> <span class="c1"># 浮動小数点 ベクトル-スカラ 演算   vd[i] = vs2[i] fop f[rs1]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>これは、標準的なスカラの順序とは逆です。
この配列は、1つのスカラレジスタのみを読み出す命令は <cite>rs1</cite> から読み出すという既存のエンコーディング規約を維持し、
5ビットの即値は <cite>rs1</cite> フィールドから供給されます。</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># ベクトル3項算術演算命令(multiply-add)のアセンブリ構文パタン</span>

<span class="c1"># 加算入力値を上書きする整数演算</span>
<span class="n">vop</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vd[i] = vs1[i] * vs2[i] + vd[i]</span>
<span class="n">vop</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vd[i] = x[rs1] * vs2[i] + vd[i]</span>

<span class="c1"># 乗算入力値を上書きする整数演算</span>
<span class="n">vop</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vd[i] = vs1[i] * vd[i] + vs2[i]</span>
<span class="n">vop</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vd[i] = x[rs1] * vd[i] + vs2[i]</span>

<span class="c1"># 加算入力値を上書きする浮動小数点演算</span>
<span class="n">vfop</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vd[i] = vs1[i] * vs2[i] + vd[i]</span>
<span class="n">vfop</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vd[i] = f[rs1] * vs2[i] + vd[i]</span>

<span class="c1"># 乗算入力値を上書きする浮動小数点演算</span>
<span class="n">vfop</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vd[i] = vs1[i] * vd[i] + vs2[i]</span>
<span class="n">vfop</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vd[i] = f[rs1] * vd[i] + vs2[i]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>次に <cite>rs1</cite> または <cite>vs1</cite> 、そして <cite>vs2</cite> の順になります。
この順序では、乗算オペランドが常に隣り合っているため、
これらの三項演算のアセンブラをより自然に読むことができます。</p>
</div>
</div>
<div class="section" id="sec-widening">
<span id="id61"></span><h2>幅拡張ベクトル算術演算命令<a class="headerlink" href="#sec-widening" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>いくつかのベクトル演算命令は、書き込みベクトルレジスタグループがEEW=2*SEWおよびEMUL=2*LMULを持つ**幅拡張** 演算が定義されています。</p>
<p>第1ベクトルレジスタグループのオペランドは、単一幅または二倍幅のいずれかです。
これらは通常、オペコードの前に <cite>vw*</cite> というプレフィックスを付けて記述され、
ベクトル浮動小数点演算の場合は <cite>vfw*</cite> となります。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ベクトル幅拡張算術演算命令のアセンブリ構文パタン</span>

<span class="c1"># 2つの1倍幅ソースで2倍幅の結果: 2*SEW = SEW op SEW</span>
<span class="n">vwop</span><span class="o">.</span><span class="n">vv</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># 整数 vector-vector      vd[i] = vs2[i] op vs1[i]</span>
<span class="n">vwop</span><span class="o">.</span><span class="n">vx</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># 整数 vector-scalar      vd[i] = vs2[i] op x[rs1]</span>

<span class="c1"># 1番目のソースオペランドが2倍幅, 2番目のソースオペランドが1倍幅, 結果が2倍幅: 2*SEW = SEW op SEW</span>
<span class="n">vwop</span><span class="o">.</span><span class="n">wv</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># 整数 vector-vector      vd[i] = vs2[i] op vs1[i]</span>
<span class="n">vwop</span><span class="o">.</span><span class="n">wx</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># 整数 vector-scalar      vd[i] = vs2[i] op x[rs1]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>2倍幅整数のワードサイズの演算を意味する <cite>w</cite> という接尾語と混同される恐れがあったため、 <cite>w</cite> はプレフィックスに移されました。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p><cite>vwf*</cite> から <cite>vfw*</cite> に変更されました。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>これらは4倍にするために、オペコードの前に <cite>vq*</cite> という接頭語を付けることで区別されます。
これらは、現時点では含まれていませんが、将来の拡張で追加される可能性があります。</p>
</div>
<p>すべての幅拡張命令において、書き込みのEEWおよびEMULの値はサポートされているコンフィギュレーションでなければならず、
そうでない場合は命令のエンコーディングは予約されています。</p>
<p>書き込みベクトルレジスタグループは、書き込みのEMULに有効なベクトルレジスタ番号を使って指定しなければならず、
そうでない場合は命令エンコーディングは予約されます。</p>
</div>
<div class="section" id="sec-narrowing">
<span id="id62"></span><h2>ベクトル幅縮小算術演算命令<a class="headerlink" href="#sec-narrowing" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>2 倍幅のソースベクトルを 1 倍幅の書き込みベクトルに変換する命令がいくつか用意されています。
これらの命令は、EEW/EMUL=2*SEW/2*LMULのベクトルレジスタグループを、
現在のSEW/LMUL設定のベクトルレジスタグループに変換します。</p>
<p>EEW &gt; ELENまたはEMUL &gt; 8の場合、命令のエンコーディングは予約されています。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>ここでの選択は、選択されたアプローチがより少ない <cite>vtype</cite> の変更を必要とするという信念に基づいています。</p>
</div>
<p>ソースおよび書き込みベクトルレジスタグループは、ソースおよび書き込みのEMUL値に対してそれぞれ正当な
ベクトルレジスタ番号で指定されなければならず、そうでなければ命令エンコーディングは予約されます。</p>
<p>第2のソースベクトルレジスタグループ(<cite>vs1</cite> で指定)がある場合、
これは結果と同じ(より狭い)幅を持ちます(すなわち、EEW=SEW)。</p>
<p>アセンブラでこれらの命令を区別するためにオペコードに <cite>vn*</cite> というプレフィックスをつけたり、
浮動小数点オペコードを絞り込むために <cite>vfn*</cite> というプレフィックスをつけたりします。
2倍幅ソースベクトルレジスタグループは、
ソースオペランドのサフィックスに <cite>w</cite> を付けて表します(例: <cite>vnsra.wv</cite>)。</p>
</div>
</div>
<div class="section" id="sec-vector-integer">
<span id="id63"></span><h1>ベクトル整数算術演算命令<a class="headerlink" href="#sec-vector-integer" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>整数ベクトル算術演算命令が提供されています。</p>
<div class="section" id="id64">
<h2>ベクトル単一幅整数加算減算命令<a class="headerlink" href="#id64" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトル整数加減算命令が提供されています。
ベクトル・スカラ形式においては逆減算命令も提供されています。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 整数加算</span>
<span class="n">vadd</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vadd</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-スカラ</span>
<span class="n">vadd</span><span class="o">.</span><span class="n">vi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">imm</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-即値</span>

<span class="c1"># 整数減算</span>
<span class="n">vsub</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vsub</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-スカラ</span>

<span class="c1"># 整数逆減算</span>
<span class="n">vrsub</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vd[i] = x[rs1] - vs2[i]</span>
<span class="n">vrsub</span><span class="o">.</span><span class="n">vi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">imm</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vd[i] = imm - vs2[i]</span>
</pre></div>
</div>
<p>ベクトル内の整数値は、<cite>x0</cite> とのスカラ逆減算によって符号を反転することができます。
これは <cite>vneg vd,vs</cite> = <cite>vrsub.vx vd,vs,x0</cite> としてアセンブリ疑似命令を定義することができます。</p>
</div>
<div class="section" id="id65">
<h2>ベクトル幅拡張整数加減算命令<a class="headerlink" href="#id65" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>符号付きと符号なしの両方で、幅拡張加減算命令が定義されています。
これらは幅の小さいオペランドが最初に符号拡張かゼロ拡張され、
倍幅での加減算が行われます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 符号なし整数の幅拡張加減算命令, 2*SEW = SEW +/- SEW</span>
<span class="n">vwaddu</span><span class="o">.</span><span class="n">vv</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vector-vector</span>
<span class="n">vwaddu</span><span class="o">.</span><span class="n">vx</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vector-scalar</span>
<span class="n">vwsubu</span><span class="o">.</span><span class="n">vv</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vector-vector</span>
<span class="n">vwsubu</span><span class="o">.</span><span class="n">vx</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vector-scalar</span>

<span class="c1"># 符号付き整数の幅拡張加減算命令, 2*SEW = SEW +/- SEW</span>
<span class="n">vwadd</span><span class="o">.</span><span class="n">vv</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vector-vector</span>
<span class="n">vwadd</span><span class="o">.</span><span class="n">vx</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vector-scalar</span>
<span class="n">vwsub</span><span class="o">.</span><span class="n">vv</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vector-vector</span>
<span class="n">vwsub</span><span class="o">.</span><span class="n">vx</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vector-scalar</span>

<span class="c1"># 符号なし整数の幅拡張加減算命令, 2*SEW = 2*SEW +/- SEW</span>
<span class="n">vwaddu</span><span class="o">.</span><span class="n">wv</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vector-vector</span>
<span class="n">vwaddu</span><span class="o">.</span><span class="n">wx</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vector-scalar</span>
<span class="n">vwsubu</span><span class="o">.</span><span class="n">wv</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vector-vector</span>
<span class="n">vwsubu</span><span class="o">.</span><span class="n">wx</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vector-scalar</span>

<span class="c1"># 符号付き整数の幅拡張加減算命令, 2*SEW = 2*SEW +/- SEW</span>
<span class="n">vwadd</span><span class="o">.</span><span class="n">wv</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vector-vector</span>
<span class="n">vwadd</span><span class="o">.</span><span class="n">wx</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vector-scalar</span>
<span class="n">vwsub</span><span class="o">.</span><span class="n">wv</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vector-vector</span>
<span class="n">vwsub</span><span class="o">.</span><span class="n">wx</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vector-scalar</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p><cite>vwcvt.x.x.v vd,vs,vm = vwadd.vx vd,vs,x0,vm</cite> と <cite>vwcvtu.x.x.v vd,vs,vm = vwaddu.vx vd,vs,x0,vm</cite> により
疑似アセンブリ命令を定義することができます。</p>
</div>
</div>
<div class="section" id="id66">
<h2>ベクトル整数拡張<a class="headerlink" href="#id66" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ゼロ拡張と符号拡張のベクトル整数拡張命令は、SEWよりも小さいEEWの整数オペランドを
SEWの幅まで拡張して書き込みレジスタに転送します。
ソースのEEWはSEWの1/2, 1/4, 1/8であり、ソースのEMULは(EEW/SEW)*LMULです。
書き込み側のEEWはSEWと同一であり、EMULはLMULと同一です。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vzext</span><span class="o">.</span><span class="n">vf2</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># SEW/2のソースオペランドをゼロ拡張してSEW幅化し書き込む</span>
<span class="n">vsext</span><span class="o">.</span><span class="n">vf2</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># SEW/2のソースオペランドを符号拡張してSEW幅化し書き込む</span>
<span class="n">vzext</span><span class="o">.</span><span class="n">vf4</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># SEW/4のソースオペランドをゼロ拡張してSEW幅化し書き込む</span>
<span class="n">vsext</span><span class="o">.</span><span class="n">vf4</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># SEW/4のソースオペランドを符号拡張してSEW幅化し書き込む</span>
<span class="n">vzext</span><span class="o">.</span><span class="n">vf8</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># SEW/8のソースオペランドをゼロ拡張してSEW幅化し書き込む</span>
<span class="n">vsext</span><span class="o">.</span><span class="n">vf8</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># SEW/8のソースオペランドを符号拡張してSEW幅化し書き込む</span>
</pre></div>
</div>
<p>ソースのEEWがサポートされていない場合もしくはEMULがLMULの最小値よりも小さい場合、
命令エンコーディングは予約されています。</p>
</div>
<div class="section" id="id67">
<h2>ベクトル整数 キャリー付き加算 / ボロー付き減算命令<a class="headerlink" href="#id67" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>複数ワードの整数演算をサポートするために、キャリービットを操作する命令が用意されています。
各演算(加算または減算)には2つの命令が用意されています。
1つは演算結果(SEW幅)を提供し、
もう1つはキャリー出力(マスク・ブールとしてエンコードされた1ビット)を生成します。</p>
<p>キャリー入出力は、 &lt;sec-mask-register-layout&gt; 節で説明したマスクレジスタのレイアウトを用いて表現されます。
エンコーディングの制約により、キャリー入力は暗黙の <cite>v0</cite> レジスタから出力されなければなりませんが、
キャリー出力はソース/書き込みのオーバーラップの制約を満たす任意のベクトルレジスタに書き込むことができます。</p>
<p><cite>vadc</cite> と <cite>vsbc</cite> は、ソースオペランドとキャリーインまたはボローインの加算または減算を行い、
その結果をベクトルレジスタ <cite>vd</cite> に書き込みます。
これらの命令は、マスクされた命令 (<cite>vm=0</cite>) としてエンコードされていますが、すべてのボディ要素を操作し、書き戻します。
マスクされていないバージョン(<cite>vm=1</cite>)に対応するエンコーディングは予約されています。</p>
<p><cite>vvmadc</cite> と <cite>vmsbc</cite> は、ソースオペランドを加算または減算し、マスクされている (<cite>vm=0</cite>) 場合にはオプションでキャリーインを加算またはボローインを減算し、
その結果をマスクレジスタ <cite>vd</cite> に書き戻します。
マスクされていない場合 (<cite>vm=1</cite>)、キャリーインやボローインはありません。
これらの命令は、マスクされていても、すべてのボディ要素を操作し、書き戻します。
これらの命令はマスク値を生成するため、常に末尾Agnosticポリシで動作します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># キャリー付き加算命令</span>

<span class="c1"># vd[i] = vs2[i] + vs1[i] + v0.mask[i]</span>
<span class="n">vadc</span><span class="o">.</span><span class="n">vvm</span>   <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">v0</span>  <span class="c1"># ベクトル-ベクトル</span>

<span class="c1"># vd[i] = vs2[i] + x[rs1] + v0.mask[i]</span>
<span class="n">vadc</span><span class="o">.</span><span class="n">vxm</span>   <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">v0</span>  <span class="c1"># ベクトル-スカラ</span>

<span class="c1"># vd[i] = vs2[i] + imm + v0.mask[i]</span>
<span class="n">vadc</span><span class="o">.</span><span class="n">vim</span>   <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">imm</span><span class="p">,</span> <span class="n">v0</span>  <span class="c1"># ベクトル-即値</span>

<span class="c1"># マスクレジスタフォーマットにキャリーアウトを生成する</span>

<span class="c1"># vd.mask[i] = carry*out(vs2[i] + vs1[i] + v0.mask[i])</span>
<span class="n">vmadc</span><span class="o">.</span><span class="n">vvm</span>   <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">v0</span>  <span class="c1"># ベクトル-ベクトル</span>

<span class="c1"># vd.mask[i] = carry*out(vs2[i] + x[rs1] + v0.mask[i])</span>
<span class="n">vmadc</span><span class="o">.</span><span class="n">vxm</span>   <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">v0</span>  <span class="c1"># ベクトル-スカラ</span>

<span class="c1"># vd.mask[i] = carry*out(vs2[i] + imm + v0.mask[i])</span>
<span class="n">vmadc</span><span class="o">.</span><span class="n">vim</span>   <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">imm</span><span class="p">,</span> <span class="n">v0</span>  <span class="c1"># ベクトル-即値</span>

<span class="c1"># vd.mask[i] = carry*out(vs2[i] + vs1[i])</span>
<span class="n">vmadc</span><span class="o">.</span><span class="n">vv</span>    <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span>      <span class="c1"># ベクトル-ベクトル, no carry-in</span>

<span class="c1"># vd.mask[i] = carry*out(vs2[i] + x[rs1])</span>
<span class="n">vmadc</span><span class="o">.</span><span class="n">vx</span>    <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span>      <span class="c1"># ベクトル-スカラ, no carry-in</span>

<span class="c1"># vd.mask[i] = carry*out(vs2[i] + imm)</span>
<span class="n">vmadc</span><span class="o">.</span><span class="n">vi</span>    <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">imm</span>      <span class="c1"># ベクトル-即値, no carry-in</span>
</pre></div>
</div>
<p>キャリー伝搬を実装するには、入力が変更されていない状態で2つの命令を実行する必要があるため、
破壊的な蓄積を行うと、正しい結果を得るために追加の移動が必要になります。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># v4に値を蓄積する複数ワード算術演算命令列</span>
<span class="n">vmadc</span><span class="o">.</span><span class="n">vvm</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v4</span><span class="p">,</span> <span class="n">v8</span><span class="p">,</span> <span class="n">v0</span>  <span class="c1"># 一時レジスタv1にキャリーを格納する</span>
<span class="n">vadc</span><span class="o">.</span><span class="n">vvm</span> <span class="n">v4</span><span class="p">,</span> <span class="n">v4</span><span class="p">,</span> <span class="n">v8</span><span class="p">,</span> <span class="n">v0</span>   <span class="c1"># 加算を行う</span>
<span class="n">vmmv</span><span class="o">.</span><span class="n">m</span> <span class="n">v0</span><span class="p">,</span> <span class="n">v1</span>             <span class="c1"># 次のワードのために一時キャリーをv0に移動する</span>
</pre></div>
</div>
<p>ボロー付き減算命令 <cite>vsbc</cite> は、減算のためのロングワード演算をサポートするための機能を果たします。
即値での減算命令はありません。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># ボロー付きの差分を計算する</span>

<span class="c1"># vd[i] = vs2[i] - vs1[i] - v0.mask[i]</span>
<span class="n">vsbc</span><span class="o">.</span><span class="n">vvm</span>   <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">v0</span>  <span class="c1"># Vector-vector</span>

<span class="c1"># vd[i] = vs2[i] - x[rs1] - v0.mask[i]</span>
<span class="n">vsbc</span><span class="o">.</span><span class="n">vxm</span>   <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">v0</span>  <span class="c1"># Vector-scalar</span>

<span class="c1"># マスクレジスタフォーマットでボロー出力を生成する</span>

<span class="c1"># vd.mask[i] = borrow*out(vs2[i] - vs1[i] - v0.mask[i])</span>
<span class="n">vmsbc</span><span class="o">.</span><span class="n">vvm</span>   <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">v0</span>  <span class="c1"># Vector-vector</span>

<span class="c1"># vd.mask[i] = borrow*out(vs2[i] - x[rs1] - v0.mask[i])</span>
<span class="n">vmsbc</span><span class="o">.</span><span class="n">vxm</span>   <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">v0</span>  <span class="c1"># Vector-scalar</span>

<span class="c1"># vd.mask[i] = borrow*out(vs2[i] - vs1[i])</span>
<span class="n">vmsbc</span><span class="o">.</span><span class="n">vv</span>    <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span>      <span class="c1"># Vector-vector, no borrow-in</span>

<span class="c1"># vd.mask[i] = borrow*out(vs2[i] - x[rs1])</span>
<span class="n">vmsbc</span><span class="o">.</span><span class="n">vx</span>    <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span>      <span class="c1"># Vector-scalar, no borrow-in</span>
</pre></div>
</div>
<p><cite>vmsbc</cite> では、切り捨て前の差が負であるときに限りボローは1と定義される。</p>
<p><cite>vadc</cite> と <cite>vsbc</cite> では書き込みベクトルレジスタが <cite>v0</cite> の場合、命令エンコーディングが予約されます。</p>
</div>
<div class="section" id="id68">
<h2>ベクトル論理命令<a class="headerlink" href="#id68" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 論理命令</span>
<span class="n">vand</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vand</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-スカラ</span>
<span class="n">vand</span><span class="o">.</span><span class="n">vi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">imm</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-即値</span>

<span class="n">vor</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vor</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># ベクトル-スカラ</span>
<span class="n">vor</span><span class="o">.</span><span class="n">vi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">imm</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># ベクトル-即値</span>

<span class="n">vxor</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vxor</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># ベクトル-スカラ</span>
<span class="n">vxor</span><span class="o">.</span><span class="n">vi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">imm</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># ベクトル-即値</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>これは、アセンブラの疑似命令 <cite>vnot.v</cite> として提供することができます。</p>
</div>
</div>
<div class="section" id="id69">
<h2>ベクトル単一幅ビットシフト命令<a class="headerlink" href="#id69" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>左への論理シフト、右への論理(ゼロ拡張)および算術(符号拡張)シフトを含む、完全なベクトルシフト命令が用意されています。
シフトするデータは、 <cite>vs2</cite> で指定されたベクトルレジスタグループにあり、シフト量はベクトルレジスタグループ <cite>vs1</cite> 、スカラ整数レジスタ <cite>rs1</cite> 、または即値となります。
ベクトルまたはスカラのシフト量の値の下位lg2(SEW)ビットが使用され、シフト量の即値はゼロ拡張されます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># ビットシフト操作</span>
<span class="n">vsll</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vsll</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-スカラ</span>
<span class="n">vsll</span><span class="o">.</span><span class="n">vi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">uimm</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-即値</span>

<span class="n">vsrl</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vsrl</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-スカラ</span>
<span class="n">vsrl</span><span class="o">.</span><span class="n">vi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">uimm</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-即値</span>

<span class="n">vsra</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vsra</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-スカラ</span>
<span class="n">vsra</span><span class="o">.</span><span class="n">vi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">uimm</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-即値</span>
</pre></div>
</div>
</div>
<div class="section" id="id70">
<h2>ベクトルサイズ幅縮退整数右シフト命令<a class="headerlink" href="#id70" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>サイズ幅縮退の右シフトは、広いオペランドからより小さいフィールドを取り出すもので、ゼロ拡張(<cite>srl</cite>)と符号拡張(<cite>sra</cite>)の両方の形式があります。
シフト量は、ベクトル、スカラの <cite>x</cite> レジスタ、または5ビットの即値から得られます。
ベクトルまたはスカラのシフト量の下位lg2(2*SEW)ビットが使用されます(例えば、SEW=64ビットからSEW=32ビットへの狭帯域化の場合は下位6ビット)。
即値形式は、シフト量の即値オペランドをゼロ拡張します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Narrowing shift right logical, SEW = (2*SEW) &gt;&gt; SEW</span>
<span class="c1"># ビット幅縮退論理右シフト命令, SEW = (2*SEW) &gt;&gt; SEW</span>
<span class="n">vnsrl</span><span class="o">.</span><span class="n">wv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vector-vector</span>
<span class="n">vnsrl</span><span class="o">.</span><span class="n">wx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vector-scalar</span>
<span class="n">vnsrl</span><span class="o">.</span><span class="n">wi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">uimm</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vector-immediate</span>

<span class="c1"># Narrowing shift right arithmetic, SEW = (2*SEW) &gt;&gt; SEW</span>
<span class="c1"># ビット幅縮退算術右シフト命令, SEW = (2*SEW) &gt;&gt; SEW</span>
<span class="n">vnsra</span><span class="o">.</span><span class="n">wv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vector-vector</span>
<span class="n">vnsra</span><span class="o">.</span><span class="n">wx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vector-scalar</span>
<span class="n">vnsra</span><span class="o">.</span><span class="n">wi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">uimm</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vector-immediate</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>アセンブリ疑似命令 <cite>vncvt.x.x.w vd,vs,vm</cite> = <cite>vnsrl.wx vd,vs,x0,vm</cite> を定義することができます。</p>
</div>
</div>
<div class="section" id="id71">
<h2>ベクトル整数比較命令<a class="headerlink" href="#id71" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下の整数比較命令は、比較の結果が真であれば書き込みマスクレジスタの要素に1を、そうでなければ0を書き込みます。
書き込みマスクベクトルは常に単一のベクトルレジスタに保持され、その要素のレイアウトはセクション <a class="reference internal" href="#sec-mask-register-layout"><span class="std std-ref">マスクレジスタのレイアウト</span></a>  で説明されています。
書き込みマスクレジスタは、ソースベクトルのマスクレジスタ(<cite>v0</cite>)と同じものでも構いません。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set if equal</span>
<span class="n">vmseq</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vmseq</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-スカラ</span>
<span class="n">vmseq</span><span class="o">.</span><span class="n">vi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">imm</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-即値</span>

<span class="c1"># Set if not equal</span>
<span class="n">vmsne</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vmsne</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-スカラ</span>
<span class="n">vmsne</span><span class="o">.</span><span class="n">vi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">imm</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-即値</span>

<span class="c1"># Set if less than, unsigned</span>
<span class="n">vmsltu</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vmsltu</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-スカラ</span>

<span class="c1"># Set if less than, signed</span>
<span class="n">vmslt</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vmslt</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-スカラ</span>

<span class="c1"># Set if less than or equal, unsigned</span>
<span class="n">vmsleu</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vmsleu</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-スカラ</span>
<span class="n">vmsleu</span><span class="o">.</span><span class="n">vi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">imm</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-即値</span>

<span class="c1"># Set if less than or equal, signed</span>
<span class="n">vmsle</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vmsle</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-スカラ</span>
<span class="n">vmsle</span><span class="o">.</span><span class="n">vi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">imm</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-即値</span>

<span class="c1"># Set if greater than, unsigned</span>
<span class="n">vmsgtu</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-スカラ</span>
<span class="n">vmsgtu</span><span class="o">.</span><span class="n">vi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">imm</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-即値</span>

<span class="c1"># Set if greater than, signed</span>
<span class="n">vmsgt</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># ベクトル-スカラ</span>
<span class="n">vmsgt</span><span class="o">.</span><span class="n">vi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">imm</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># ベクトル-即値</span>

<span class="c1"># 以下の2命令は直接提供されない</span>
<span class="c1"># Set if greater than or equal, unsigned</span>
<span class="c1"># vmsgeu.vx vd, vs2, rs1, vm    # ベクトル-スカラ</span>
<span class="c1"># Set if greater than or equal, signed</span>
<span class="c1"># vmsge.vx vd, vs2, rs1, vm    # ベクトル-スカラ</span>
</pre></div>
</div>
<p>以下の表は全ての比較操作がどのようにネイティブマシンコードに実装されるのかを示しています。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">比較</span>            <span class="n">アセンブラマッピング</span>          <span class="n">アセンブラ疑似命令</span>

<span class="n">va</span> <span class="o">&lt;</span> <span class="n">vb</span>         <span class="n">vmslt</span><span class="p">{</span><span class="n">u</span><span class="p">}</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="n">vm</span>
<span class="n">va</span> <span class="o">&lt;=</span> <span class="n">vb</span>        <span class="n">vmsle</span><span class="p">{</span><span class="n">u</span><span class="p">}</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="n">vm</span>
<span class="n">va</span> <span class="o">&gt;</span> <span class="n">vb</span>         <span class="n">vmslt</span><span class="p">{</span><span class="n">u</span><span class="p">}</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">vm</span>    <span class="n">vmsgt</span><span class="p">{</span><span class="n">u</span><span class="p">}</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="n">vm</span>
<span class="n">va</span> <span class="o">&gt;=</span> <span class="n">vb</span>        <span class="n">vmsle</span><span class="p">{</span><span class="n">u</span><span class="p">}</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">vm</span>    <span class="n">vmsge</span><span class="p">{</span><span class="n">u</span><span class="p">}</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="n">vm</span>

<span class="n">va</span> <span class="o">&lt;</span> <span class="n">x</span>          <span class="n">vmslt</span><span class="p">{</span><span class="n">u</span><span class="p">}</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">vm</span>
<span class="n">va</span> <span class="o">&lt;=</span> <span class="n">x</span>         <span class="n">vmsle</span><span class="p">{</span><span class="n">u</span><span class="p">}</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">vm</span>
<span class="n">va</span> <span class="o">&gt;</span> <span class="n">x</span>          <span class="n">vmsgt</span><span class="p">{</span><span class="n">u</span><span class="p">}</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">vm</span>
<span class="n">va</span> <span class="o">&gt;=</span> <span class="n">x</span>         <span class="n">see</span> <span class="n">below</span>

<span class="n">va</span> <span class="o">&lt;</span> <span class="n">i</span>          <span class="n">vmsle</span><span class="p">{</span><span class="n">u</span><span class="p">}</span><span class="o">.</span><span class="n">vi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vm</span>    <span class="n">vmslt</span><span class="p">{</span><span class="n">u</span><span class="p">}</span><span class="o">.</span><span class="n">vi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">vm</span>
<span class="n">va</span> <span class="o">&lt;=</span> <span class="n">i</span>         <span class="n">vmsle</span><span class="p">{</span><span class="n">u</span><span class="p">}</span><span class="o">.</span><span class="n">vi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">vm</span>
<span class="n">va</span> <span class="o">&gt;</span> <span class="n">i</span>          <span class="n">vmsgt</span><span class="p">{</span><span class="n">u</span><span class="p">}</span><span class="o">.</span><span class="n">vi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">vm</span>
<span class="n">va</span> <span class="o">&gt;=</span> <span class="n">i</span>         <span class="n">vmsgt</span><span class="p">{</span><span class="n">u</span><span class="p">}</span><span class="o">.</span><span class="n">vi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vm</span>    <span class="n">vmsge</span><span class="p">{</span><span class="n">u</span><span class="p">}</span><span class="o">.</span><span class="n">vi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">vm</span>

<span class="n">va</span><span class="p">,</span> <span class="n">vb</span> <span class="n">ベクトルレジスタグループ</span>
<span class="n">x</span>      <span class="n">スカラ整数レジスタ</span>
<span class="n">i</span>      <span class="n">即値</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p><cite>vmsle.vi</cite> の範囲は -16 から 15 で、その結果、実効的な <cite>vmslt.vi</cite> の範囲は -15 から 16 となります。
<cite>vmsleu.vi</cite> の範囲は0から15で、実効的な <cite>vmsltu.vi</cite> の範囲は1から16になります (注意: 即値0の <cite>vmsltu.vi</cite> は常に偽なので役に立ちません)。
5ビットのベクトル即値は常に符号拡張されているので、<cite>vmsleu.vi</cite> は <cite>2^SEW^-16</cite> から <cite>2^SEW^-1</cite> の範囲の符号なし即値もサポートしており、
<cite>2^SEW^-15</cite> から <cite>2^SEW^</cite> の範囲の符号なし即値に対する <cite>vmsltu.vi</cite> の比較が可能です。
即値 <cite>2^SEW^</cite> の <cite>vlsltu.vi</cite> は常に真なので、有用ではないことに注意してください。</p>
</div>
<p>同様に、<cite>vmsge{u}.vi</cite> は提供されず、即値を1だけデクリメントした <cite>vmsgt{u}.vi</cite> を使用して比較を実装します。
その結果、実効的な <cite>vmsge.vi</cite> の範囲は-15～16、実効的な <cite>vmsgeu.vi</cite> の範囲は1～16となります(なお、即値が0の <cite>vmsgeu.vi</cite> は常に真なので役に立ちません)。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>1つの比較命令でマスク値の正しい極性を提供できるようにするために提供されています。</p>
</div>
<p>エンコーディング空間を減らすために、<cite>vmsge{u}.vx</cite> 形式は直接提供されていないので、<cite>va {ge} x</cite> の場合は特別な処理が必要です。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>しかし、OPIVIでスカラの <cite>x</cite> レジスタを使用する命令はこれらだけです。
別の方法として、さらに2つのfunct6エンコーディングを使用することもできますが、
これらは同じ8つのfunct6エンコーディングのグループの他のものとは異なるオペランドフォーマット(マスクレジスタへの書き込み)になります。
現在のPoRでは、これらの命令を省略し、必要に応じて以下のように合成しています。</p>
</div>
<p><cite>vmsge{u}.vx</cite> の演算は、 <cite>x</cite> の表現がアンダーフローしないことがわかっている場合、 <cite>x</cite> の値を1だけ減らして <cite>vmsgt{u}.vx</cite> 命令を使用することで合成できます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>`vmsge{u}.vx` 命令を合成するための命令列

va &gt;= x,  x &gt; minimum

   addi t0, x, -1; vmsgt{u}.vx vd, va, t0, vm
</pre></div>
</div>
<p>通常は上記の順序が最も効率的な実装になりますが、 <cite>x</cite> の範囲が不明な場合にはアセンブラの疑似命令を提供することができます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>マスク無し va &gt;= x

  疑似命令: vmsge{u}.vx vd, va, x
  展開: vmslt{u}.vx vd, va, x; vmnand.mm vd, vd, vd

マスク付き va &gt;= x, vd != v0

  疑似命令: vmsge{u}.vx vd, va, x, v0.t
  展開: vmslt{u}.vx vd, va, x, v0.t; vmxor.mm vd, vd, v0

マスク付き va &gt;= x, vd == v0

  疑似命令: vmsge{u}.vx vd, va, x, v0.t, vt
  展開: vmslt{u}.vx vt, va, x;  vmandnot.mm vd, vd, vt

マスク付き va &gt;= x, any vd

  疑似命令: vmsge{u}.vx vd, va, x, v0.t, vt
  展開: vmslt{u}.vx vt, va, x;  vmandnot.mm vt, v0, vt;  vmandnot.mm vd, vd, v0;  vmor.mm vd, vt, vd

  疑似命令中のvt引数は一時ベクトルレジスタの意味であり、
  vdとは異なり破壊される問題ないレジスタでなければならない
</pre></div>
</div>
<p>マスク付きundisturbedポリシによって複数の比較をANDする例を以下に示します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># (a &lt; b) &amp;&amp; (b &lt; c) をマスク付きundisturbedによって2命令で実現する</span>
<span class="n">vmslt</span><span class="o">.</span><span class="n">vv</span>    <span class="n">v0</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">vb</span>        <span class="c1"># 全ての要素に書き込みを行う</span>
<span class="n">vmslt</span><span class="o">.</span><span class="n">vv</span>    <span class="n">v0</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="n">vc</span><span class="p">,</span> <span class="n">v0</span><span class="o">.</span><span class="n">t</span>  <span class="c1"># マスクの設定された場所のみ書き込みを行う</span>
</pre></div>
</div>
<p>比較はマスクレジスタを書き込むため、常に末尾agnosticポリシで動作します。</p>
</div>
<div class="section" id="id72">
<h2>ベクトル整数最大/最小命令<a class="headerlink" href="#id72" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>符号付き整数/符号なし整数の最大・最小値計算命令がサポートされている。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 符号なし最小値</span>
<span class="n">vminu</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vminu</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-スカラ</span>

<span class="c1"># 符号付き最小値</span>
<span class="n">vmin</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vmin</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-スカラ</span>

<span class="c1"># 符号なし最大値</span>
<span class="n">vmaxu</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vmaxu</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-スカラ</span>

<span class="c1"># 符号付き最大値</span>
<span class="n">vmax</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vmax</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-スカラ</span>
</pre></div>
</div>
</div>
<div class="section" id="id73">
<h2>ベクトル単一幅整数乗算命令<a class="headerlink" href="#id73" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>単一幅の乗算命令は、SEWビット*SEWビットの乗算を行い、SEWビット幅の結果を返す。
<cite>*mulh*</cite> 版では、積の上位ワードを出力レジスタに書き込みます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 符号付き乗算、積の下位ビットを返す</span>
<span class="n">vmul</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># Vector-vector</span>
<span class="n">vmul</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vector-scalar</span>

<span class="c1"># 符号付き乗算、積の上位ビットを返す</span>
<span class="n">vmulh</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># Vector-vector</span>
<span class="n">vmulh</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vector-scalar</span>

<span class="c1"># 符号なし乗算、積の上位ビットを返す</span>
<span class="n">vmulhu</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># Vector-vector</span>
<span class="n">vmulhu</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vector-scalar</span>

<span class="c1"># vs2を符号付き、vs1を符号なしとした乗算、積の上位ビットを返す</span>
<span class="n">vmulhsu</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># Vector-vector</span>
<span class="n">vmulhsu</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vector-scalar</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>拡張機能としては、<cite>vmulh</cite>, <cite>vmulhu</cite>, <cite>vmulhsu</cite> のバリエーションが考えられ、積の下半分を破棄する際に <cite>vxrm</cite> 丸めモードを使用します。
これらのケースではオーバーフローの可能性はありません。</p>
</div>
</div>
<div class="section" id="id74">
<h2>ベクトル整数除算命令<a class="headerlink" href="#id74" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>除算・剰余命令は、RISC-V標準のスカラ整数乗除算と同等で、極端な入力に対しても同じ結果が得られます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 符号なし除算</span>
<span class="n">vdivu</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vdivu</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-スカラ</span>

<span class="c1"># 符号付除算</span>
<span class="n">vdiv</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vdiv</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-スカラ</span>

<span class="c1"># 符号なし剰余</span>
<span class="n">vremu</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vremu</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-スカラ</span>

<span class="c1"># 符号付剰余</span>
<span class="n">vrem</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vrem</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-スカラ</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>標準的な命令がない場合、ソフトウェアは演算を実行するために何らかのアルゴリズムを選択しなければならず、
マイクロアーキテクチャによってはパフォーマンスが低下する可能性があるというのが賛成の理由です。</p>
</div>
</div>
<div class="section" id="id75">
<h2>ベクトル幅拡張乗算命令<a class="headerlink" href="#id75" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>幅拡張整数乗算命令は、SEWビット*SEWビット乗算から完全な2*SEWビット積を返します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 幅拡張符号付き整数乗算</span>
<span class="n">vwmul</span><span class="o">.</span><span class="n">vv</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span> <span class="c1"># vector-vector</span>
<span class="n">vwmul</span><span class="o">.</span><span class="n">vx</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span> <span class="c1"># vector-scalar</span>

<span class="c1"># 幅拡張符号なし整数乗算</span>
<span class="n">vwmulu</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span> <span class="c1"># vector-vector</span>
<span class="n">vwmulu</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span> <span class="c1"># vector-scalar</span>

<span class="c1"># 幅拡張符号付き・符号なし整数乗算</span>
<span class="n">vwmulsu</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span> <span class="c1"># vector-vector</span>
<span class="n">vwmulsu</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span> <span class="c1"># vector-scalar</span>
</pre></div>
</div>
</div>
<div class="section" id="id76">
<h2>ベクトル単一幅整数乗算加算命令<a class="headerlink" href="#id76" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>整数の乗算加算命令は破壊的で、加算値や最小値を上書きするもの(<cite>vmacc</cite>、<cite>vnmsac</cite>)と、
最初の乗算値を上書きするもの(<cite>vmadd</cite>、<cite>vnmsub</cite>)の2種類が用意されています。</p>
<p>積の下位ビットの半分が第3オペランドに加算または減算されます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>オペコードは、(残念ながら直感に反する)浮動小数点の <cite>fnmsub</cite> 命令の定義に合わせて <cite>vnmsac</cite> となっています。
オペコードは <cite>vnmsub</cite> と似ています。</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 整数乗算加算命令、加算項上書き</span>
<span class="n">vmacc</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># vd[i] = +(vs1[i] * vs2[i]) + vd[i]</span>
<span class="n">vmacc</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># vd[i] = +(x[rs1] * vs2[i]) + vd[i]</span>

<span class="c1"># 整数乗算減算命令、減算項上書き</span>
<span class="n">vnmsac</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># vd[i] = -(vs1[i] * vs2[i]) + vd[i]</span>
<span class="n">vnmsac</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># vd[i] = -(x[rs1] * vs2[i]) + vd[i]</span>

<span class="c1"># 整数乗算加算命令、乗算項上書き</span>
<span class="n">vmadd</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># vd[i] = (vs1[i] * vd[i]) + vs2[i]</span>
<span class="n">vmadd</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># vd[i] = (x[rs1] * vd[i]) + vs2[i]</span>

<span class="c1"># 整数乗算減算命令、乗算項上書き</span>
<span class="n">vnmsub</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># vd[i] = -(vs1[i] * vd[i]) + vs2[i]</span>
<span class="n">vnmsub</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># vd[i] = -(x[rs1] * vd[i]) + vs2[i]</span>
</pre></div>
</div>
</div>
<div class="section" id="id77">
<h2>ベクトル幅拡張整数乗算加算命令<a class="headerlink" href="#id77" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>幅拡張整数乗算・加算命令は、SEWビット*SEWビットの乗算から2*SEWビットの値に2*SEWビットの乗算を加算し、
2*SEWビットの結果を生成します。
符号付きおよび符号なしの乗算オペランドのすべての組み合わせがサポートされています。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 幅拡張符号なし整数乗算加算命令、加算項上書き</span>
<span class="n">vwmaccu</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># vd[i] = +(vs1[i] * vs2[i]) + vd[i]</span>
<span class="n">vwmaccu</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># vd[i] = +(x[rs1] * vs2[i]) + vd[i]</span>

<span class="c1"># 幅拡張符号付き整数乗算加算命令、加算項上書き</span>
<span class="n">vwmacc</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># vd[i] = +(vs1[i] * vs2[i]) + vd[i]</span>
<span class="n">vwmacc</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># vd[i] = +(x[rs1] * vs2[i]) + vd[i]</span>

<span class="c1"># 幅拡張符号なし整数乗算加算命令、加算項上書き</span>
<span class="n">vwmaccsu</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vd[i] = +(signed(vs1[i]) * unsigned(vs2[i])) + vd[i]</span>
<span class="n">vwmaccsu</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vd[i] = +(signed(x[rs1]) * unsigned(vs2[i])) + vd[i]</span>

<span class="c1"># Widening unsigned-signed-integer multiply-add, overwrite addend</span>
<span class="c1"># 幅拡張符号なし・符号付き整数乗算加算命令、加算項上書き</span>
<span class="n">vwmaccus</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vd[i] = +(unsigned(x[rs1]) * signed(vs2[i])) + vd[i]</span>
</pre></div>
</div>
</div>
<div class="section" id="id78">
<h2>ベクトル整数マージ命令<a class="headerlink" href="#id78" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトル整数マージ命令は、2つのソースオペランドをマスクに基づいて結合します。
通常の算術命令とは異なり、マージはすべてのボディ要素(すなわち、 <cite>vstart</cite> から <cite>vl</cite> の現在のベクトル長までの要素の集合)に対して動作します。</p>
<p><cite>vmerge</cite> 命令は、マスクされた命令(<cite>vm=0</cite>)としてエンコードされます。
この命令は、次のように2つのソースを組み合わせます。
マスク値がゼロの要素では、第1オペランドが書き込み要素にコピーされ、そうでない場合は第2オペランドが書き込み要素にコピーされます。
第1オペランドは常に <cite>vs2</cite> で指定されるベクトルレジスタ群です。
第2オペランドは、 <cite>vs1</cite> で指定されるベクトルレジスタ群、
<cite>rs1</cite> で指定されるスカラ <cite>x</cite> レジスタ、または5ビットの符号拡張即値です。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vmerge</span><span class="o">.</span><span class="n">vvm</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">v0</span>  <span class="c1"># vd[i] = v0.mask[i] ? vs1[i] : vs2[i]</span>
<span class="n">vmerge</span><span class="o">.</span><span class="n">vxm</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">v0</span>  <span class="c1"># vd[i] = v0.mask[i] ? x[rs1] : vs2[i]</span>
<span class="n">vmerge</span><span class="o">.</span><span class="n">vim</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">imm</span><span class="p">,</span> <span class="n">v0</span>  <span class="c1"># vd[i] = v0.mask[i] ? imm    : vs2[i]</span>
</pre></div>
</div>
</div>
<div class="section" id="id79">
<h2>ベクトル整数移動命令<a class="headerlink" href="#id79" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトル整数移動命令は、ソース・オペランドをベクトル・レジスタ・グループにコピーします。
<cite>vmv.v.v</cite> はベクトルレジスタ群をコピーしますが、 <cite>vmv.v.x</cite> と <cite>vmv.v.i</cite> はスカラレジスタまたは即値をコピー先のベクトルレジスタ群のすべてのアクティブな要素に <a href="#id80"><span class="problematic" id="id81">**</span></a>転送**します。
これらの命令は、マスクされていない命令(<cite>vm=1</cite>)としてエンコードされます。
第1オペランド指定子(<cite>vs2</cite>)には、 <cite>v0</cite> が含まれていなければならず、 <cite>vs2</cite> に含まれるその他のベクトルレジスタ番号は <em>予約されています</em> 。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vmv</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">v</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs1</span> <span class="c1"># vd[i] = vs1[i]</span>
<span class="n">vmv</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span> <span class="c1"># vd[i] = x[rs1]</span>
<span class="n">vmv</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">i</span> <span class="n">vd</span><span class="p">,</span> <span class="n">imm</span> <span class="c1"># vd[i] = imm</span>
</pre></div>
</div>
<p>ベクトル整数移動命令は、ベクトルマージ命令とエンコーディングが同じですが、 <cite>vm=1</cite> 、 <cite>vs2=v0</cite> となっています。</p>
<p>ボディ要素を変更しない <cite>vmv.v.vd, vd</cite> という形式は、そのレジスタが次に SEW と等しい EEW で使用されることを示すヒントとして使用されます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>SEWに従って内部表現をシャッフルすることができます。
データを内部的に再編成しない実装では、この命令を動的に省略し、NOP として扱うことができます。</p>
</div>
</div>
</div>
<div class="section" id="sec-vector-fixed-point">
<span id="id82"></span><h1>ベクトル固定小数点算術演算命令<a class="headerlink" href="#sec-vector-fixed-point" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>前述の整数演算命令群を拡張し、固定小数点演算がサポートされています。</p>
<p>固定小数点数とは、暗黙の分母を持つ分数の分子として解釈される2の補数の符号付きまたは符号なしの整数です。
固定小数点命令は分子に適用されることを意図しており、分母を管理するのはソフトウェアの責任です。
Nビットの要素には、-2^N-1^...+2^N-1^-1の範囲の2の補数の符号付き整数と、0...+2^N-1^-1の範囲の符号なし整数を格納できます。
固定小数点命令は、スケーリングと丸めをサポートすることで狭いオペランドの精度を維持し、
結果を出力フォーマット範囲に飽和させることでオーバーフローを処理することができます。</p>
<div class="section" id="id83">
<h2>ベクトル単一幅飽和加算と飽和減算<a class="headerlink" href="#id83" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>符号付き整数と符号なし整数の両方に対して、飽和形式の整数の加算と減算が提供されます。
結果が出力先をオーバーフローする場合、結果は最も近い表現可能な値で置き換えられ、 <cite>vxsat</cite> ビットが設定されます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 符号なし整数の飽和加算</span>
<span class="n">vsaddu</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vsaddu</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-スカラ</span>
<span class="n">vsaddu</span><span class="o">.</span><span class="n">vi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">imm</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-即値</span>

<span class="c1"># 符号付き整数の飽和加算</span>
<span class="n">vsadd</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vsadd</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-スカラ</span>
<span class="n">vsadd</span><span class="o">.</span><span class="n">vi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">imm</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-即値</span>

<span class="c1"># 符号付き整数の飽和減算</span>
<span class="n">vssubu</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vssubu</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-スカラ</span>

<span class="c1"># 符号付き整数の飽和減算</span>
<span class="n">vssub</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vssub</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-スカラ</span>
</pre></div>
</div>
</div>
<div class="section" id="id84">
<h2>ベクトル単一幅平均加算と平均減算命令<a class="headerlink" href="#id84" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>平均化された加算・減算命令は、結果を1ビット右シフトし、 <cite>vxrm</cite> の設定に従って結果を丸める。
符号なしと符号ありのバージョンがあります。
<cite>vaaddu</cite> と <cite>vaadd</cite> では、結果にオーバーフローがあってはなりません。
<cite>vasub</cite> と <cite>vasubu</cite> では、オーバーフローは無視され、結果は折り返されます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 平均加算</span>

<span class="c1"># 符号なし整数の平均加算</span>
<span class="n">vaaddu</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># roundoff*unsigned(vs2[i] + vs1[i], 1)</span>
<span class="n">vaaddu</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># roundoff*unsigned(vs2[i] + x[rs1], 1)</span>

<span class="c1"># 符号付き整数の整数加算</span>
<span class="n">vaadd</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># roundoff*signed(vs2[i] + vs1[i], 1)</span>
<span class="n">vaadd</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># roundoff*signed(vs2[i] + x[rs1], 1)</span>

<span class="c1"># 平均減算</span>

<span class="c1"># 符号なし整数の平均減算</span>
<span class="n">vasubu</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># roundoff*unsigned(vs2[i] - vs1[i], 1)</span>
<span class="n">vasubu</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># roundoff*unsigned(vs2[i] - x[rs1], 1)</span>

<span class="c1"># 符号付き整数の平均減算</span>
<span class="n">vasub</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># roundoff*signed(vs2[i] - vs1[i], 1)</span>
<span class="n">vasub</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># roundoff*signed(vs2[i] - x[rs1], 1)</span>
</pre></div>
</div>
</div>
<div class="section" id="id85">
<h2>丸めと飽和を用いたベクトル単一幅分数乗算<a class="headerlink" href="#id85" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>符号付き分数乗算命令は、2つのSEW入力の2*SEW積を生成し、その結果をSEW-1ビットだけ右にシフトし、これらのビットを <cite>vxrm</cite> に従って丸めた後、SEWビットに収まるように結果を飽和させます。
結果が飽和した場合は、 <cite>vxsat</cite> ビットがセットされます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 符号付き飽和丸め分数乗算</span>
<span class="c1"># 丸め演算については、vxrmの説明を参照のこと</span>
<span class="n">vsmul</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vd[i] = clip(roundoff*signed(vs2[i]*vs1[i], SEW-1))</span>
<span class="n">vsmul</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vd[i] = clip(roundoff*signed(vs2[i]*x[rs1], SEW-1))</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>結果は+2^2N-2^となり、2Nビットで保持する場合、符号ビットは1つ(ゼロ)となります。
他のすべての製品は、2Nビットで2つの符号ビットを持ちます。
N個の結果ビットでより高い精度を維持するために、製品はNよりも1ビット少ない数だけ右にシフトされ、
最大の大きさの結果は飽和しますが、他のすべての製品では結果の精度が1ビット増加します。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>この操作は、丸めが単なる切り捨て(<cite>rdn</cite>)である場合には、 <cite>vmulhu</cite> および <cite>vmulhsu</cite> 命令によって部分的にカバーされます。</p>
</div>
<div class="section" id="id86">
<h3>ベクトル単一幅スケーリングシフト命令<a class="headerlink" href="#id86" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>これらの命令は、入力値を右にシフトし、シフトしたビットを <cite>vxrm</cite> に従って丸めます。
スケーリングの右シフトには、ゼロ拡張型 (<cite>vssrl</cite>) と符号拡張型 (<cite>vssra</cite>) があります。
ベクトルまたはスカラのシフト量の値の下位lg2(SEW)ビットが使用され、シフト量の即値はゼロ拡張されます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 論理スケーリング右シフト</span>
<span class="n">vssrl</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vd[i] = roundoff*unsigned(vs2[i], vs1[i])</span>
<span class="n">vssrl</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vd[i] = roundoff*unsigned(vs2[i], x[rs1])</span>
<span class="n">vssrl</span><span class="o">.</span><span class="n">vi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">uimm</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vd[i] = roundoff*unsigned(vs2[i], uimm)</span>

<span class="c1"># 算術スケーリング右シフト</span>
<span class="n">vssra</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vd[i] = roundoff*signed(vs2[i],vs1[i])</span>
<span class="n">vssra</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vd[i] = roundoff*signed(vs2[i], x[rs1])</span>
<span class="n">vssra</span><span class="o">.</span><span class="n">vi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">uimm</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vd[i] = roundoff*signed(vs2[i], uimm)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id87">
<h2>ベクトル固定小数点幅縮小クリップ命令<a class="headerlink" href="#id87" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><cite>vnclip</cite> 命令は、固定小数点の値をより狭い出力先に詰めるために使用されます。
この命令は、最終的な出力形式への丸め、スケーリング、および飽和をサポートします。</p>
<p>2番目の引数(ベクトル要素、スカラ値、即値)は、狭義のシフト命令のようにソースを右シフトする量を与え、スケーリングを行います。
ベクトルまたはスカラのシフト量の値の下位lg2(2*SEW)ビットが使用されます(例：SEW=64ビットからSEW=32ビットへの狭帯域化操作の場合は下位6ビット)。
即値形式は、シフト量の即値オペランドをゼロ拡張します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 符号なし幅縮小クリップ命令</span>
<span class="c1">#                                SEW                            2*SEW   SEW</span>
 <span class="n">vnclipu</span><span class="o">.</span><span class="n">wv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vd[i] = clip(roundoff*unsigned(vs2[i], vs1[i]))</span>
 <span class="n">vnclipu</span><span class="o">.</span><span class="n">wx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vd[i] = clip(roundoff*unsigned(vs2[i], x[rs1]))</span>
 <span class="n">vnclipu</span><span class="o">.</span><span class="n">wi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">uimm</span><span class="p">,</span> <span class="n">vm</span> <span class="c1"># vd[i] = clip(roundoff*unsigned(vs2[i], uimm))</span>

<span class="c1"># 符号付き幅縮小クリップ</span>
 <span class="n">vnclip</span><span class="o">.</span><span class="n">wv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vd[i] = clip(roundoff*signed(vs2[i], vs1[i]))</span>
 <span class="n">vnclip</span><span class="o">.</span><span class="n">wx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vd[i] = clip(roundoff*signed(vs2[i], x[rs1]))</span>
 <span class="n">vnclip</span><span class="o">.</span><span class="n">wi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">uimm</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># vd[i] = clip(roundoff*signed(vs2[i], uimm))</span>
</pre></div>
</div>
<p><cite>vnclipu</cite>/<cite>vnclip</cite> では、丸め方は <cite>vxrm</cite> CSR で指定します。
丸めは、書き込みレジスタの最下位ビットを中心に、飽和演算の前に行われます。</p>
<p><cite>vnclipu</cite> では、シフトされた丸められたソース値は符号なし整数として扱われ、
その結果が符号なし整数として見た書き込みレジスタをオーバーフローする場合は飽和します。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p><cite>vxsat</cite> の値を設定する必要がない場合は、まず <cite>vmax</cite> を使って0に対する最大値を実行して負の数を取り除き、
次に <cite>vnclipu</cite> を使って結果の符号なしの値を出力先にクリップする、2つのベクトル命令列を使用できます。
SEWを変更するには、この2つの命令の間に、 <cite>vsetvli</cite> が必要です。</p>
</div>
<p><cite>vnclip</cite> では、丸められたシフト元の値を符号付き整数として扱い、その結果が符号付き整数として見たときに
書き込みレジスタをオーバーフローさせるようであれば飽和を行います。</p>
<p>いずれかの書き込みレジスタの要素が飽和した場合、 <cite>vxsat</cite> レジスタに <cite>vxsat</cite> ビットが設定されます。</p>
</div>
</div>
<div class="section" id="sec-vector-float">
<span id="id88"></span><h1>ベクトル浮動小数点命令<a class="headerlink" href="#sec-vector-float" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>標準のベクトル浮動小数点命令では、16ビット、32ビット、64ビット、128ビットの要素をIEEE-754/2008互換の値として扱います。
ベクトル浮動小数点演算子のEEWが、サポートされているIEEE浮動小数点型に対応していない場合、
その命令のエンコーディングは予約されています。</p>
<p>ベクトル浮動小数点命令では、サポートされているベクトル浮動小数点の要素幅に対応する
スカラ浮動小数点拡張が有効であることが必要です。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p><cite>f</cite> レジスタでのスカラ半精度浮動小数点サポートも実装する必要があります。</p>
</div>
<p>浮動小数点ユニット状態フィールド <cite>mstatus.FS</cite> が <cite>Off</cite> の場合、
ベクトル浮動小数点命令を実行しようとすると、不正な命令例外が発生します。
浮動小数点拡張状態(浮動小数点CSRや <cite>f</cite> レジスタなど)を変更するベクトル浮動小数点命令は、
<cite>mstatus.FS</cite> を <cite>Dirty</cite> に設定しなければなりません。</p>
<p>ベクトル浮動小数点命令は、NaNに関してはスカラ浮動小数点命令と同じ動作をします。</p>
<p>ベクトルスカラ演算のスカラ値は、 <a class="reference internal" href="#sec-arithmetic-encoding"><span class="std std-ref">ベクトル算術演算命令エンコーディング</span></a>  で説明したように、
標準的なスカラ <cite>f</cite> レジスタから供給することができます。</p>
<div class="section" id="id89">
<h2>ベクトル浮動小数点例外フラグ<a class="headerlink" href="#id89" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>アクティブな浮動小数点要素でのベクトル浮動小数点例外は、 <cite>fflags</cite> レジスタの標準FP例外フラグを設定します。
非アクティブな要素はFP例外フラグを設定しません。</p>
</div>
<div class="section" id="id90">
<h2>ベクトル単一幅浮動小数点加減算命令<a class="headerlink" href="#id90" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 浮動小数点加算</span>
<span class="n">vfadd</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vfadd</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-スカラ</span>

<span class="c1"># 浮動小数点減算</span>
<span class="n">vfsub</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vfsub</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-スカラ vd[i] = vs2[i] - f[rs1]</span>
<span class="n">vfrsub</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># スカラ-ベクトル vd[i] = f[rs1] - vs2[i]</span>
</pre></div>
</div>
</div>
<div class="section" id="id91">
<h2>ベクトル幅拡張浮動小数点加減算命令<a class="headerlink" href="#id91" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 浮動小数点幅拡張加減算命令, 2*SEW = SEW +/- SEW</span>
<span class="n">vfwadd</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vfwadd</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-スカラ</span>
<span class="n">vfwsub</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vfwsub</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-スカラ</span>

<span class="c1"># 浮動小数点幅拡張加減算命令, 2*SEW = 2*SEW +/- SEW</span>
<span class="n">vfwadd</span><span class="o">.</span><span class="n">wv</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vfwadd</span><span class="o">.</span><span class="n">wf</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-スカラ</span>
<span class="n">vfwsub</span><span class="o">.</span><span class="n">wv</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vfwsub</span><span class="o">.</span><span class="n">wf</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-スカラ</span>
</pre></div>
</div>
</div>
<div class="section" id="id92">
<h2>ベクトル単一幅浮動小数点乗算除算命令<a class="headerlink" href="#id92" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 浮動小数点乗算</span>
<span class="n">vfmul</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vfmul</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-スカラ</span>

<span class="c1"># 浮動小数点除算</span>
<span class="n">vfdiv</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vfdiv</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-スカラ</span>

<span class="c1"># 浮動小数点逆除算 ベクトル = スカラ / ベクトル</span>
<span class="n">vfrdiv</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># scalar-vector, vd[i] = f[rs1]/vs2[i]</span>
</pre></div>
</div>
</div>
<div class="section" id="id93">
<h2>ベクトル幅拡張浮動小数点乗算命令<a class="headerlink" href="#id93" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 幅拡張浮動小数点乗算</span>
<span class="n">vfwmul</span><span class="o">.</span><span class="n">vv</span>    <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span> <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vfwmul</span><span class="o">.</span><span class="n">vf</span>    <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span> <span class="c1"># ベクトル-スカラ</span>
</pre></div>
</div>
</div>
<div class="section" id="id94">
<h2>ベクトル単一幅浮動小数点複合乗算加算命令<a class="headerlink" href="#id94" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>複合乗算加算の4種類すべてが提供されており、加算値または最初の乗算値のいずれかのオペランドを上書きする2つの破壊的な形式があります。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># FP multiply-accumulate, overwrites addend</span>
<span class="n">vfmacc</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># vd[i] = +(vs1[i] * vs2[i]) + vd[i]</span>
<span class="n">vfmacc</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># vd[i] = +(f[rs1] * vs2[i]) + vd[i]</span>

<span class="c1"># FP negate-(multiply-accumulate), overwrites subtrahend</span>
<span class="n">vfnmacc</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vd[i] = -(vs1[i] * vs2[i]) - vd[i]</span>
<span class="n">vfnmacc</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vd[i] = -(f[rs1] * vs2[i]) - vd[i]</span>

<span class="c1"># FP multiply-subtract-accumulator, overwrites subtrahend</span>
<span class="n">vfmsac</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># vd[i] = +(vs1[i] * vs2[i]) - vd[i]</span>
<span class="n">vfmsac</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># vd[i] = +(f[rs1] * vs2[i]) - vd[i]</span>

<span class="c1"># FP negate-(multiply-subtract-accumulator), overwrites minuend</span>
<span class="n">vfnmsac</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vd[i] = -(vs1[i] * vs2[i]) + vd[i]</span>
<span class="n">vfnmsac</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vd[i] = -(f[rs1] * vs2[i]) + vd[i]</span>

<span class="c1"># FP multiply-add, overwrites multiplicand</span>
<span class="n">vfmadd</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># vd[i] = +(vs1[i] * vd[i]) + vs2[i]</span>
<span class="n">vfmadd</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># vd[i] = +(f[rs1] * vd[i]) + vs2[i]</span>

<span class="c1"># FP negate-(multiply-add), overwrites multiplicand</span>
<span class="n">vfnmadd</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vd[i] = -(vs1[i] * vd[i]) - vs2[i]</span>
<span class="n">vfnmadd</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vd[i] = -(f[rs1] * vd[i]) - vs2[i]</span>

<span class="c1"># FP multiply-sub, overwrites multiplicand</span>
<span class="n">vfmsub</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># vd[i] = +(vs1[i] * vd[i]) - vs2[i]</span>
<span class="n">vfmsub</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># vd[i] = +(f[rs1] * vd[i]) - vs2[i]</span>

<span class="c1"># FP negate-(multiply-sub), overwrites multiplicand</span>
<span class="n">vfnmsub</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vd[i] = -(vs1[i] * vd[i]) + vs2[i]</span>
<span class="n">vfnmsub</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vd[i] = -(f[rs1] * vd[i]) + vs2[i]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>いくつかの非破壊的なFMAを提供することは可能でしょう。
しかし、これは3つの入力と別々の出力を持つ唯一のマスク可能な演算となります。</p>
</div>
</div>
<div class="section" id="id95">
<h2>ベクトル幅拡張浮動小数点複合乗算加算命令<a class="headerlink" href="#id95" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>幅拡張された浮動小数点複合乗算加算命令は、すべて幅拡張された加算先を結果で上書きします。
乗算器の入力はすべてSEW幅で、加算器と出力は2*SEWビット幅です。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># FP widening multiply-accumulate, overwrites addend</span>
<span class="n">vfwmacc</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># vd[i] = +(vs1[i] * vs2[i]) + vd[i]</span>
<span class="n">vfwmacc</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># vd[i] = +(f[rs1] * vs2[i]) + vd[i]</span>

<span class="c1"># FP widening negate-(multiply-accumulate), overwrites addend</span>
<span class="n">vfwnmacc</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vd[i] = -(vs1[i] * vs2[i]) - vd[i]</span>
<span class="n">vfwnmacc</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vd[i] = -(f[rs1] * vs2[i]) - vd[i]</span>

<span class="c1"># FP widening multiply-subtract-accumulator, overwrites addend</span>
<span class="n">vfwmsac</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># vd[i] = +(vs1[i] * vs2[i]) - vd[i]</span>
<span class="n">vfwmsac</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># vd[i] = +(f[rs1] * vs2[i]) - vd[i]</span>

<span class="c1"># FP widening negate-(multiply-subtract-accumulator), overwrites addend</span>
<span class="n">vfwnmsac</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vd[i] = -(vs1[i] * vs2[i]) + vd[i]</span>
<span class="n">vfwnmsac</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vd[i] = -(f[rs1] * vs2[i]) + vd[i]</span>
</pre></div>
</div>
</div>
<div class="section" id="id96">
<h2>ベクトル浮動小数点平方根命令<a class="headerlink" href="#id96" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>これは単精度ベクトル-ベクトル命令です。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 浮動小数点平方根命令</span>
<span class="n">vfsqrt</span><span class="o">.</span><span class="n">v</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-ベクトル 平方根</span>
</pre></div>
</div>
</div>
<div class="section" id="id97">
<h2>ベクトル浮動小数点逆平方根推定命令<a class="headerlink" href="#id97" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 7ビットの浮動小数点逆平方根推定命令</span>
<span class="n">vfrsqrt7</span><span class="o">.</span><span class="n">v</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>
</pre></div>
</div>
<p>これは、7ビットの精度で1/sqrt(x)の推定値を返す、単項のベクトル-ベクトル命令です。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>後方互換性のために、ツールチェインのエイリアスとして以前の名前を残すことができます。</p>
</div>
<p>次の表は、すべてのクラスの浮動小数点入力に対するこの命令の動作を示しています。</p>
<p>例外的なケースでは、指数の下位ビットと合数の上位6ビット(先頭の1ビットの後)が連結され、以下のテーブルのアドレスに使用されます。
このテーブルの出力は、結果として得られる信号の上位7ビット(先頭の1ビットの後)となり、結果として得られる信号の残りの部分はゼロとなります。
正常でない入力は、ルックアップの前に正規化され、指数が適切に調整されます。
出力の指数は、結果が引数の平方根の逆数に近似するように選択されます。</p>
<p>より正確には、結果は以下のように計算されます。
正規化された入力指数を、入力が正常な場合は入力指数と等しく、そうでない場合は0から符号の先頭のゼロの数を引いた値とします。
入力が非正規の場合、正規化された入力指数は、先頭の1ビットを捨てて、入力指数を1から正規化された入力指数を引いて左にシフトすることで与えられます。
出力指数は floor((3*B - 1 - 正規化された入力指数) / 2) に等しくなります。
出力符号は入力符号に等しくなります。</p>
<p>次の表は、正規化された入力指数のLSBと正規化された入力記号の6つのMSBの関数として、出力記号の7つのMSBを示したもので、出力記号の他のビットはゼロです。</p>
<p>include::vfrsqrt7.adoc[]</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>および vfrsqrt7(0x7f765432 ({approx} 3.274e38)) = 0x1f820000 ({approx} 5.506e-20)となります。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>将来的には、より高い推定精度の命令を定義することができます。</p>
</div>
</div>
<div class="section" id="id98">
<h2>ベクトル浮動小数点逆数推定命令<a class="headerlink" href="#id98" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 7ビットの浮動小数点逆数推定命令</span>
<span class="n">vfrec7</span><span class="o">.</span><span class="n">v</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>要素の幅を表す <a href="#id99"><span class="problematic" id="id100">``</span></a>e``**x** 記法との混同を招くと判断されました。
以前の名前は後方互換性のためにツールチェインのエイリアスとして保持することができます。</p>
</div>
<p>これは単項のベクトル・ベクトル命令で、7ビットの精度で1/xの推定値を返します。</p>
<p>次の表は、すべてのクラスの浮動小数点入力に対するこの命令の動作を示しています(<a href="#id101"><span class="problematic" id="id102">*</span></a>B*は指数バイアスです)。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>少なくとも2^B-1^の大きさを持つ通常の入力は、サブノーマルの出力を生成し、他の通常の入力は通常の出力を生成します。</p>
</div>
<p>例外が発生しないケースでは、上位7ビットの仮数部(先頭の1ビットの後)が次の表のアドレスに使用されます。
このテーブルの出力は、結果として得られる信号の上位7ビット(先頭の1ビットの後)となり、結果として得られる信号の残りの部分はゼロとなります。
正常でない入力は、ルックアップの前に正規化され、指数が適切に調整されます。
出力の指数は、結果が引数の逆数に近似するように選択され、サブノーマル出力はそれに応じて非正規化されます。</p>
<p>より正確には、結果は以下のように計算されます。
正規化された入力指数を、入力が正常な場合は入力指数と等しく、そうでない場合は0から符号の先頭のゼロの数を引いたものとします。
正規化された出力指数は、(2*B - 1 - 正規化された入力指数)に等しくなります。
正規化された出力指数が[-1, 2*B]の範囲外である場合、その結果は上の表の例外的なケースの1つに対応します。</p>
<p>入力が非正規の場合、正規化された入力多項式は、入力多項式を1から正規化された入力指数を引いて左にシフトし、先頭の1ビットを捨てて与えられます。
それ以外の場合は、正規化された入力信号は入力信号と同じです。
次の表は、正規化された入力信号の7つのMSBの関数として、正規化された出力信号の7つのMSBを示したもので、正規化された出力信号の他のビットはゼロです。</p>
<p>include::vfrec7.adoc[]</p>
<p>正規化された出力指数が0または-1の場合、結果はサブノーマル数となります。
出力指数は0で、出力の仮数部は正規化された出力仮数部の左にある1ビットを連結し、
その量を正規化された出力指数から1を引いて右にシフトしたものになります。
それ以外の場合は、出力指数は正規化された出力指数に等しく、出力合言葉は正規化された出力仮数部に等しくなります。
出力符号は入力符号に等しくなります。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>およびvfrec7(0x7f765432 ({approx} 3.274e38)) = 0x00214000 ({approx} 3.053e-39)となります。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>将来的には、より高い推定精度の命令を定義することができます。</p>
</div>
</div>
<div class="section" id="min-max">
<h2>ベクトル浮動小数点MIN/MAX命令<a class="headerlink" href="#min-max" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトル浮動小数点 <cite>vfmin</cite> および <cite>vfmax</cite> 命令は、RISC-V F/D/Q 拡張のバージョン 2.2 における対応するスカラ浮動小数点命令と同じ動作をします。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 浮動小数点最小値</span>
<span class="n">vfmin</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vfmin</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-スカラ</span>

<span class="c1"># 浮動小数点最大値</span>
<span class="n">vfmax</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vfmax</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-スカラ</span>
</pre></div>
</div>
</div>
<div class="section" id="id103">
<h2>ベクトル浮動小数点符号挿入命令<a class="headerlink" href="#id103" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>スカラの符号挿入命令のベクトル版です。
結果は符号ビットを除くすべてのビットを、ベクトルの <cite>vs2</cite>  オペランドから取得します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vfsgnj</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vfsgnj</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-スカラ</span>

<span class="n">vfsgnjn</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vfsgnjn</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-スカラ</span>

<span class="n">vfsgnjx</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vfsgnjx</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-スカラ</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>アセンブリ疑似命令 <cite>vfneg.vd,vs</cite> = <cite>vfsgnjn.vv vd,vs,vs</cite> を定義することができます。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>アセンブリ疑似命令 <cite>vfabs.vd,vs</cite> = <cite>vfsgnjx.vv vd,vs,vs</cite> を定義できます。</p>
</div>
</div>
<div class="section" id="id104">
<h2>ベクトル浮動小数点比較命令<a class="headerlink" href="#id104" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>これらのベクトルFP比較命令は、2つのソースオペランドを比較し、比較結果をマスクレジスタに書き込みます。
書き込みマスクベクトルは常に単一のベクトルレジスタに保持され、その要素のレイアウトは <a class="reference internal" href="#sec-mask-register-layout"><span class="std std-ref">マスクレジスタのレイアウト</span></a>  節で説明されています。
書き込みマスクレジスタはソースベクトルマスクレジスタ(<cite>v0</cite>)と同じであってもかまいません。
比較はマスクレジスタを書き込むため、常にTail-agnosticポリシで動作します。</p>
<p>比較命令は、スカラ浮動小数点比較命令の文法に従います。
<cite>vmfeq</cite> と <cite>vmfne</cite> は NaN 入力の信号に対してのみ無効な操作という例外を発生させます。
<cite>vmflt</cite>、 <cite>vmfle</cite>、 <cite>vmfgt</cite>、 <cite>vmfge</cite> は、シグナリング NaN 入力とサイレント NaN 入力の両方で無効な操作に関する例外を発生させます。
<cite>vmfne</cite> は、どちらかのオペランドが NaN のときに出力要素に 1 を書き込みますが、
他の比較ではどちらかのオペランドが NaN のときに 0 を書き込みます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 等価比較</span>
<span class="n">vmfeq</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vmfeq</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-スカラ</span>

<span class="c1"># 非等価比較</span>
<span class="n">vmfne</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vmfne</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-スカラ</span>

<span class="c1"># 小なり比較</span>
<span class="n">vmflt</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vmflt</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-スカラ</span>

<span class="c1"># 以下比較</span>
<span class="n">vmfle</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-ベクトル</span>
<span class="n">vmfle</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-スカラ</span>

<span class="c1"># 大なり比較</span>
<span class="n">vmfgt</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-スカラ</span>

<span class="c1"># 以上比較</span>
<span class="n">vmfge</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># ベクトル-スカラ</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">比較</span>            <span class="n">アセンブリ言語マッピング</span>   <span class="n">アセンブリ言語疑似命令</span>

<span class="n">va</span> <span class="o">&lt;</span> <span class="n">vb</span>         <span class="n">vmflt</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="n">vm</span>
<span class="n">va</span> <span class="o">&lt;=</span> <span class="n">vb</span>        <span class="n">vmfle</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="n">vm</span>
<span class="n">va</span> <span class="o">&gt;</span> <span class="n">vb</span>         <span class="n">vmflt</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">vm</span>    <span class="n">vmfgt</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="n">vm</span>
<span class="n">va</span> <span class="o">&gt;=</span> <span class="n">vb</span>        <span class="n">vmfle</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">vm</span>    <span class="n">vmfge</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="n">vm</span>

<span class="n">va</span> <span class="o">&lt;</span> <span class="n">f</span>          <span class="n">vmflt</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">vm</span>
<span class="n">va</span> <span class="o">&lt;=</span> <span class="n">f</span>         <span class="n">vmfle</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">vm</span>
<span class="n">va</span> <span class="o">&gt;</span> <span class="n">f</span>          <span class="n">vmfgt</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">vm</span>
<span class="n">va</span> <span class="o">&gt;=</span> <span class="n">f</span>         <span class="n">vmfge</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">vm</span>

<span class="n">va</span><span class="p">,</span> <span class="n">vb</span> <span class="n">ベクトルレジスタグループ</span>
<span class="n">f</span>      <span class="n">スカラ浮動小数点レジスタ</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>比較対象が非 NaN 定数の場合は、中間の2つの命令を省略できます。</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># isgreater() の実装例</span>
<span class="n">vmfeq</span><span class="o">.</span><span class="n">vv</span> <span class="n">v0</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">va</span>        <span class="c1"># AがNaNでない場合にのみセットされる</span>
<span class="n">vmfeq</span><span class="o">.</span><span class="n">vv</span> <span class="n">v1</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="n">vb</span>        <span class="c1"># BがNaNでない場合にのみセットされる</span>
<span class="n">vmand</span><span class="o">.</span><span class="n">mm</span> <span class="n">v0</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">v1</span>        <span class="c1"># AとBに順序関係があるときのみセットされる</span>
<span class="n">vmfgt</span><span class="o">.</span><span class="n">vv</span> <span class="n">v0</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="n">v0</span><span class="o">.</span><span class="n">t</span>  <span class="c1">#  従って、順序関係がある値の場合にのみフラグが設定される</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>より効率的なシーケンスでは、<cite>va</cite> の要素に quiet NaN が含まれ、<cite>vb</cite> の対応する要素に signaling NaN が含まれている場合に、
不正な例外を発生させることができません。</p>
</div>
</div>
<div class="section" id="id105">
<h2>ベクトル浮動小数点分類命令<a class="headerlink" href="#id105" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>スカラ分類命令と同様に動作する単項のベクトル-ベクトル命令です。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vfclass</span><span class="o">.</span><span class="n">v</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># ベクトル-ベクトル</span>
</pre></div>
</div>
<p>この命令で生成された10ビットのマスクは、結果要素の最下位ビットに配置されます。
結果の上位(SEW-10)ビットには0が入ります。
この命令はSEW=16b以上でのみ定義されているため、結果は常に書き込み要素に収まります。</p>
</div>
<div class="section" id="id106">
<h2>ベクトル浮動小数点マージ命令<a class="headerlink" href="#id106" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトルスカラ浮動小数点マージ命令が提供されています。
この命令は、マスク値に関係なく、<cite>vstart</cite> から <cite>vl</cite>  の現在のベクトル長までのすべてのボディ要素で動作します。</p>
<p><cite>vfmerge.vfm</cite> 命令は、マスクされた命令 (<cite>vm=0</cite>) としてエンコードされます。
マスク値がゼロの要素では、最初のベクトルオペランドが書き込み要素にコピーされ、そうでない場合は、スカラ浮動小数点レジスタ値が書き込み要素にコピーされます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vfmerge</span><span class="o">.</span><span class="n">vfm</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">v0</span>  <span class="c1"># vd[i] = v0.mask[i] ? f[rs1] : vs2[i]</span>
</pre></div>
</div>
</div>
<div class="section" id="id107">
<h2>ベクトル浮動小数点移動命令<a class="headerlink" href="#id107" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトル浮動小数点移動命令は、浮動小数点のスカラオペランドをベクトルレジスタグループに <strong>転送</strong> します。
この命令は、スカラ <cite>f</cite> レジスタ値をベクトルレジスタグループのすべてのアクティブな要素にコピーします。
この命令はマスクされた命令(<cite>vm=1</cite>)としてエンコードされます。
この命令は、<cite>vs2</cite> フィールドが <cite>v0</cite> に設定されていなければならず、<cite>vs2</cite> の他の値はすべて予約されています。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vfmv</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">f</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span>  <span class="c1"># vd[i] = f[rs1]</span>
</pre></div>
</div>
</div>
<div class="section" id="id108">
<h2>単一幅浮動所数点/整数型変換命令<a class="headerlink" href="#id108" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>浮動小数点値、符号なし整数、符号あり整数との間の変換操作が用意されており、変換元と変換先の両方がSEW幅である。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vfcvt</span><span class="o">.</span><span class="n">xu</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">v</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>       <span class="c1"># 浮動小数点から符号なし整数への変換.</span>
<span class="n">vfcvt</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">v</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>       <span class="c1"># 浮動小数点から符号付き整数への変換.</span>

<span class="n">vfcvt</span><span class="o">.</span><span class="n">rtz</span><span class="o">.</span><span class="n">xu</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">v</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># 浮動小数点からtruncateを使用した符号なし整数への変換.</span>
<span class="n">vfcvt</span><span class="o">.</span><span class="n">rtz</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">v</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># 浮動小数点からtruncateを使用した符号付き整数への変換.</span>

<span class="n">vfcvt</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">xu</span><span class="o">.</span><span class="n">v</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>       <span class="c1"># 符号なし整数から浮動小数点への変換.</span>
<span class="n">vfcvt</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">v</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>       <span class="c1"># 符号付き整数から浮動小数点への変換.</span>
</pre></div>
</div>
<p>変換命令は、スカラ変換命令と同じ例外的な条件に関するルールに従います。
これらの変換は、ゼロに向かって丸める <cite>rtz</cite>  の変種を除いて、<cite>frm</cite> の動的丸めモードを使用します。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>浮動小数点から整数への切り捨て変換を高速化するために提供されています。</p>
</div>
</div>
<div class="section" id="id109">
<h2>幅拡張浮動小数点/整数型変換命令<a class="headerlink" href="#id109" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>より小さな整数型や浮動小数点型のデータタイプを2倍の幅の型に変換する変換命令群が用意されています。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vfwcvt</span><span class="o">.</span><span class="n">xu</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">v</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>       <span class="c1"># 浮動小数点を倍幅の符号なし整数に変換.</span>
<span class="n">vfwcvt</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">v</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>       <span class="c1"># 浮動小数点を倍幅の符号付き整数に変換.</span>

<span class="n">vfwcvt</span><span class="o">.</span><span class="n">rtz</span><span class="o">.</span><span class="n">xu</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">v</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># 浮動小数点をtruncateを使用した倍幅の符号なし整数に変換.</span>
<span class="n">vfwcvt</span><span class="o">.</span><span class="n">rtz</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">v</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># 浮動小数点をtruncateを使用した倍幅の符号付き整数に変換.</span>

<span class="n">vfwcvt</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">xu</span><span class="o">.</span><span class="n">v</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>       <span class="c1"># 符号なし整数を倍幅の浮動小数点に変換.</span>
<span class="n">vfwcvt</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">v</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>       <span class="c1"># 符号付き整数を倍幅の浮動小数点に変換.</span>

<span class="n">vfwcvt</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">v</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>        <span class="c1"># 単一幅浮動小数点を倍幅の浮動小数点に変換.</span>
</pre></div>
</div>
<p>これらの命令は、他の幅拡張命令(<a class="reference internal" href="#sec-widening"><span class="std std-ref">幅拡張ベクトル算術演算命令</span></a> 参照)と同様に、ベクトルレジスタのオーバーラップに対する制約があります。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>同等の結果と追加の例外フラグを発生させずに、いくつかの倍のステップとして実装することができます。</p>
</div>
</div>
<div class="section" id="id110">
<h2>浮動小数点/整数 幅縮小型変換命令<a class="headerlink" href="#id110" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vfncvt</span><span class="o">.</span><span class="n">xu</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">w</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>       <span class="c1"># 倍幅の浮動小数点を符号付き整数に変換.</span>
<span class="n">vfncvt</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">w</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>       <span class="c1"># 倍幅の浮動小数点を符号なし整数に変換.</span>

<span class="n">vfncvt</span><span class="o">.</span><span class="n">rtz</span><span class="o">.</span><span class="n">xu</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">w</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># 倍幅の浮動小数点をtruncateを使用した符号なし整数に変換.</span>
<span class="n">vfncvt</span><span class="o">.</span><span class="n">rtz</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">w</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># 倍幅の浮動小数点をtruncateを使用した符号付き整数に変換.</span>

<span class="n">vfncvt</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">xu</span><span class="o">.</span><span class="n">w</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>       <span class="c1"># 倍幅の符号なし整数を浮動小数点に変換.</span>
<span class="n">vfncvt</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">w</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>       <span class="c1"># 倍幅の符号付き整数を浮動小数点に変換.</span>

<span class="n">vfncvt</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">w</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>        <span class="c1"># 倍幅浮動小数点を単一幅の浮動小数点に変換.</span>
<span class="n">vfncvt</span><span class="o">.</span><span class="n">rod</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">w</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>    <span class="c1"># 倍幅浮動小数点をodd方向の丸めに使用して単一幅の浮動小数点に変換.</span>
</pre></div>
</div>
<p>これらの命令は、他の幅縮小命令(<a class="reference internal" href="#sec-narrowing"><span class="std std-ref">ベクトル幅縮小算術演算命令</span></a> 参照)と同様に、ベクトルレジスタのオーバーラップに制約があります。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>変換は半減ステップのシーケンスで実装できます。
最後の半減ステップ以外が round-towards-odd (<cite>vfncvt.rod.f.f.w</cite>) を使用した場合、結果は同等に丸められ、同じ例外フラグが立てられます。
最後のステップだけは、希望する丸め方向を使用する必要があります。</p>
</div>
</div>
</div>
<div class="section" id="id111">
<h1>ベクトルリダクション操作<a class="headerlink" href="#id111" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>ベクトルリダクションは、ベクトルレジスタ群の要素と、ベクトルレジスタの要素0に保持されているスカラを受け取り、
何らかの二項演算子を用いてリダクションを行い、ベクトルレジスタの要素0にスカラの結果を出力するものです。
スカラの入出力オペランドは、ベクトルレジスタ群ではなく、単一のベクトルレジスタの要素0に保持されるため、LMULの設定に関わらず、
どのベクトルレジスタもベクトルリダクションのスカラのソースまたは書き込みレジスタとなります。</p>
<p>書き込みのベクトルレジスタは、マスクレジスタを含むソースオペランドとオーバーラップすることができます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>スカラユニットでサポートされていない将来の型で将来のポリモーフィックな使用をサポートするために、
スカラオペランドと結果をベクトルレジスタの要素0に読み書きします。</p>
</div>
<p>ソースベクトルレジスタグループの非アクティブな要素はリダクションから除外されますが、
スカラオペランドはマスク値にかかわらず常に含まれます。</p>
<p>書き込みベクトルレジスタ内の他の要素(0 &lt; index &lt; VLEN/SEW)は末尾とみなされ、
現在のtail agnostic/undisturbedポリシで管理されます。</p>
<p><a href="#id112"><span class="problematic" id="id113">`</span></a>vl`=0の場合は、操作は行われず、書き込みレジスタは更新されません。</p>
<p>ベクトルリダクション命令の例外は、常に <cite>vstart</cite> が0で報告されます。
ベクトルリダクション操作は、<cite>vstart</cite> が 0 でない場合、不正な命令の例外を発生させます。</p>
<p>縮小演算のアセンブラ構文は、<cite>vredop.vs</cite> です。<cite>.vs</cite> は、第1オペランドがベクトルレジスタグループで、
第 2 オペランドがベクトルレジスタの要素 0 に格納されたスカラであることを表します。</p>
<div class="section" id="sec-vector-integer-reduce">
<span id="id114"></span><h2>ベクトル単一幅整数リダクション命令<a class="headerlink" href="#sec-vector-integer-reduce" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>単一幅のリダクション命令のオペランドと結果は、すべて同じSEW幅になります。
算術加算ではオーバーフローは丸められます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="c1"># 単純なリダクション命令. [*]は全てのアクティブな要素を意味する:</span>
<span class="n">vredsum</span><span class="o">.</span><span class="n">vs</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vd[0] =  sum( vs1[0] , vs2[*] )</span>
<span class="n">vredmaxu</span><span class="o">.</span><span class="n">vs</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vd[0] = maxu( vs1[0] , vs2[*] )</span>
<span class="n">vredmax</span><span class="o">.</span><span class="n">vs</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vd[0] =  max( vs1[0] , vs2[*] )</span>
<span class="n">vredminu</span><span class="o">.</span><span class="n">vs</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vd[0] = minu( vs1[0] , vs2[*] )</span>
<span class="n">vredmin</span><span class="o">.</span><span class="n">vs</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vd[0] =  min( vs1[0] , vs2[*] )</span>
<span class="n">vredand</span><span class="o">.</span><span class="n">vs</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vd[0] =  and( vs1[0] , vs2[*] )</span>
<span class="n">vredor</span><span class="o">.</span><span class="n">vs</span>   <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vd[0] =   or( vs1[0] , vs2[*] )</span>
<span class="n">vredxor</span><span class="o">.</span><span class="n">vs</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># vd[0] =  xor( vs1[0] , vs2[*] )</span>
</pre></div>
</div>
</div>
<div class="section" id="sec-vector-integer-reduce-widen">
<span id="id115"></span><h2>ベクトル幅拡張整数リダクション命令<a class="headerlink" href="#sec-vector-integer-reduce-widen" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>符号なしの <cite>vwredsumu.vs</cite> 命令は、SEW幅のベクトル要素をゼロ拡張してから合計し、
次に2*SEW幅のスカラー要素を加え、その結果を2*SEW幅のスカラー要素に格納します。</p>
<p><cite>vwredsum.vs</cite> 命令は、SEW幅のベクトル要素を符号拡張してから加算します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="c1"># 2倍幅での符号なしリダクション加算を倍幅でアキュムレートする</span>
<span class="n">vwredsumu</span><span class="o">.</span><span class="n">vs</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># 2*SEW = 2*SEW + sum(zero-extend(SEW))</span>

  <span class="c1"># 符号付きリダクション加算を倍幅でアキュムレートする</span>
<span class="n">vwredsum</span><span class="o">.</span><span class="n">vs</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span>   <span class="c1"># 2*SEW = 2*SEW + sum(sign-extend(SEW))</span>
</pre></div>
</div>
</div>
<div class="section" id="sec-vector-float-reduce">
<span id="id116"></span><h2>ベクトル単一幅浮動小数点リダクション命令<a class="headerlink" href="#sec-vector-float-reduce" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 単純なリダクション</span>
<span class="n">vfredosum</span><span class="o">.</span><span class="n">vs</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span> <span class="c1"># 順序付き加算</span>
<span class="n">vfredusum</span><span class="o">.</span><span class="n">vs</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span> <span class="c1"># 順序無し加算</span>
<span class="n">vfredmax</span><span class="o">.</span><span class="n">vs</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span> <span class="c1"># 最大値</span>
<span class="n">vfredmin</span><span class="o">.</span><span class="n">vs</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span> <span class="c1"># 最小値</span>
</pre></div>
</div>
<div class="section" id="id117">
<h3>ベクトル順序付き単一幅浮動小数点リダクション加算命令<a class="headerlink" href="#id117" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><cite>vfredosum</cite> 命令は、<cite>vs1[0]</cite> のスカラーから順に、
浮動小数点値を要素順に合計しなければなりません--つまり、以下のように計算を行います。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>vd[0] = `(((vs1[0] + vs2[0]) + vs2[1]) + ...) + vs2[vl-1]`
</pre></div>
</div>
<p>ここで各加算は、例外フラグの発生や特別な値の生成・伝搬という点で、スカラ浮動小数点演算命令と同じ動作をします。</p>
<p>演算がマスクされている場合(<cite>vm=0</cite>)、マスクされていない要素は結果や例外フラグに影響を与えません。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>この動作は、スカラの加算ループを自動ベクトル化する際のNaN、例外、丸めの処理と同一です。</p>
</div>
</div>
<div class="section" id="id118">
<h3>ベクトル順序無し単一幅浮動小数点リダクション加算命令<a class="headerlink" href="#id118" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>順序無しリダクション命令である <cite>vfredusum</cite> は、リダクションを実行する際の実装の自由度を高めます。</p>
<p>実装では、ソースのベクトルレジスタ群(<cite>vs2</cite>)とソースのスカラー値(<cite>vs1[0]</cite>)の要素を入力とし
バイナリ演算子ノードで構成されるリダクションツリーと同等の結果を生成する必要があります。
ツリー内の各演算子は、2つの入力を受け入れ、1つの結果を生成します。
各演算子は、まず、RISC-Vのスカラ浮動小数点加算として、指数の範囲と精度が無限大の正確な和を計算し、
次に、この正確な和を、SEWで示される要素浮動小数点フォーマットと少なくとも同じ範囲と精度を持つ浮動小数点フォーマットに変換し、
現在アクティブな浮動小数点ダイナミック丸めモードを用いて丸めます。
各演算子の結果には、異なる浮動小数点の範囲と精度を選択することができます。
一方の入力が、マスクされた要素やアクティブなベクトル長を超えた要素からのみ得られるノードは、
その入力を適切なEEWの加法単位元として扱うか、あるいは単に他方の入力をその出力にコピーすることができます。
ツリーのルートノードからの丸められた結果は、SEW で示される標準的な浮動小数点フォーマットに変換されます(動的丸めモードを使用して再度丸められます)。
実装では、最終結果に加法単位元を加えることができます。</p>
<p>加法単位元は、切り捨て(-{inf}方向)の場合は+0.0、その他の丸め方の場合は-0.0です。</p>
<p>リダクションツリーの構造は、<cite>vtype</cite> と <cite>vl</cite> に与えられた値に対して決定的でなければなりません。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>特に、アクティブな要素がなく、スカラー入力がNaNの場合、実装はNaNを正規化し、NaNがシグナリングの場合は、無効な例外フラグを設定することが許可されています。
また、<cite>vfredosum</cite> のように、元のNaNを通過させ、例外フラグを設定しないことも可能です。</p>
</div>
</div>
<div class="section" id="id119">
<h3>ベクトル単一幅浮動小数点最大・最小リダクション<a class="headerlink" href="#id119" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>その際、例外フラグは設定されず、NaNの処理も行われません。</p>
</div>
</div>
</div>
<div class="section" id="sec-vector-float-reduce-widen">
<span id="id120"></span><h2>ベクトル幅拡張浮動小数点リダクション命令<a class="headerlink" href="#sec-vector-float-reduce-widen" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>リダクション加算命令における幅拡張の形式は、倍幅のデータの読み書きを行います。。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># 単純なリダクション</span>
<span class="n">vfwredosum</span><span class="o">.</span><span class="n">vs</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span> <span class="c1"># 順序付きリダクション加算</span>
<span class="n">vfwredusum</span><span class="o">.</span><span class="n">vs</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span> <span class="c1"># 順序なしリダクション加算命令</span>
</pre></div>
</div>
<p>SEW幅の要素のリダクション操作は単一幅で行われ、<cite>vs2</cite> の要素は2*SEWに拡張されて2*SEWビットのアキュムレータに加算されます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p><cite>vfwredusum.vs</cite>  は <cite>vfredusum.vs</cite> と同様に動作します。</p>
</div>
</div>
</div>
<div class="section" id="sec-vector-mask">
<span id="id121"></span><h1>ベクトルマスク命令<a class="headerlink" href="#sec-vector-mask" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>ベクトルレジスタに格納されているマスクを操作するための命令がいくつか提供されています。</p>
<div class="section" id="sec-mask-register-logical">
<span id="id122"></span><h2>ベクトルマスクレジスタ論理命令<a class="headerlink" href="#sec-mask-register-logical" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトルマスクレジスタ論理命令は、マスクレジスタに対して演算を実行します。
マスクレジスタの各要素は1ビットであり、従ってこれらの命令は <cite>vtype</cite> フィールド内の <cite>vlmul</cite>  の設定に関係なく単一のベクトルレジスタを操作します。
これらの命令は <cite>vlmul</cite>  の設定を変更しません。
書き込みベクトルレジスタはソースベクトルレジスタと同一である可能性があります。</p>
<p>他のベクトル命令と同様に、<cite>vstart</cite> インデックスよりも小さな要素は変更されず、命令実行後には <cite>vstart</cite>  の値は0にリセットされます。
ベクトルマスク論理命令は常にマスクは適用されず、従って非アクティブ要素はありませんん。<cite>vm=0</cite> に相当するエンコーディングは予約されています。
<cite>vl</cite> 以降のマスク要素、つまり末尾エレメントは常にtail-agnosticポリシに基づいて更新されます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vmand</span><span class="o">.</span><span class="n">mm</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span>     <span class="c1"># vd.mask[i] =   vs2.mask[i] &amp;&amp;  vs1.mask[i]</span>
<span class="n">vmnand</span><span class="o">.</span><span class="n">mm</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span>    <span class="c1"># vd.mask[i] = !(vs2.mask[i] &amp;&amp;  vs1.mask[i])</span>
<span class="n">vmandnot</span><span class="o">.</span><span class="n">mm</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span>  <span class="c1"># vd.mask[i] =   vs2.mask[i] &amp;&amp; !vs1.mask[i]</span>
<span class="n">vmxor</span><span class="o">.</span><span class="n">mm</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span>    <span class="c1"># vd.mask[i] =   vs2.mask[i] ^^  vs1.mask[i]</span>
<span class="n">vmor</span><span class="o">.</span><span class="n">mm</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span>     <span class="c1"># vd.mask[i] =   vs2.mask[i] ||  vs1.mask[i]</span>
<span class="n">vmnor</span><span class="o">.</span><span class="n">mm</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span>    <span class="c1"># vd.mask[i] = !(vs2.mask[i] ||  vs1.mask[i])</span>
<span class="n">vmornot</span><span class="o">.</span><span class="n">mm</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span>  <span class="c1"># vd.mask[i] =   vs2.mask[i] || !vs1.mask[i]</span>
<span class="n">vmxnor</span><span class="o">.</span><span class="n">mm</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span>    <span class="c1"># vd.mask[i] = !(vs2.mask[i] ^^  vs1.mask[i])</span>
</pre></div>
</div>
<p>一般的に使用されるマスク論理操作のために、いくつかのアセンブラ疑似命令が定義されています。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vmmv</span><span class="o">.</span><span class="n">m</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs</span>  <span class="o">=&gt;</span> <span class="n">vmand</span><span class="o">.</span><span class="n">mm</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">vs</span>  <span class="c1"># Copy mask register</span>
<span class="n">vmclr</span><span class="o">.</span><span class="n">m</span> <span class="n">vd</span>     <span class="o">=&gt;</span> <span class="n">vmxor</span><span class="o">.</span><span class="n">mm</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vd</span>   <span class="c1"># Clear mask register</span>
<span class="n">vmset</span><span class="o">.</span><span class="n">m</span> <span class="n">vd</span>     <span class="o">=&gt;</span> <span class="n">vmxnor</span><span class="o">.</span><span class="n">mm</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vd</span>  <span class="c1"># Set mask register</span>
<span class="n">vmnot</span><span class="o">.</span><span class="n">m</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs</span> <span class="o">=&gt;</span> <span class="n">vmnand</span><span class="o">.</span><span class="n">mm</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">vs</span>  <span class="c1"># Invert bits</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>ビットが解釈無しにコピーされるため &quot;mv&quot;と読んだ方が整合性があります。
vmcpy.m アセンブラ疑似命令は互換性のために残されています。</p>
</div>
<p>8つのマスク論理命令は2つの入力マスクに対する任意の16個のバイナリ論理演算を実行することができます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>次のマスクされたベクトル演算と簡単に融合できるように設計されています。</p>
</div>
</div>
<div class="section" id="pop-vpopc">
<h2>ベクトルマスクPopカウント <cite>vpopc</cite><a class="headerlink" href="#pop-vpopc" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vpopc</span><span class="o">.</span><span class="n">m</span> <span class="n">rd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>
</pre></div>
</div>
<p>ソースオペランドは、 <a class="reference internal" href="#sec-mask-register-layout"><span class="std std-ref">マスクレジスタのレイアウト</span></a>  節で説明されているように、マスクレジスタの値を保持する単一のベクトルレジスタです。</p>
<p><cite>vpopc.m</cite> 命令は、ベクトルソースマスクレジスタのアクティブ要素のうち、値が1であるマスク要素の数を数え、その結果をスカラの <cite>x</cite>  レジスタに書き込みます。</p>
<p>この操作はマスク下で行うことができ、その場合はマスクされた要素のみがカウントされます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vpopc</span><span class="o">.</span><span class="n">m</span> <span class="n">rd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">v0</span><span class="o">.</span><span class="n">t</span> <span class="c1"># x[rd] = sum**i ( vs2.mask[i] &amp;&amp; v0.mask[i] )</span>
</pre></div>
</div>
<p><cite>vpopc.m</cite> 上の例外は、常に <cite>vstart</cite> が 0 で通知されます。
<cite>vpopc</cite> 命令は、<cite>vstart</cite> が0でない場合、不正命令例外を発生させます。</p>
</div>
<div class="section" id="vfirst-find-first-set">
<h2><cite>vfirst</cite> find-first-set マスクビット命令<a class="headerlink" href="#vfirst-find-first-set" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vfirst</span><span class="o">.</span><span class="n">m</span> <span class="n">rd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>
</pre></div>
</div>
<p><cite>vfirst</cite> 命令は、ソースマスクベクトルの中から、値1を持つ最も低い番号のアクティブな要素を見つけ、その要素のインデックスをGPRに書き込みます。
値が1のアクティブな要素がない場合は、-1が書き込まれます。</p>
<p>ベクトルの長さはどのような実装でも2^(XLEN-1)^ を超えることはありませんので、ソフトウェアは負の値(最上位ビットの設定)があれば、
要素が見つからないと仮定することができます。</p>
<p><cite>vfirst</cite> の例外は常に 0 の <cite>vstart</cite> で報告されます。
<cite>vstart</cite> が 0 でない場合、<cite>vfirst</cite> 命令は不正命令例外を発生させます。</p>
</div>
<div class="section" id="vmsbf-m-set-before-first">
<h2><cite>vmsbf.m</cite> set-before-firstマスクビット<a class="headerlink" href="#vmsbf-m-set-before-first" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   <span class="n">vmsbf</span><span class="o">.</span><span class="n">m</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>

<span class="c1"># 例</span>

    <span class="mi">7</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span>   <span class="n">要素番号</span>

    <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span>   <span class="n">v3</span> <span class="n">の値</span>
                      <span class="n">vmsbf</span><span class="o">.</span><span class="n">m</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span>
    <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span>   <span class="n">v2</span> <span class="n">の値</span>

    <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span>   <span class="n">v3</span> <span class="n">の値</span>
                      <span class="n">vmsbf</span><span class="o">.</span><span class="n">m</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span>
    <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span>   <span class="n">v2</span>

    <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span>   <span class="n">v3</span> <span class="n">値</span>
                      <span class="n">vmsbf</span><span class="o">.</span><span class="n">m</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span>
    <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span>   <span class="n">v2</span>

    <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span>   <span class="n">v0</span> <span class="n">の値</span>
    <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span>   <span class="n">v3</span> <span class="n">の値</span>
                      <span class="n">vmsbf</span><span class="o">.</span><span class="n">m</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">,</span> <span class="n">v0</span><span class="o">.</span><span class="n">t</span>
    <span class="mi">0</span> <span class="mi">1</span> <span class="n">x</span> <span class="n">x</span> <span class="n">x</span> <span class="n">x</span> <span class="mi">1</span> <span class="mi">1</span>   <span class="n">v2</span> <span class="n">の値</span>
</pre></div>
</div>
<p><cite>vmsbf.m</cite> 命令は、マスク・レジスタを入力とし、結果をマスク・レジスタに書き込みます。
この命令は、1である最初のソース要素の前にあるすべてのアクティブなマスク要素に1を書き込み、
その要素とそれに続くすべてのアクティブな要素に0を書き込みます。
ソースベクトルにセットビットがない場合、書き込みレジスタのすべてのアクティブ要素に1が書き込まれます。</p>
<p>書き込みマスクレジスタの末尾要素はtail-agnosticポリシに基づいて更新されます。</p>
<p><cite>vmsbf.m</cite> の例外は、常に <cite>vstart</cite> =0の状態で報告されます。
<cite>vmsbf</cite> 命令は、<cite>vstart</cite> が 0 でない場合、不正命令例外を発生します。</p>
<p>書き込みレジスタはソースレジスタをオーバラップすることは出来ません。
マスク付き命令の場合、<cite>v0</cite> マスクレジスタとオーバラップすることは出来ません。</p>
</div>
<div class="section" id="vmsif-m-set-including-first">
<h2><cite>vmsif.m</cite> set-including-first マスクビット命令<a class="headerlink" href="#vmsif-m-set-including-first" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトルset-including-first命令はset-before-first命令と似ていますが、
セットビットを含めるところが異なります。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   <span class="n">vmsif</span><span class="o">.</span><span class="n">m</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>

<span class="c1"># 例</span>

    <span class="mi">7</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span>   <span class="n">要素番号</span>

    <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span>   <span class="n">v3</span> <span class="n">の値</span>
                      <span class="n">vmsif</span><span class="o">.</span><span class="n">m</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span>
    <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span>   <span class="n">v2</span> <span class="n">の値</span>

    <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span>   <span class="n">v3</span> <span class="n">の値</span>
                      <span class="n">vmsif</span><span class="o">.</span><span class="n">m</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span>
    <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span>   <span class="n">v2</span>

    <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span>   <span class="n">v0</span> <span class="n">の値</span>
    <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span>   <span class="n">v3</span> <span class="n">の値</span>
                      <span class="n">vmsif</span><span class="o">.</span><span class="n">m</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">,</span> <span class="n">v0</span><span class="o">.</span><span class="n">t</span>
    <span class="mi">1</span> <span class="mi">1</span> <span class="n">x</span> <span class="n">x</span> <span class="n">x</span> <span class="n">x</span> <span class="mi">1</span> <span class="mi">1</span>   <span class="n">v2</span> <span class="n">の値</span>
</pre></div>
</div>
<p>書き込みマスクレジスタの末尾要素はtail-agnosticポリシに基づいて更新されます。</p>
<p><cite>vmsif.m</cite> の例外は、常に <cite>vstart</cite> =0の状態で報告されます。
<cite>vmsif</cite> 命令は、<cite>vstart</cite> が 0 でない場合、不正命令例外を発生します。</p>
<p>書き込みレジスタはソースレジスタをオーバラップすることは出来ません。
マスク付き命令の場合、<cite>v0</cite> マスクレジスタとオーバラップすることは出来ません。</p>
</div>
<div class="section" id="vmsof-m-set-only-first">
<h2><cite>vmsof.m</cite> set-only-first マスクビット命令<a class="headerlink" href="#vmsof-m-set-only-first" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>set-only-firstベクトル命令はset-before-first命令と似ていますが、
ビットがセットされている最初の要素のみを設定するところが異なります。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   <span class="n">vmsof</span><span class="o">.</span><span class="n">m</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>

<span class="c1"># 例</span>

    <span class="mi">7</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span>   <span class="n">要素番号</span>

    <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span>   <span class="n">v3</span> <span class="n">の値</span>
                      <span class="n">vmsof</span><span class="o">.</span><span class="n">m</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span>
    <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span>   <span class="n">v2</span> <span class="n">の値</span>

    <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span>   <span class="n">v3</span> <span class="n">の値</span>
                      <span class="n">vmsof</span><span class="o">.</span><span class="n">m</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span>
    <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span>   <span class="n">v2</span>

    <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span>   <span class="n">v0</span> <span class="n">の値</span>
    <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span>   <span class="n">v3</span> <span class="n">の値</span>
                      <span class="n">vmsof</span><span class="o">.</span><span class="n">m</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">,</span> <span class="n">v0</span><span class="o">.</span><span class="n">t</span>
    <span class="mi">0</span> <span class="mi">1</span> <span class="n">x</span> <span class="n">x</span> <span class="n">x</span> <span class="n">x</span> <span class="mi">0</span> <span class="mi">0</span>   <span class="n">v2</span> <span class="n">の値</span>
</pre></div>
</div>
<p>書き込みマスクレジスタの末尾要素はtail-agnosticポリシに基づいて更新されます。</p>
<p><cite>vmsof.m</cite> の例外は、常に <cite>vstart</cite> =0の状態で報告されます。
<cite>vmsof</cite> 命令は、<cite>vstart</cite> が 0 でない場合、不正命令例外を発生します。</p>
<p>書き込みレジスタはソースレジスタをオーバラップすることは出来ません。
マスク付き命令の場合、<cite>v0</cite> マスクレジスタとオーバラップすることは出来ません。</p>
</div>
<div class="section" id="id123">
<h2>ベクトルマスク命令の使用例<a class="headerlink" href="#id123" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下はベクトル化されたデータに依存するループ終了コードです。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">include</span><span class="p">::</span><span class="n">example</span><span class="o">/</span><span class="n">strcpy</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="n">lines</span><span class="o">=</span><span class="mf">4.</span><span class="o">.-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">include</span><span class="p">::</span><span class="n">example</span><span class="o">/</span><span class="n">strncpy</span><span class="o">.</span><span class="n">s</span><span class="p">[</span><span class="n">lines</span><span class="o">=</span><span class="mf">4.</span><span class="o">.-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="iota">
<h2>ベクトルIota命令<a class="headerlink" href="#iota" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><cite>viota.m</cite> 命令は、ソースベクトルマスクレジスタを読み込み、書き込みベクトルレジスタグループの各要素に
マスク・レジスタの要素のうち、インデックスがその要素よりも小さい要素のすべてのビットの合計、
すなわち、マスク値のパラレルプレフィックス和を書き込みます。</p>
<p>この命令はマスクを使用することができます。この場合アクティブな要素のみが
加算に使用されます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">viota</span><span class="o">.</span><span class="n">m</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vm</span>

<span class="c1"># 例</span>

    <span class="mi">7</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span>   <span class="n">要素数</span>

    <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span>   <span class="n">v2</span> <span class="n">の値</span>
                      <span class="n">viota</span><span class="o">.</span><span class="n">m</span> <span class="n">v4</span><span class="p">,</span> <span class="n">v2</span> <span class="c1"># Unmasked</span>
    <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span>   <span class="n">v4</span> <span class="n">の結果</span>

    <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span>   <span class="n">v0</span> <span class="n">の値</span>
    <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span>   <span class="n">v2</span> <span class="n">の値</span>
    <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span>   <span class="n">v4</span> <span class="n">の値</span>
                      <span class="n">viota</span><span class="o">.</span><span class="n">m</span> <span class="n">v4</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v0</span><span class="o">.</span><span class="n">t</span> <span class="c1"># Masked, vtype.vma=0</span>
    <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">5</span> <span class="mi">1</span> <span class="mi">7</span> <span class="mi">1</span> <span class="mi">0</span>   <span class="n">v4</span> <span class="n">の値</span>
</pre></div>
</div>
<p>SEWが結果の値よりも大きい場合は、結果値をゼロ拡張して出力要素を埋めます。
結果値が出力先のSEWをオーバーフローする場合は、最下位のSEWビットが保持されます。</p>
<p><cite>viota.m</cite>  の例外は、常に <cite>vstart</cite> =0として報告され、例外ハンドラの後に再開するときは、常に最初から実行が再開されます。
<cite>vstart</cite> が 0 でない場合は、不正命令例外が発生します。</p>
<p>書き込みレジスタグループはソース・レジスタと重なることはできず、マスクされている場合はマスク・レジスタ (<cite>v0</cite>) と重なることはできません。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>1つ目の理由は、時間的に長いベクトル・レジスタを持ち、ベクトル・レジスタのリネームを行わない実装において、WARハザードの回避を容易にするためです。
第二に、例外が単純化された後に実行を再開することを可能にするためです。</p>
</div>
<p><cite>viota.m</cite> 命令は、メモリ・スキャッタ命令(インデックス・ストア)と組み合わせて、
ベクトル圧縮機能を実行することができます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>      <span class="c1"># 入力メモリ配列から、非ゼロの要素を圧縮して出力メモリ配列に格納する</span>
    <span class="c1">#</span>
    <span class="c1"># size*t compact*non*zero(size*t n, const int* in, int* out)</span>
    <span class="c1"># {</span>
    <span class="c1">#   size**t i;</span>
    <span class="c1">#   size**t count = 0;</span>
    <span class="c1">#   int *p = out;</span>
    <span class="c1">#</span>
    <span class="c1">#   for (i=0; i&lt;n; i++)</span>
    <span class="c1">#   {</span>
    <span class="c1">#       const int v = *in++;</span>
    <span class="c1">#       if (v != 0)</span>
    <span class="c1">#           *p++ = v;</span>
    <span class="c1">#   }</span>
    <span class="c1">#</span>
    <span class="c1">#   return (size**t) (p - out);</span>
    <span class="c1"># }</span>
    <span class="c1">#</span>
    <span class="c1"># a0 = n</span>
    <span class="c1"># a1 = &amp;in</span>
    <span class="c1"># a2 = &amp;out</span>

<span class="n">compact</span><span class="o">*</span><span class="n">non</span><span class="o">*</span><span class="n">zero</span><span class="p">:</span>
    <span class="n">li</span> <span class="n">a6</span><span class="p">,</span> <span class="mi">0</span>                      <span class="c1"># 非ゼロ要素のカウンタをクリアする</span>
<span class="n">loop</span><span class="p">:</span>
    <span class="n">vsetvli</span> <span class="n">a5</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">e32</span><span class="p">,</span> <span class="n">m8</span><span class="p">,</span> <span class="n">ta</span><span class="p">,</span> <span class="n">ma</span>   <span class="c1"># 32-bit整数</span>
    <span class="n">vle32</span><span class="o">.</span><span class="n">v</span> <span class="n">v8</span><span class="p">,</span> <span class="p">(</span><span class="n">a1</span><span class="p">)</span>               <span class="c1"># 入力ベクトルをロードする</span>
      <span class="n">sub</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a5</span>               <span class="c1"># ロードした要素数を減算する</span>
      <span class="n">slli</span> <span class="n">a5</span><span class="p">,</span> <span class="n">a5</span><span class="p">,</span> <span class="mi">2</span>               <span class="c1"># 4倍する</span>
    <span class="n">vmsne</span><span class="o">.</span><span class="n">vi</span> <span class="n">v0</span><span class="p">,</span> <span class="n">v8</span><span class="p">,</span> <span class="mi">0</span>             <span class="c1"># 非ゼロの場所を特定する</span>
      <span class="n">add</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a5</span>               <span class="c1"># 入力ポインタを進める</span>
    <span class="n">vpopc</span><span class="o">.</span><span class="n">m</span> <span class="n">a5</span><span class="p">,</span> <span class="n">v0</span>                 <span class="c1"># v0中の非ゼロ値を数える</span>
    <span class="n">viota</span><span class="o">.</span><span class="n">m</span> <span class="n">v16</span><span class="p">,</span> <span class="n">v0</span>                <span class="c1"># アクティブ要素の出力オフセットを取得する</span>
      <span class="n">add</span> <span class="n">a6</span><span class="p">,</span> <span class="n">a6</span><span class="p">,</span> <span class="n">a5</span>               <span class="c1"># 要素数を加算する</span>
    <span class="n">vsll</span><span class="o">.</span><span class="n">vi</span> <span class="n">v16</span><span class="p">,</span> <span class="n">v16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">v0</span><span class="o">.</span><span class="n">t</span>      <span class="c1"># オフセットを4バイト分乗算する</span>
      <span class="n">slli</span> <span class="n">a5</span><span class="p">,</span> <span class="n">a5</span><span class="p">,</span> <span class="mi">2</span>               <span class="c1"># 非ゼロの要素の数を4バイト分乗算する</span>
    <span class="n">vsuxei32</span><span class="o">.</span><span class="n">v</span> <span class="n">v8</span><span class="p">,</span> <span class="p">(</span><span class="n">a2</span><span class="p">),</span> <span class="n">v16</span><span class="p">,</span> <span class="n">v0</span><span class="o">.</span><span class="n">t</span> <span class="c1"># スケールしたviotaの結果をマスクに基づいてメモリに書き込む</span>
      <span class="n">add</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a5</span>               <span class="c1"># 出力ポインタを進める</span>
      <span class="n">bnez</span> <span class="n">a0</span><span class="p">,</span> <span class="n">loop</span>                <span class="c1"># これ以上あるか？</span>

      <span class="n">mv</span> <span class="n">a0</span><span class="p">,</span> <span class="n">a6</span>                    <span class="c1"># カウント数を返す</span>
      <span class="n">ret</span>
</pre></div>
</div>
<p><cite>vid.v</cite> 命令は、各要素のインデックスを、0から <cite>vl</cite> -1までの書き込みベクトルレジスタグループに書き込みます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vid</span><span class="o">.</span><span class="n">v</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vm</span>  <span class="c1"># 要素のインデックスを書き込みレジスタに書き込む</span>
</pre></div>
</div>
<p>この命令はマスクを使用することができます。</p>
<p>この命令の <cite>vs2</cite>  フィールドは <cite>v0</cite> を設定しなければなりません、
そうでない場合のエンコーディングは <em>予約されています</em>。</p>
<p>結果がSEWよりも小さいビット幅である場合、ゼロ拡張して書き込み要素に書き込まれます。
結果がSEWよりも大きい場合、下位のSEWビットが保持されます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>同じデータパスを使用して、暗黙的なマスクソースを使用することで実装することができます。</p>
</div>
</div>
</div>
<div class="section" id="sec-vector-permute">
<span id="id124"></span><h1>ベクトル組み合わせ命令<a class="headerlink" href="#sec-vector-permute" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>ベクトルレジスタ内の要素を移動させるために、さまざまな並べ替え命令が用意されています。</p>
<div class="section" id="id125">
<h2>整数スカラ移動命令<a class="headerlink" href="#id125" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>整数スカラ読み込み・書き込み命令は、スカラ <cite>x</cite> レジスタとベクトルレジスタの要素0との間で1つの値を転送します。
この命令はLMULやベクトルレジスタグループを無視します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vmv</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">s</span> <span class="n">rd</span><span class="p">,</span> <span class="n">vs2</span>  <span class="c1"># x[rd] = vs2[0] (vs1=0)</span>
<span class="n">vmv</span><span class="o">.</span><span class="n">s</span><span class="o">.</span><span class="n">x</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span>  <span class="c1"># vd[0] = x[rs1] (vs2=0)</span>
</pre></div>
</div>
<p><cite>vmv.x.s</cite> は SEW 幅の単一要素をソースベクトルレジスタのインデックス0から書き込み整数レジスタにコピーする命令です。
SEW &gt; XLENの場合、最下位のXLENビットが転送され、上位のSEW-XLENビットは無視されます。
SEW &lt; XLENの場合、値はXLENビットに符号拡張されます。</p>
<p><cite>vmv.s.x</cite> 命令は、スカラ整数レジスタを書き込みベクトルレジスタの要素 0 にコピーします。
SEW &lt; XLENの場合、最下位のビットがコピーされ、XLEN-SEWの上位ビットは無視されます。
SEW &gt; XLENの場合、値はSEWビットに符号拡張されます。 書き込みベクトルレジスタ内の他の要素 ( 0 &lt; index &lt; VLEN/SEW ) は
現在の末尾agnostic/undisturbedポリシを使用して、末尾要素として扱われます。
<cite>vstart</cite> {ge}の場合  <cite>vl</cite> の場合、操作は行われず、書き込みレジスタは更新されません。</p>
<p><cite>vmv.x.s</cite> と <cite>vmv.s.x</cite> のマスク付きバージョン (<cite>vm=0</cite>) に対応するエンコーディングは予約されています。</p>
<div class="section" id="id126">
<h3>浮動小数点スカラ移動命令<a class="headerlink" href="#id126" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>浮動小数点スカラの読み込み・書き込み命令は、スカラ <cite>f</cite> レジスタとベクトルレジスタの要素0との間で1つの値を転送します。
この命令は、LMULとベクトルレジスタグループを無視します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vfmv</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">s</span> <span class="n">rd</span><span class="p">,</span> <span class="n">vs2</span>  <span class="c1"># f[rd] = vs2[0] (rs1=0)</span>
<span class="n">vfmv</span><span class="o">.</span><span class="n">s</span><span class="o">.</span><span class="n">f</span> <span class="n">vd</span><span class="p">,</span> <span class="n">rs1</span>  <span class="c1"># vd[0] = f[rs1] (vs2=0)</span>
</pre></div>
</div>
<p><cite>vfmv.f.s</cite> は、SEW幅の要素を1つだけ、コピー元のベクトルレジスタの要素0からコピー先のスカラ浮動小数点レジスタにコピーします。</p>
<p><cite>vfmv.s.f</cite> 命令は、スカラ浮動小数点レジスタを、書き込みベクトルレジスタの要素0にコピーします。
書き込みベクトルレジスタの他の要素(0 &lt; index &lt; VLEN/SW)は、現在のTail-agnostic/Undisturbedポリシを用いて、末尾要素として扱われます。
もし、<cite>vstart</cite> {ge} <cite>vl</cite> の場合、操作は行われず、書き込みレジスタは更新されません。</p>
<p><cite>vfmv.f.s</cite> と <cite>vfmv.s.f</cite>  のマスクバージョン(<cite>vm=0</cite>)に対応するエンコーディングは予約されています。</p>
</div>
</div>
<div class="section" id="id127">
<h2>ベクトルスライド命令<a class="headerlink" href="#id127" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>スライド命令は、ベクトルレジスタグループの要素を上下に移動させます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>実装では、特定のオフセット値を <cite>vslideup</cite> および <cite>vslidedown</cite> に最適化することができます。
特に、2の累乗オフセットは、他のオフセットよりも大幅に高速に動作する可能性があります。</p>
</div>
<p>すべての <cite>vslideup</cite>, <cite>vslidedown</cite>, <cite>v[f]slide1up</cite>, <cite>v[f]slide1down</cite> 命令において、<cite>vstart</cite> {ge} <cite>vl</cite> の場合、
この命令は操作を行わず、書き込みベクトルレジスタを変更せずに残します。</p>
<p>末尾要素については、Tail agnostic/undisturbedポリシに基づいて適用されます。</p>
<p>スライド命令はマスクされていて、マスク要素 <em>i</em> が、<em>書き込み</em> 要素 <em>i</em> を書き込むかどうかを制御している場合があります。
非アクティブな要素については、Mask undisturbed/agnosticポリシに従います。</p>
<div class="section" id="id128">
<h3>ベクトルスライドアップ命令<a class="headerlink" href="#id128" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vslideup</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>        <span class="c1"># vd[i+rs1] = vs2[i]</span>
<span class="n">vslideup</span><span class="o">.</span><span class="n">vi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">uimm</span><span class="p">,</span> <span class="n">vm</span>       <span class="c1"># vd[i+uimm] = vs2[i]</span>
</pre></div>
</div>
<p><cite>vslideup</cite> では、<cite>vl</cite> の値で、書き込みレジスタの最大要素数を指定します。
書き込みレジスタの開始インデックス (<em>OFFSET</em>) は、<cite>rs1</cite> で指定された <cite>x</cite> レジスタの符号なし整数、
または XLEN ビットにゼロ拡張された 5 ビットの即値のいずれかを使用して指定できます。
XLEN &gt; SEWの場合、<em>OFFSET</em> はSEWビットに切り捨てられません。
マスキングされておらず、かつ、 <em>OFFSET</em> &lt; <cite>vl</cite> であれば、 <em>OFFSET</em> から <cite>vl</cite> -1 までの出力要素が書き込まれます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="n">vslideup</span> <span class="n">の書き込みレジスタ要素の動作</span>

 <span class="n">OFFSET</span> <span class="ow">is</span> <span class="n">amount</span> <span class="n">to</span> <span class="n">slideup</span><span class="p">,</span> <span class="n">either</span> <span class="kn">from</span> <span class="nn">x</span> <span class="n">register</span> <span class="ow">or</span> <span class="n">a</span> <span class="mi">5</span><span class="o">-</span><span class="n">bit</span> <span class="n">immediate</span>

                  <span class="mi">0</span> <span class="o">&lt;</span>  <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">vstart</span><span class="p">,</span> <span class="n">OFFSET</span><span class="p">)</span>  <span class="n">Unchanged</span>
<span class="nb">max</span><span class="p">(</span><span class="n">vstart</span><span class="p">,</span> <span class="n">OFFSET</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vl</span>                   <span class="n">vd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vs2</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">OFFSET</span><span class="p">]</span> <span class="k">if</span> <span class="n">v0</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="n">enabled</span>
                 <span class="n">vl</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">VLMAX</span>                <span class="n">Follow</span> <span class="n">tail</span> <span class="n">policy</span>
</pre></div>
</div>
<p><cite>vslideup</cite> の書き込みベクトルレジスタグループはソースベクトルレジスタグループと重ならないようにしてください。</p>
</div>
<div class="section" id="id129">
<h3>ベクトルスライドダウン命令<a class="headerlink" href="#id129" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vslidedown</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>       <span class="c1"># vd[i] = vs2[i+rs1]</span>
<span class="n">vslidedown</span><span class="o">.</span><span class="n">vi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">uimm</span><span class="p">,</span> <span class="n">vm</span>      <span class="c1"># vd[i] = vs2[i+uimm]</span>
</pre></div>
</div>
<p><cite>vslidedown</cite>  では、<cite>vl</cite> の値は、書き込まれる宛先要素の最大数を指定します。
<cite>vl</cite> を過ぎた残りの要素は、現在の末尾ポリシ(<a class="reference internal" href="#sec-agnostic"><span class="std std-ref">Tail Agnostic とVector Mask Agnostic vta と vma</span></a>  節)に従って処理されます。</p>
<p>ソースの開始インデックス (<em>OFFSET</em>) は、<cite>rs1</cite> で指定された <cite>x</cite> レジスタの符号なし整数を使用して指定するか、
または XLEN ビットまでゼロ拡張された 5 ビットの即値を使用します。
XLEN &gt; SEWの場合、<a href="#id130"><span class="problematic" id="id131">*</span></a>OFFSET*はSEWビットに切り捨てられません。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vslidedown</span> <span class="n">behavior</span> <span class="k">for</span> <span class="n">source</span> <span class="n">elements</span> <span class="k">for</span> <span class="n">element</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">slide</span>
                 <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="o">+</span><span class="n">OFFSET</span> <span class="o">&lt;</span> <span class="n">VLMAX</span>   <span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vs2</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">OFFSET</span><span class="p">]</span>
             <span class="n">VLMAX</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="o">+</span><span class="n">OFFSET</span>           <span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">vslidedown</span> <span class="n">behavior</span> <span class="k">for</span> <span class="n">destination</span> <span class="n">element</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">slide</span>
                 <span class="mi">0</span> <span class="o">&lt;</span>  <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vstart</span>         <span class="n">Unchanged</span>
            <span class="n">vstart</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vl</span>             <span class="n">vd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">v0</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="n">enabled</span>
                <span class="n">vl</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">VLMAX</span>          <span class="n">Follow</span> <span class="n">tail</span> <span class="n">policy</span>
</pre></div>
</div>
</div>
<div class="section" id="slide1up">
<h3>ベクトル Slide1up<a class="headerlink" href="#slide1up" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>スライドのバリエーションとして、要素を1つ移動するだけでなく、
空いた要素の位置にスカラーの整数値を挿入できるものが用意されています。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vslide1up</span><span class="o">.</span><span class="n">vx</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>        <span class="c1"># vd[0]=x[rs1], vd[i+1] = vs2[i]</span>
<span class="n">vfslide1up</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>        <span class="c1"># vd[0]=f[rs1], vd[i+1] = vs2[i]</span>
</pre></div>
</div>
<p><cite>vslide1up</cite> 命令は、要素0がアクティブであれば、<cite>x</cite> レジスタの引数を書き込みベクトルレジスタグループの要素0に配置し、
そうでなければ、書き込みベクトル要素の更新は、現在のMask Agnostic/Undisturbed ポリシに従います。
XLEN &lt; SEWの場合、値はSEWビットに符号拡張されます。
XLEN &gt; SEWの場合、最下位のビットがコピーされ、SEW-XLENの上位ビットは無視されます。</p>
<p>残りのアクティブな <cite>vl</cite> -1 要素は、ソースベクトルレジスタ群のインデックス <em>i</em> から書き込みベクトルレジスタ群のインデックス <a href="#id132"><span class="problematic" id="id133">*</span></a>i*+1 にコピーオーバーされます。</p>
<p><cite>vl</cite> レジスタはソースの値で更新される書き込みベクトルレジスタ要素の最大数を指定し、
<cite>vl</cite> を超えた残りの要素は現在の末尾ポリシ(<a class="reference internal" href="#sec-agnostic"><span class="std std-ref">Tail Agnostic とVector Mask Agnostic vta と vma</span></a> 節)に従って処理されます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="n">vslide1up</span> <span class="n">behavior</span>

                  <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vstart</span>  <span class="n">unchanged</span>
              <span class="mi">0</span> <span class="o">=</span> <span class="n">i</span> <span class="o">=</span> <span class="n">vstart</span>  <span class="n">vd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">rs1</span><span class="p">]</span> <span class="k">if</span> <span class="n">v0</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="n">enabled</span>
<span class="nb">max</span><span class="p">(</span><span class="n">vstart</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vl</span>      <span class="n">vd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vs2</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">v0</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="n">enabled</span>
            <span class="n">vl</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">VLMAX</span>   <span class="n">Follow</span> <span class="n">tail</span> <span class="n">policy</span>
</pre></div>
</div>
<p><cite>vslide1up</cite> 命令は、書き込みベクトルレジスタグループがソースのベクトルレジスタグループと重ならないことが必要です。
それ以外の場合は、命令のエンコーディングは予約されています。</p>
<p><cite>vfslide1up</cite> 命令は類似して定義されていますが、そのスカラ引数を <cite>f</cite> レジスタから供給します。</p>
</div>
<div class="section" id="slide1down">
<h3>ベクトル Slide1down 命令<a class="headerlink" href="#slide1down" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><cite>vslide1down</cite> 命令は、最初の <cite>vl</cite>  -1個のアクティブな要素の値を、
ソースベクトルレジスタグループのインデックス <em>i</em> +1 から書き込みベクトルレジスタ群のインデックス*i*にコピーします。</p>
<p><cite>vl</cite> レジスタはソースの値で書き込まれる書き込みベクトルレジスタ要素の最大数を指定し、
<cite>vl</cite> を超えた残りの要素は現在の末尾ポリシ(<a class="reference internal" href="#sec-agnostic"><span class="std std-ref">Tail Agnostic とVector Mask Agnostic vta と vma</span></a> 節)に従って処理されます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vslide1down</span><span class="o">.</span><span class="n">vx</span>  <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>      <span class="c1"># vd[i] = vs2[i+1], vd[vl-1]=x[rs1]</span>
<span class="n">vfslide1down</span><span class="o">.</span><span class="n">vf</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span>      <span class="c1"># vd[i] = vs2[i+1], vd[vl-1]=f[rs1]</span>
</pre></div>
</div>
<p><cite>vslide1down</cite> 命令は、要素 <cite>vl-1</cite> がアクティブであれば、<cite>x</cite> レジスタの引数を書き込みベクトルレジスタの位置 <cite>vl</cite>  -1に置き、
そうでなければ、書き込み要素は変更されません。
XLEN &lt; SEWの場合、値はSEWビットに符号拡張されます。
XLEN &gt; SEWの場合、最下位のビットがコピーされ、SEW-XLENの上位ビットは無視されます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vslide1down</span> <span class="n">behavior</span>

                    <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vstart</span>  <span class="n">unchanged</span>
          <span class="n">vstart</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vl</span><span class="o">-</span><span class="mi">1</span>    <span class="n">vd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vs2</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">v0</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="n">enabled</span>
          <span class="n">vstart</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">=</span> <span class="n">vl</span><span class="o">-</span><span class="mi">1</span>    <span class="n">vd</span><span class="p">[</span><span class="n">vl</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">rs1</span><span class="p">]</span> <span class="k">if</span> <span class="n">v0</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="n">enabled</span>
              <span class="n">vl</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">VLMAX</span>   <span class="n">Follow</span> <span class="n">tail</span> <span class="n">policy</span>
</pre></div>
</div>
<p><cite>vfslide1down</cite> 命令は同様に定義されていますが、スカラー引数は <cite>f</cite> レジスタから供給されます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>これは、デバッガが複数回の <cite>vslide1down</cite> の呼び出しを繰り返すことで、ゆっくりではありますが、ベクトルレジスタの内容を変更するためのパスを提供します。</p>
</div>
</div>
</div>
<div class="section" id="id134">
<h2>ベクトルレジスタギャザー命令<a class="headerlink" href="#id134" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトル・レジスタ・ギャザー命令は、第2のソースベクトルレジスタグループによって与えられる位置から第1のソースベクトルレジスタグループの要素を読み出します。
第2ベクトルのインデックス値は、符号なし整数として扱われます。
ソースベクトルは、<cite>vl</cite> にかかわらず、任意のインデックス &lt; VLMAX で読み取ることができます。
書き込みレジスタに書き込む最大要素数は <cite>vl</cite> で与えられ、<cite>vl</cite> を過ぎた残りの要素は現在の末尾要素のポリシ (<a class="reference internal" href="#sec-agnostic"><span class="std std-ref">Tail Agnostic とVector Mask Agnostic vta と vma</span></a> 節) に従って処理されます。
この操作はマスクすることができ、非アクティブな要素に対しては、マスク undisturbed/agnostic ポリシに従います。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vrgather</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span> <span class="c1"># vd[i] = (vs1[i] &gt;= VLMAX) ? 0 : vs2[vs1[i]];</span>
<span class="n">vrgatherei16</span><span class="o">.</span><span class="n">vv</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span><span class="p">,</span> <span class="n">vm</span> <span class="c1"># vd[i] = (vs1[i] &gt;= VLMAX) ? 0 : vs2[vs1[i]];</span>
</pre></div>
</div>
<p><cite>vrgather.vv</cite> 形式では、データとインデックスの両方に SEW/LMUL を使用しています。
また、<cite>vrgatherei16.vv</cite> 形式では、<cite>vs2</cite> のデータには SEW/LMUL を使用しますが、
<cite>vs1</cite> のインデックスには EEW=16 と EMUL = (16/SEW)*LMUL を使用します。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>また，<cite>vrgatherei16</cite> 形式では，64K 個の要素のインデックスを作成することができ，
SEW &gt; 16 の場合にインデックスを保持するために必要なレジスタの容量を減らすために使用することもできます。</p>
</div>
<p>要素のインデックスが範囲外の場合 ( <cite>vs1[i]</cite> {ge} VLMAX )、要素の値は 0 を返します。</p>
<p>レジスタギャザーのベクトルスカラ形式とベクトル即値形式も用意されています。
これらは、与えられたインデックスでソース・ベクトルから1つの要素を読み、この値を書き込みベクトルレジスタの最初のアクティブの要素に書き込みます。
スカラレジスタのインデックス値と、XLENビットまでゼロ拡張された即値は、符号なし整数として扱われます。
XLEN &gt; SEWの場合，インデックス値はSEWビットまで切り捨てられません。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vrgather</span><span class="o">.</span><span class="n">vx</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">vm</span> <span class="c1"># vd[i] = (x[rs1] &gt;= VLMAX) ? 0 : vs2[x[rs1]]</span>
<span class="n">vrgather</span><span class="o">.</span><span class="n">vi</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">uimm</span><span class="p">,</span> <span class="n">vm</span> <span class="c1"># vd[i] = (uimm &gt;= VLMAX) ? 0 : vs2[uimm]</span>
</pre></div>
</div>
<p>任意の <cite>vrgather</cite> 命令では、書き込みベクトルレジスタグループはソースベクトルレジスタグループとオーバーラップすることはできません。</p>
</div>
<div class="section" id="id135">
<h2>ベクトル圧縮命令<a class="headerlink" href="#id135" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ベクトル圧縮命令は、ソースベクトルレジスタ群からベクトルマスクレジスタによって選択された要素を、
書き込みベクトルレジスタ群の先頭の連続した要素にパックすることができます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vcompress</span><span class="o">.</span><span class="n">vm</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span><span class="p">,</span> <span class="n">vs1</span>  <span class="c1"># vs1で有効なvs2の要素をvdに圧縮する</span>
</pre></div>
</div>
<p><cite>vs1</cite> で指定されたベクトルマスクレジスタは、ベクトルレジスタグループ <cite>vs2</cite> の最初の <cite>vl</cite> 要素のうち、
どの要素を抽出して、ベクトルレジスタ <cite>vd</cite> の先頭の連続した要素にパックすべきかを示します。
<cite>vd</cite> の残りの要素は、現在の末尾要素ポリシ (<a class="reference internal" href="#sec-agnostic"><span class="std std-ref">Tail Agnostic とVector Mask Agnostic vta と vma</span></a> 節) に従って、末尾要素として扱われます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vcompress命令の使用例</span>

    <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span>   <span class="n">v0</span>
    <span class="mi">8</span> <span class="mi">7</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span>   <span class="n">v1</span>
    <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span>   <span class="n">v2</span>

                            <span class="n">vcompress</span><span class="o">.</span><span class="n">vm</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v0</span>
    <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">8</span> <span class="mi">7</span> <span class="mi">5</span> <span class="mi">2</span> <span class="mi">0</span>   <span class="n">v2</span>
</pre></div>
</div>
<p><cite>vcompress</cite> は、マスクされていない命令(<cite>vm=1</cite>)としてエンコードされます。
同等のマスクされた命令(<cite>vm=0</cite>)は予約されています。</p>
<p>書き込みベクトルレジスタグループはソースベクトルレジスタグループやソースマスクレジスタと重なることはできません。</p>
<p>非ゼロの <cite>vstart</cite> で <cite>vcompress</cite> 命令を実行すると、不正命令例外が発生します。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>実装ではこれを行わずに要素 0 から再起動することを想定しています。</p>
</div>
<div class="section" id="vdecompress">
<h3><cite>vdecompress</cite> の合成<a class="headerlink" href="#vdecompress" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>逆の操作を行う <cite>vdecompress</cite> 命令は定義されていませんが、この操作はiota命令とマスク付き <cite>vrgather</cite> 命令を用いて合成できます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>`vdecompress` の所望の動作
  7 6 5 4 3 2 1 0     # vid

        e d c b a     # パッキングされたベクトルの5要素
  1 0 0 1 1 1 0 1     # 8要素のベクトルマスク
  p q r s t u v w     # vdecompress実行前の書き込みレジスタ

  e q r d c b v a     # vdecompress実行後
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># v0はマスクを保持している</span>
<span class="c1"># v1はパックデータを保持している</span>
<span class="c1"># v11は展開されたベクトルと結果を保持している</span>
<span class="n">viota</span><span class="o">.</span><span class="n">m</span> <span class="n">v10</span><span class="p">,</span> <span class="n">v0</span>                 <span class="c1"># v0のマスクを使用してiotaを実行する</span>
<span class="n">vrgather</span><span class="o">.</span><span class="n">vv</span> <span class="n">v11</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v10</span><span class="p">,</span> <span class="n">v0</span><span class="o">.</span><span class="n">t</span>  <span class="c1"># 書き込みレジスタを展開する</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="n">q</span> <span class="n">r</span> <span class="n">s</span> <span class="n">t</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>    <span class="c1"># v11書き込みレジスタ</span>
      <span class="n">e</span> <span class="n">d</span> <span class="n">c</span> <span class="n">b</span> <span class="n">a</span>    <span class="c1"># v1ソースレジスタ</span>
<span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span>    <span class="c1"># v0マスクレジスタ</span>

<span class="mi">4</span> <span class="mi">4</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span>    <span class="c1"># viota.m実行後のv10レジスタ</span>
<span class="n">e</span> <span class="n">q</span> <span class="n">r</span> <span class="n">d</span> <span class="n">c</span> <span class="n">b</span> <span class="n">v</span> <span class="n">a</span>    <span class="c1"># マスク付きviota.mを用いたvrgatherの書き込みレジスタ</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id136">
<h2>ベクトルレジスタ全体移動命令<a class="headerlink" href="#id136" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><cite>vmv&lt;nr&gt;r.v</cite> 命令は、ベクトルレジスタ全体(VLENビット全て)をコピーし、
ベクトルレジスタグループ全体をコピーすることができます。
EEW=SEW、EMUL=`nr` 、実効長 <cite>evl</cite> =EMUL * VLEN/SEWのように動作します。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>ベクトルレジスタをシャッフルすることを支援するためのものです。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>代わりに、<cite>vstart</cite> {ge} <cite>evl</cite> の場合には要素は書き込まれません。</p>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>そのレジスタグループが次に SEW に等しい EEW でアクセスされることを示すヒントとして扱われます。</p>
</div>
<p>この命令はOPIVI命令としてエンコードされます。 コピーするベクトルレジスタの数は、
メモリ命令の <cite>nf</cite> フィールドと同じエンコーディングで <cite>simm</cite> フィールドの下位3ビットにエンコードされます。
<cite>nr</cite> フィールドの値は、1、2、4、8のいずれかでなければならず、その他の値は予約されています。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>このエンコーディングが選ばれたのは、関連する <cite>vmerge</cite> エンコーディングに近いことと、<cite>vsmul</cite> 命令が即値フォームから恩恵を受ける可能性が低いことによります。</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vmv</span><span class="o">&lt;</span><span class="n">nr</span><span class="o">&gt;</span><span class="n">r</span><span class="o">.</span><span class="n">v</span> <span class="n">vd</span><span class="p">,</span> <span class="n">vs2</span>  <span class="c1"># 一般的なフォーム</span>

<span class="n">vmv1r</span><span class="o">.</span><span class="n">v</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span>   <span class="c1">#  v2をv1にコピーする</span>
<span class="n">vmv2r</span><span class="o">.</span><span class="n">v</span> <span class="n">v10</span><span class="p">,</span> <span class="n">v12</span> <span class="c1">#  v12をv10にコピーし、v13をv11にコピーする</span>
<span class="n">vmv4r</span><span class="o">.</span><span class="n">v</span> <span class="n">v4</span><span class="p">,</span> <span class="n">v8</span>   <span class="c1">#  v8をv4に、v9をv5に、v10をv6に、v11をv7にコピーする</span>
<span class="n">vmv8r</span><span class="o">.</span><span class="n">v</span> <span class="n">v0</span><span class="p">,</span> <span class="n">v8</span>   <span class="c1">#  v8をv0に、v9をv1に、... v15をv7にコピーする</span>
</pre></div>
</div>
<p>ソースと書き込みのベクトルレジスタ番号は、ベクトルレジスタグループのサイズに合わせて適切にアラインメントする必要があり、
他のベクトルレジスタ番号とのエンコーディングは予約されています。</p>
</div>
</div>
<div class="section" id="id137">
<h1>例外処理<a class="headerlink" href="#id137" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>ベクトル命令中の例外(同期例外または非同期割込みのいずれかが原因)では、
既存の <cite>*epc</cite>  CSR には例外の発生したベクトル命令へのポインタが書き込まれ、
<cite>vstart</cite>  CSR には例外の原因となった要素のインデックスが書き込まれます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>これは、IBM 3090のベクトル機能のスキームに似ています。
<cite>vstart</cite>  CSRなしで前進性を確保するためには、実装は、ベクトル命令全体が例外を発生させることなく常にアトミックに完了することを保証しなければなりません。
これは、ストライド演算やスキャッタ/ギャザ演算、デマンドページングされた仮想メモリがある場合には、特に困難です。</p>
</div>
<div class="section" id="id138">
<h2>正確なベクトル例外<a class="headerlink" href="#id138" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>正確なベクトル例外には以下の要件が必要です:</p>
<ul class="simple">
<li><p>例外の発生したベクトル命令よりも古い命令が結果をコミットしていること</p></li>
<li><p>例外の発生したベクトル命令よりも新しい命令がアーキテクチャ状態を変更していないこと</p></li>
<li><p>例外の発生したベクトル命令内で、 <cite>vstart</cite>  CSR のインデックスより前の結果要素に影響を与える演算が結果をコミットしていること</p></li>
<li><p>例外の発生したベクトル命令内で、 <cite>vstart</cite>  CSR 以降の要素に影響を与える演算がアーキテクチャ状態を変更していないこと。ただし、影響を受けるベクトル命令を再起動して完了させても、正しい最終状態が得られる場合を除く。</p></li>
</ul>
<p>最後の要件を緩和して、例外が報告された時点で <cite>vstart</cite>  以降の要素が更新されていても、
与えられた <cite>vstart</cite>  から命令を再実行することでそれらの要素が正しく上書きされることを許可します。</p>
<p>非デバイスメモリ領域では、ベクトルストア命令が、同期例外の原因となった要素を超えて、メモリ内の要素を更新している可能性があります。
デバイスメモリ領域では、ベクトルストア命令中に同期例外を引き起こした要素と同じかそれ以上のインデックスで更新されていてはなりません。</p>
<p>上述の場合を除き、ベクトル命令は入力を上書きすることができますので、ほとんどの場合、
ベクトル命令の再起動は <cite>vstart</cite>  の位置からでなければなりません。
しかし、ベクトル命令の実行結果が常に同一であり、どの場所からでも再起動できるようにするために、
この上書きを禁止するケースがいくつかあります。</p>
<p>実装では、<cite>vstart</cite> で報告された要素やセグメントについて、最終的に前進が保証されるようにしなければなりません。</p>
</div>
<div class="section" id="id139">
<h2>不正確ベクトル例外<a class="headerlink" href="#id139" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>不正確なベクトル例外とは、正確ではない例外のことです。
特に、 <cite>*epc</cite> よりも新しい命令は結果をコミットしているかもしれませんし、 <cite>*epc</cite> よりも古い命令は実行を完了していないかもしれません。
不正確な例外は主に、エラーを報告して実行を終了することが適切な反応である場合に使用することを意図しています。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>多くの組み込み機器では、致命的なエラーが発生したときには、再開可能な例外を必要としないため、
ベクトル命令のための不正確な例外のみを生成することを想定しています。</p>
</div>
<p>不正確な例外は、同期ベクトル例外によって引き起こされた例外のために、<cite>vstart</cite> で障害要素を報告しなければなりません。</p>
</div>
<div class="section" id="id140">
<h2>正確・不正確選択可能な例外<a class="headerlink" href="#id140" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>プロファイルによっては、特権モードのビットを用意して、正確なベクトル例外と不正確ベクトル例外を選択することができます。
不正確なモードでは、高性能に動作しますが、エラーの原因を特定することが困難になる可能性があります。
一方、正確なモードでは、動作速度が遅くなりますが、不正確なモードと同じエラーが発生しない可能性があるものの、
エラーのデバッグが行いやすくなります。</p>
</div>
<div class="section" id="id141">
<h2>スワップ可能な例外<a class="headerlink" href="#id141" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>別の例外モードでは、ベクトルユニットのスワップ可能な状態をサポートし、
例外時に特別な命令でベクトルユニットのマイクロアーキテクチャの状態を保存・復元することで、
不正確な例外の周辺でも実行を正しく継続できるようにします。</p>
<p>このメカニズムは、現在の標準拡張では定義されていません。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>ベクトルユニットの実装から不透明なマイクロアーキテクチャの状態を保存・復元する標準的な方法を定義する可能性があります。</p>
</div>
</div>
</div>
<div class="section" id="sec-vector-extensions">
<span id="id142"></span><h1>標準ベクトル拡張<a class="headerlink" href="#sec-vector-extensions" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>このセクションでは、パブリックレビューのために提案される標準ベクトル拡張について説明します。
組み込み用途を目的とした小規模な拡張機能のセットには &quot;Zve &quot;という接頭辞を付け、
アプリケーションプロセッサ向けに設計された大規模なベクター拡張機能には1文字のVという拡張子を付けています。</p>
<p>初期のベクトル拡張は、暗号や機械学習などの様々な領域で追加のベクトル拡張を行うためのベースとして設計されています。</p>
<div class="section" id="zve">
<h2>Zve*: 組み込みプロセッサ用のベクトル拡張<a class="headerlink" href="#zve" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下の5つの標準的な拡張機能は、さまざまな程度のベクトルサポートを提供するために定義されており、
組み込みプロセッサでの使用を目的としています。
これらの拡張機能は、XLEN=32 または XLEN=64 のベース ISA に追加することができます。
表には、各拡張機能の最小VLENとサポートされるEEW、およびサポートされる浮動小数点型を示しています。</p>
<p>全ての Zve* 拡張は正確な例外を持ちます。</p>
<p>すべてのZve*拡張は、8,16,32のEEWをサポートしており、Zve64*拡張は64のEEWもサポートしています。</p>
<p>すべての Zve* 拡張機能は、ベクトル構成命令 (<a class="reference internal" href="#sec-vector-config"><span class="std std-ref">コンフィグレーション設定命令 (vsetvli/vsetivl/vsetvl)</span></a>  節) をサポートしています。</p>
<p>全ての Zve* 拡張は全てのベクトルロード・ストア命令(<a class="reference internal" href="#sec-vector-memory"><span class="std std-ref">ベクトルロード・ストア命令</span></a> 節)をサポートしていますが、
Zve64* 拡張は XLEN=32 の時のインデックス値に対する EEW=64 をサポートしていません。</p>
<p>すべての Zve* 拡張は、すべてのベクトル整数命令 (<a class="reference internal" href="#sec-vector-integer"><span class="std std-ref">ベクトル整数算術演算命令</span></a> 節) をサポートしています。
ただし、積の上位ワードを返す <cite>vmulh</cite>  整数乗算バリエーション (<cite>vmulh.vv</cite>, <cite>vmulh.vx</cite>, <cite>vmulhu.vv</cite>, <cite>vmulhu.vx</cite>, <cite>vmulhsu.vv</cite>, <cite>vmulhsu.vx</cite> ) は、Zve64* では EEW=64 に対応していません。</p>
<p>すべてのZve*拡張は、すべてのベクトル固定小数点演算命令（<a class="reference internal" href="#sec-vector-fixed-point"><span class="std std-ref">ベクトル固定小数点算術演算命令</span></a> ）をサポートしています。
ただし、 <cite>vsmul.vv</cite> と <cite>vsmul.vx</cite> は、Zve64*のEEW=64ではサポートされていません。</p>
<p>すべての Zve* 拡張は、すべてのベクトル整数の単一幅および幅拡張および幅縮小操作をサポートします (<a class="reference internal" href="#sec-vector-integer-reduce"><span class="std std-ref">ベクトル単一幅整数リダクション命令</span></a> 節, <a class="reference internal" href="#sec-vector-integer-reduce-widen"><span class="std std-ref">ベクトル幅拡張整数リダクション命令</span></a> 節)。</p>
<p>全ての Zve* 拡張は全てのベクトルマスク命令をサポートします (<a class="reference internal" href="#sec-vector-mask"><span class="std std-ref">ベクトルマスク命令</span></a> 節)。</p>
<p>Zve32x と Zve64x が浮動小数点スカラ移動命令を実装していないことを除いて、
すべての Zve* 拡張はすべてのベクトル組み合わせ命令 (<a class="reference internal" href="#sec-vector-permute"><span class="std std-ref">ベクトル組み合わせ命令</span></a> 節) をサポートしています。</p>
<p>Zve32fおよびZve64f拡張は、スカラ・プロセッサがF拡張を実装し、EEW=32の浮動小数点オペランドに対するすべてのベクトル浮動小数点命令（<a class="reference internal" href="#sec-vector-float"><span class="std std-ref">ベクトル浮動小数点命令</span></a> 節）を実装することを要求し、
サポートされているすべての整数EEWとの間の変換命令が提供されています。
EEW=32のベクトル単幅浮動小数点演算(<a class="reference internal" href="#sec-vector-float-reduce"><span class="std std-ref">ベクトル単一幅浮動小数点リダクション命令</span></a> 節)をサポートしています。</p>
<p>Zve32d および Zve64d 拡張は、スカラ・プロセッサが D 拡張を実装し、EEW=32 または EEW=64 の浮動小数点オペランドに対するすべてのベクトル浮動小数点命令 (<a class="reference internal" href="#sec-vector-float"><span class="std std-ref">ベクトル浮動小数点命令</span></a> 節) を実装する必要があります
(幅拡張命令および FP32 と FP64 の間の変換を含む)。
EEW=32およびEEW=64のベクトル単幅浮動小数点演算(<a class="reference internal" href="#sec-vector-float-reduce"><span class="std std-ref">ベクトル単一幅浮動小数点リダクション命令</span></a> 節)がサポートされており、
FP32からFP64への幅拡張リダクションもサポートされています。</p>
</div>
<div class="section" id="v">
<h2>V: アプリケーションプロセッサのためのベクトル拡張<a class="headerlink" href="#v" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>1文字のV拡張は、アプリケーションプロセッサのプロファイルでの使用を目的としています。</p>
<p>V ベクトル拡張には正確なトラップをサポートします。</p>
<p>V ベクトル拡張は、VLEN {ge} 128 が必要です。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>VLEN を大きくすると、短いベクターの場合にストリップマイニングコードを省略できる場合がありますが、
最小実装のサイズが大きくなります。
LMULを大きくすると、既知のサイズの長いアプリケーションベクターのストリップマイニングを回避することができますが、
利用可能なベクトルレジスタグループの数が少なくなりますので注意してください。
たとえば、LMULが8の場合、最大16個の64ビット要素を持つベクトルを、4つのベクトルレジスターグループを使用して、
ストリップマイニングを行わずに処理することができます。</p>
</div>
<p>V拡張は、8、16、32、および64のEEWをサポートしています。</p>
<p>V拡張は，ベクトルコンフィグレーション設定命令(vsetvli/vsetivl/vsetvl)をサポートしています。</p>
<p>V拡張は全てのロードストア命令をサポートしていますが(<a class="reference internal" href="#sec-vector-memory"><span class="std std-ref">ベクトルロード・ストア命令</span></a> 節)
XLEN=32の時のインデックス値に関するEEW=64のV拡張はサポートされていません。</p>
<p>V拡張機能は、すべてのベクトル整数命令 (<a class="reference internal" href="#sec-vector-integer"><span class="std std-ref">ベクトル整数算術演算命令</span></a> 節) をサポートしています。</p>
<p>V 拡張機能は、すべてのベクトル固定小数点演算命令 (<a class="reference internal" href="#sec-vector-integer"><span class="std std-ref">ベクトル整数算術演算命令</span></a> 節) をサポートしています。</p>
<p>V拡張は、すべてのベクトル整数の単一幅および幅縮小演算をサポートしています(<a class="reference internal" href="#sec-vector-integer-reduce"><span class="std std-ref">ベクトル単一幅整数リダクション命令</span></a> ,
<a class="reference internal" href="#sec-vector-integer-reduce-widen"><span class="std std-ref">ベクトル幅拡張整数リダクション命令</span></a> 節)。</p>
<p>V 拡張機能は、すべてのベクトルマスク命令をサポートします (<a class="reference internal" href="#sec-vector-mask"><span class="std std-ref">ベクトルマスク命令</span></a> 節)。</p>
<p>V拡張は、すべてのベクトル組み合わせ命令をサポートしています(<a class="reference internal" href="#sec-vector-permute"><span class="std std-ref">ベクトル組み合わせ命令</span></a> 節)。</p>
<p>また、EEW=32 または EEW=64 の浮動小数点オペランドに対するすべてのベクトル浮動小数点命令 (<a class="reference internal" href="#sec-vector-float"><span class="std std-ref">ベクトル浮動小数点命令</span></a> 節) を実装します (幅拡張命令およびFP32とFP64 間の変換を含む)。
EEW=32およびEEW=64のベクトル単一幅浮動小数点リダクション命令(<a class="reference internal" href="#sec-vector-float-reduce"><span class="std std-ref">ベクトル単一幅浮動小数点リダクション命令</span></a> ) は、FP32からFP64への幅拡張リダクションと同様にサポートされています。</p>
</div>
</div>
<div class="section" id="id143">
<h1>ベクトル命令リスト<a class="headerlink" href="#id143" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>include::inst-table.adoc[]</p>
<p>include::vector-examples.adoc[]</p>
<p>include::calling-convention.adoc[]</p>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="RISC-V &#34;V&#34; ベクトル拡張" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; 著作権 2019, msyksphinz

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>